//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ClientCodeClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param module (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getFile(module: SahabModules | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Common/ClientCode/GetFile?";
        if (module === null)
            throw new Error("The parameter 'module' cannot be null.");
        else if (module !== undefined)
            url_ += "module=" + encodeURIComponent("" + module) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CommonLookupsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param commonType (optional) 
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getList(commonType: CommonLookups | undefined, usingInFilter: boolean | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<CommonLookupDto> {
        let url_ = this.baseUrl + "/api/Common/CommonLookups/GetList?";
        if (commonType === null)
            throw new Error("The parameter 'commonType' cannot be null.");
        else if (commonType !== undefined)
            url_ += "commonType=" + encodeURIComponent("" + commonType) + "&";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CommonLookupDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CommonLookupDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommonLookupDto>(null as any);
    }
}

export class ExternalSystemClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<FullExternalSystemDto> {
        let url_ = this.baseUrl + "/api/Common/ExternalSystem/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullExternalSystemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullExternalSystemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullExternalSystemDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<ExternalSystemDto> {
        let url_ = this.baseUrl + "/api/Common/ExternalSystem/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ExternalSystemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExternalSystemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalSystemDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<ExternalSystemDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Common/ExternalSystem/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<ExternalSystemDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExternalSystemDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalSystemDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<ExternalSystemDto[]> {
        let url_ = this.baseUrl + "/api/Common/ExternalSystem/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<ExternalSystemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExternalSystemDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalSystemDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: NewExternalSystemDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Common/ExternalSystem/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: UpdateExternalSystemDto | undefined, signal?: AbortSignal): Promise<UpdateExternalSystemDto> {
        let url_ = this.baseUrl + "/api/Common/ExternalSystem/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateExternalSystemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateExternalSystemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateExternalSystemDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/ExternalSystem/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/ExternalSystem/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class JorCentralBankExportLogClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<CentralBankExportLogDto> {
        let url_ = this.baseUrl + "/api/Common/JorCentralBankExportLog/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CentralBankExportLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CentralBankExportLogDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CentralBankExportLogDto>(null as any);
    }

    /**
     * @param succeeded (optional) 
     * @param fileId (optional) 
     * @param fileName (optional) 
     * @param type (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getList(succeeded: boolean | undefined, fileId: number | undefined, fileName: string | undefined, type: ExportLogType | undefined, date_From: string | undefined, date_To: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<CentralBankExportLogListDto[]> {
        let url_ = this.baseUrl + "/api/Common/JorCentralBankExportLog/GetList?";
        if (succeeded === null)
            throw new Error("The parameter 'succeeded' cannot be null.");
        else if (succeeded !== undefined)
            url_ += "Succeeded=" + encodeURIComponent("" + succeeded) + "&";
        if (fileId === null)
            throw new Error("The parameter 'fileId' cannot be null.");
        else if (fileId !== undefined)
            url_ += "FileId=" + encodeURIComponent("" + fileId) + "&";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CentralBankExportLogListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CentralBankExportLogListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CentralBankExportLogListDto[]>(null as any);
    }
}

export class JorCentralBankServiceClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    exportSendTransactions(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: DateTimeRangeFilter | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Common/JorCentralBankService/ExportSendTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportSendTransactions(_response);
        });
    }

    protected processExportSendTransactions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    exportReceiveTransactions(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: DateTimeRangeFilter | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Common/JorCentralBankService/ExportReceiveTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportReceiveTransactions(_response);
        });
    }

    protected processExportReceiveTransactions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    exportExchangeTransactions(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: DateTimeRangeFilter | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Common/JorCentralBankService/ExportExchangeTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportExchangeTransactions(_response);
        });
    }

    protected processExportExchangeTransactions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LookupCategoryClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<FullLookupCategoryDto> {
        let url_ = this.baseUrl + "/api/Common/LookupCategory/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullLookupCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullLookupCategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullLookupCategoryDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<LookupCategoryDto> {
        let url_ = this.baseUrl + "/api/Common/LookupCategory/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<LookupCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LookupCategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupCategoryDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<LookupCategoryDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Common/LookupCategory/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<LookupCategoryDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LookupCategoryDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupCategoryDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<LookupCategoryDto[]> {
        let url_ = this.baseUrl + "/api/Common/LookupCategory/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<LookupCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LookupCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupCategoryDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: NewLookupCategoryDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Common/LookupCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: UpdateLookupCategoryDto | undefined, signal?: AbortSignal): Promise<UpdateLookupCategoryDto> {
        let url_ = this.baseUrl + "/api/Common/LookupCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateLookupCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateLookupCategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateLookupCategoryDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/LookupCategory/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/LookupCategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class LookupMappingClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<AddLookupMappingDto> {
        let url_ = this.baseUrl + "/api/Common/LookupMapping/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<AddLookupMappingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AddLookupMappingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddLookupMappingDto>(null as any);
    }

    /**
     * @param lookupCategoryId (optional) 
     * @param externalSystemId (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getList(lookupCategoryId: number | undefined, externalSystemId: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<LookupMappingDto[]> {
        let url_ = this.baseUrl + "/api/Common/LookupMapping/GetList?";
        if (lookupCategoryId === null)
            throw new Error("The parameter 'lookupCategoryId' cannot be null.");
        else if (lookupCategoryId !== undefined)
            url_ += "lookupCategoryId=" + encodeURIComponent("" + lookupCategoryId) + "&";
        if (externalSystemId === null)
            throw new Error("The parameter 'externalSystemId' cannot be null.");
        else if (externalSystemId !== undefined)
            url_ += "externalSystemId=" + encodeURIComponent("" + externalSystemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<LookupMappingDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LookupMappingDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupMappingDto[]>(null as any);
    }

    /**
     * @param lookupCategoryId (optional) 
     * @param localId (optional) 
     * @param externalSystemId (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getExternal(lookupCategoryId: number | undefined, localId: number | undefined, externalSystemId: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<ExternaItemDto> {
        let url_ = this.baseUrl + "/api/Common/LookupMapping/GetExternal?";
        if (lookupCategoryId === null)
            throw new Error("The parameter 'lookupCategoryId' cannot be null.");
        else if (lookupCategoryId !== undefined)
            url_ += "lookupCategoryId=" + encodeURIComponent("" + lookupCategoryId) + "&";
        if (localId === null)
            throw new Error("The parameter 'localId' cannot be null.");
        else if (localId !== undefined)
            url_ += "localId=" + encodeURIComponent("" + localId) + "&";
        if (externalSystemId === null)
            throw new Error("The parameter 'externalSystemId' cannot be null.");
        else if (externalSystemId !== undefined)
            url_ += "externalSystemId=" + encodeURIComponent("" + externalSystemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExternal(_response);
        });
    }

    protected processGetExternal(response: AxiosResponse): Promise<ExternaItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExternaItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternaItemDto>(null as any);
    }

    /**
     * @param lookupCategoryId (optional) 
     * @param externalId (optional) 
     * @param externalSystemId (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getLocal(lookupCategoryId: number | undefined, externalId: string | undefined, externalSystemId: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<ExternaItemDto> {
        let url_ = this.baseUrl + "/api/Common/LookupMapping/GetLocal?";
        if (lookupCategoryId === null)
            throw new Error("The parameter 'lookupCategoryId' cannot be null.");
        else if (lookupCategoryId !== undefined)
            url_ += "lookupCategoryId=" + encodeURIComponent("" + lookupCategoryId) + "&";
        if (externalId === null)
            throw new Error("The parameter 'externalId' cannot be null.");
        else if (externalId !== undefined)
            url_ += "externalId=" + encodeURIComponent("" + externalId) + "&";
        if (externalSystemId === null)
            throw new Error("The parameter 'externalSystemId' cannot be null.");
        else if (externalSystemId !== undefined)
            url_ += "externalSystemId=" + encodeURIComponent("" + externalSystemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLocal(_response);
        });
    }

    protected processGetLocal(response: AxiosResponse): Promise<ExternaItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExternaItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternaItemDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param externalSystemId (optional) 
     * @param lookupCategoryId (optional) 
     * @param fileType (optional) 
     * @param file (optional) 
     * @param externalIdConfiguration_Type (optional) 
     * @param externalIdConfiguration_Key (optional) 
     * @param externalIdConfiguration_Index (optional) 
     * @param externalNameConfiguration_Type (optional) 
     * @param externalNameConfiguration_Key (optional) 
     * @param externalNameConfiguration_Index (optional) 
     * @return Success
     */
    seedData(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, externalSystemId: number | undefined, lookupCategoryId: number | undefined, fileType: LookupCategoryFileTypes | undefined, file: FileParameter | undefined, externalIdConfiguration_Type: MappingType | undefined, externalIdConfiguration_Key: string | undefined, externalIdConfiguration_Index: number | undefined, externalNameConfiguration_Type: MappingType | undefined, externalNameConfiguration_Key: string | undefined, externalNameConfiguration_Index: number | undefined, signal?: AbortSignal): Promise<ExternaItemDto> {
        let url_ = this.baseUrl + "/api/Common/LookupMapping/SeedData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (externalSystemId === null || externalSystemId === undefined)
            throw new Error("The parameter 'externalSystemId' cannot be null.");
        else
            content_.append("ExternalSystemId", externalSystemId.toString());
        if (lookupCategoryId === null || lookupCategoryId === undefined)
            throw new Error("The parameter 'lookupCategoryId' cannot be null.");
        else
            content_.append("LookupCategoryId", lookupCategoryId.toString());
        if (fileType === null || fileType === undefined)
            throw new Error("The parameter 'fileType' cannot be null.");
        else
            content_.append("FileType", fileType.toString());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (externalIdConfiguration_Type === null || externalIdConfiguration_Type === undefined)
            throw new Error("The parameter 'externalIdConfiguration_Type' cannot be null.");
        else
            content_.append("ExternalIdConfiguration.Type", externalIdConfiguration_Type.toString());
        if (externalIdConfiguration_Key === null || externalIdConfiguration_Key === undefined)
            throw new Error("The parameter 'externalIdConfiguration_Key' cannot be null.");
        else
            content_.append("ExternalIdConfiguration.Key", externalIdConfiguration_Key.toString());
        if (externalIdConfiguration_Index === null || externalIdConfiguration_Index === undefined)
            throw new Error("The parameter 'externalIdConfiguration_Index' cannot be null.");
        else
            content_.append("ExternalIdConfiguration.Index", externalIdConfiguration_Index.toString());
        if (externalNameConfiguration_Type === null || externalNameConfiguration_Type === undefined)
            throw new Error("The parameter 'externalNameConfiguration_Type' cannot be null.");
        else
            content_.append("ExternalNameConfiguration.Type", externalNameConfiguration_Type.toString());
        if (externalNameConfiguration_Key === null || externalNameConfiguration_Key === undefined)
            throw new Error("The parameter 'externalNameConfiguration_Key' cannot be null.");
        else
            content_.append("ExternalNameConfiguration.Key", externalNameConfiguration_Key.toString());
        if (externalNameConfiguration_Index === null || externalNameConfiguration_Index === undefined)
            throw new Error("The parameter 'externalNameConfiguration_Index' cannot be null.");
        else
            content_.append("ExternalNameConfiguration.Index", externalNameConfiguration_Index.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSeedData(_response);
        });
    }

    protected processSeedData(response: AxiosResponse): Promise<ExternaItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExternaItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternaItemDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: AddLookupMappingDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Common/LookupMapping/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: UpdateLookupMappingDto | undefined, signal?: AbortSignal): Promise<UpdateLookupMappingDto> {
        let url_ = this.baseUrl + "/api/Common/LookupMapping/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateLookupMappingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateLookupMappingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateLookupMappingDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/LookupMapping/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/LookupMapping/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class PurposeClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<FullPurposeDto> {
        let url_ = this.baseUrl + "/api/Common/Purpose/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullPurposeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullPurposeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullPurposeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<PurposeDto> {
        let url_ = this.baseUrl + "/api/Common/Purpose/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<PurposeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PurposeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PurposeDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<PurposeDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Common/Purpose/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<PurposeDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PurposeDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PurposeDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<PurposeDto[]> {
        let url_ = this.baseUrl + "/api/Common/Purpose/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<PurposeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<PurposeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PurposeDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: NewPurposeDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Common/Purpose/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: UpdatePurposeDto | undefined, signal?: AbortSignal): Promise<UpdatePurposeDto> {
        let url_ = this.baseUrl + "/api/Common/Purpose/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdatePurposeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdatePurposeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdatePurposeDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/Purpose/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/Purpose/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class RelationClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<FullRelationDto> {
        let url_ = this.baseUrl + "/api/Common/Relation/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullRelationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullRelationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullRelationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<RelationDto> {
        let url_ = this.baseUrl + "/api/Common/Relation/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<RelationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RelationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RelationDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<RelationDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Common/Relation/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<RelationDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RelationDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RelationDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<RelationDto[]> {
        let url_ = this.baseUrl + "/api/Common/Relation/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<RelationDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RelationDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RelationDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: NewRelationDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Common/Relation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: UpdateRelationDto | undefined, signal?: AbortSignal): Promise<UpdateRelationDto> {
        let url_ = this.baseUrl + "/api/Common/Relation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateRelationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateRelationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateRelationDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/Relation/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/Relation/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class SourceOfFundClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<FullSourceOfFundDto> {
        let url_ = this.baseUrl + "/api/Common/SourceOfFund/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullSourceOfFundDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullSourceOfFundDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullSourceOfFundDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<SourceOfFundDto> {
        let url_ = this.baseUrl + "/api/Common/SourceOfFund/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<SourceOfFundDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SourceOfFundDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SourceOfFundDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<SourceOfFundDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Common/SourceOfFund/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<SourceOfFundDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SourceOfFundDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SourceOfFundDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<SourceOfFundDto[]> {
        let url_ = this.baseUrl + "/api/Common/SourceOfFund/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<SourceOfFundDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SourceOfFundDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SourceOfFundDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: AddSourceOfFundDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Common/SourceOfFund/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: UpdateSourceOfFundDto | undefined, signal?: AbortSignal): Promise<UpdateSourceOfFundDto> {
        let url_ = this.baseUrl + "/api/Common/SourceOfFund/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateSourceOfFundDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateSourceOfFundDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateSourceOfFundDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/SourceOfFund/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Common/SourceOfFund/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class TemplateResourcesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getProfileCompanyLogo(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Common/TemplateResources/GetProfileCompanyLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfileCompanyLogo(_response);
        });
    }

    protected processGetProfileCompanyLogo(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UaeCentralBankSynchronizationClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    exportTransactions(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: ExportTransactionsOptions | undefined, signal?: AbortSignal): Promise<ExportTransactionsResultDto> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankSynchronization/ExportTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportTransactions(_response);
        });
    }

    protected processExportTransactions(response: AxiosResponse): Promise<ExportTransactionsResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportTransactionsResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportTransactionsResultDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param body (optional) 
     * @return Success
     */
    exportUpdatedTransactions(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, body: ExportUpdatedTransactionsOptions | undefined, signal?: AbortSignal): Promise<ExportTransactionsResultDto> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankSynchronization/ExportUpdatedTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportUpdatedTransactions(_response);
        });
    }

    protected processExportUpdatedTransactions(response: AxiosResponse): Promise<ExportTransactionsResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportTransactionsResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportTransactionsResultDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @param rTDOrRSUFile (optional) 
     * @param ackFile (optional) 
     * @param loadFromSftpServer (optional) 
     * @return Success
     */
    importProcessedTransactions(branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, rTDOrRSUFile: FileParameter | undefined, ackFile: FileParameter | undefined, loadFromSftpServer: boolean | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankSynchronization/ImportProcessedTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (rTDOrRSUFile === null || rTDOrRSUFile === undefined)
            throw new Error("The parameter 'rTDOrRSUFile' cannot be null.");
        else
            content_.append("RTDOrRSUFile", rTDOrRSUFile.data, rTDOrRSUFile.fileName ? rTDOrRSUFile.fileName : "RTDOrRSUFile");
        if (ackFile === null || ackFile === undefined)
            throw new Error("The parameter 'ackFile' cannot be null.");
        else
            content_.append("AckFile", ackFile.data, ackFile.fileName ? ackFile.fileName : "AckFile");
        if (loadFromSftpServer === null || loadFromSftpServer === undefined)
            throw new Error("The parameter 'loadFromSftpServer' cannot be null.");
        else
            content_.append("LoadFromSftpServer", loadFromSftpServer.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImportProcessedTransactions(_response);
        });
    }

    protected processImportProcessedTransactions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UaeCentralBankSynchronizationLogClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<CentralBankSynchronizationLogDto> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankSynchronizationLog/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CentralBankSynchronizationLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CentralBankSynchronizationLogDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CentralBankSynchronizationLogDto>(null as any);
    }

    /**
     * @param succeed (optional) 
     * @param logFailType (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getList(succeed: boolean | undefined, logFailType: SynchronizationLogFailType | undefined, date_From: string | undefined, date_To: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<CentralBankSynchronizationLogListDto[]> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankSynchronizationLog/GetList?";
        if (succeed === null)
            throw new Error("The parameter 'succeed' cannot be null.");
        else if (succeed !== undefined)
            url_ += "Succeed=" + encodeURIComponent("" + succeed) + "&";
        if (logFailType === null)
            throw new Error("The parameter 'logFailType' cannot be null.");
        else if (logFailType !== undefined)
            url_ += "LogFailType=" + encodeURIComponent("" + logFailType) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CentralBankSynchronizationLogListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CentralBankSynchronizationLogListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CentralBankSynchronizationLogListDto[]>(null as any);
    }
}

export class UaeCentralBankTransactionFileClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<CentralBankTransactionFileDto> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankTransactionFile/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CentralBankTransactionFileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CentralBankTransactionFileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CentralBankTransactionFileDto>(null as any);
    }

    /**
     * @param succeed (optional) 
     * @param fileName (optional) 
     * @param processedDate (optional) 
     * @param processedByFileName (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param exportedRange_From (optional) 
     * @param exportedRange_To (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getPaginatedList(succeed: boolean | undefined, fileName: string | undefined, processedDate: string | undefined, processedByFileName: string | undefined, date_From: string | undefined, date_To: string | undefined, exportedRange_From: string | undefined, exportedRange_To: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<CentralBankTransactionFileListDto[]> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankTransactionFile/GetPaginatedList?";
        if (succeed === null)
            throw new Error("The parameter 'succeed' cannot be null.");
        else if (succeed !== undefined)
            url_ += "Succeed=" + encodeURIComponent("" + succeed) + "&";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (processedDate === null)
            throw new Error("The parameter 'processedDate' cannot be null.");
        else if (processedDate !== undefined)
            url_ += "ProcessedDate=" + encodeURIComponent("" + processedDate) + "&";
        if (processedByFileName === null)
            throw new Error("The parameter 'processedByFileName' cannot be null.");
        else if (processedByFileName !== undefined)
            url_ += "ProcessedByFileName=" + encodeURIComponent("" + processedByFileName) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (exportedRange_From === null)
            throw new Error("The parameter 'exportedRange_From' cannot be null.");
        else if (exportedRange_From !== undefined)
            url_ += "ExportedRange.From=" + encodeURIComponent("" + exportedRange_From) + "&";
        if (exportedRange_To === null)
            throw new Error("The parameter 'exportedRange_To' cannot be null.");
        else if (exportedRange_To !== undefined)
            url_ += "ExportedRange.To=" + encodeURIComponent("" + exportedRange_To) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<CentralBankTransactionFileListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CentralBankTransactionFileListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CentralBankTransactionFileListDto[]>(null as any);
    }
}

export class UaeCentralBankTransactionLogClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<CentralBankTransactionLogDto> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankTransactionLog/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CentralBankTransactionLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CentralBankTransactionLogDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CentralBankTransactionLogDto>(null as any);
    }

    /**
     * @param transactionType (optional) 
     * @param transactionId (optional) 
     * @param lineNumber (optional) 
     * @param type (optional) 
     * @param transactionLogProcessingStatuses (optional) 
     * @param centralBankTransactionFileId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getPaginatedList(transactionType: TransactionTypes | undefined, transactionId: number | undefined, lineNumber: string | undefined, type: TransactionLogType | undefined, transactionLogProcessingStatuses: TransactionLogProcessingStatuses | undefined, centralBankTransactionFileId: number | undefined, date_From: string | undefined, date_To: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<CentralBankTransactionLogListDto[]> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankTransactionLog/GetPaginatedList?";
        if (transactionType === null)
            throw new Error("The parameter 'transactionType' cannot be null.");
        else if (transactionType !== undefined)
            url_ += "TransactionType=" + encodeURIComponent("" + transactionType) + "&";
        if (transactionId === null)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else if (transactionId !== undefined)
            url_ += "TransactionId=" + encodeURIComponent("" + transactionId) + "&";
        if (lineNumber === null)
            throw new Error("The parameter 'lineNumber' cannot be null.");
        else if (lineNumber !== undefined)
            url_ += "LineNumber=" + encodeURIComponent("" + lineNumber) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (transactionLogProcessingStatuses === null)
            throw new Error("The parameter 'transactionLogProcessingStatuses' cannot be null.");
        else if (transactionLogProcessingStatuses !== undefined)
            url_ += "TransactionLogProcessingStatuses=" + encodeURIComponent("" + transactionLogProcessingStatuses) + "&";
        if (centralBankTransactionFileId === null)
            throw new Error("The parameter 'centralBankTransactionFileId' cannot be null.");
        else if (centralBankTransactionFileId !== undefined)
            url_ += "CentralBankTransactionFileId=" + encodeURIComponent("" + centralBankTransactionFileId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<CentralBankTransactionLogListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CentralBankTransactionLogListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CentralBankTransactionLogListDto[]>(null as any);
    }

    /**
     * @param transactionType (optional) 
     * @param transactionId (optional) 
     * @param lineNumber (optional) 
     * @param type (optional) 
     * @param transactionLogProcessingStatuses (optional) 
     * @param centralBankTransactionFileId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    getPaginatedReportList(transactionType: TransactionTypes | undefined, transactionId: number | undefined, lineNumber: string | undefined, type: TransactionLogType | undefined, transactionLogProcessingStatuses: TransactionLogProcessingStatuses | undefined, centralBankTransactionFileId: number | undefined, date_From: string | undefined, date_To: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<CentralBankRemittanceTransactionListDto[]> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankTransactionLog/GetPaginatedReportList?";
        if (transactionType === null)
            throw new Error("The parameter 'transactionType' cannot be null.");
        else if (transactionType !== undefined)
            url_ += "TransactionType=" + encodeURIComponent("" + transactionType) + "&";
        if (transactionId === null)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else if (transactionId !== undefined)
            url_ += "TransactionId=" + encodeURIComponent("" + transactionId) + "&";
        if (lineNumber === null)
            throw new Error("The parameter 'lineNumber' cannot be null.");
        else if (lineNumber !== undefined)
            url_ += "LineNumber=" + encodeURIComponent("" + lineNumber) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (transactionLogProcessingStatuses === null)
            throw new Error("The parameter 'transactionLogProcessingStatuses' cannot be null.");
        else if (transactionLogProcessingStatuses !== undefined)
            url_ += "TransactionLogProcessingStatuses=" + encodeURIComponent("" + transactionLogProcessingStatuses) + "&";
        if (centralBankTransactionFileId === null)
            throw new Error("The parameter 'centralBankTransactionFileId' cannot be null.");
        else if (centralBankTransactionFileId !== undefined)
            url_ += "CentralBankTransactionFileId=" + encodeURIComponent("" + centralBankTransactionFileId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedReportList(_response);
        });
    }

    protected processGetPaginatedReportList(response: AxiosResponse): Promise<CentralBankRemittanceTransactionListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CentralBankRemittanceTransactionListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CentralBankRemittanceTransactionListDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    closed(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankTransactionLog/Closed?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClosed(_response);
        });
    }

    protected processClosed(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @param x_Idempotence_Key (optional) 
     * @return Success
     */
    pending(id: number | undefined, branchIdHeader: string | undefined, x_Idempotence_Key: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Common/UaeCentralBankTransactionLog/Pending?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "X-Idempotence-Key": x_Idempotence_Key !== undefined && x_Idempotence_Key !== null ? "" + x_Idempotence_Key : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPending(_response);
        });
    }

    protected processPending(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export enum ActionType {
    RTD = "RTD",
    RSU = "RSU",
}

export interface AddLookupMappingDto {
    externalSystemId: number;
    lookupCategoryId: number;
    externalId: string;
    externalName: string;
    localId: number;
}

export interface AddSourceOfFundDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface CentralBankExportLogDto {
    id?: number;
    succeeded?: boolean;
    from?: string | null;
    to?: string | null;
    failReasons?: string[] | null;
    fileId?: number | null;
    fileName?: string | null;
    file?: FileDto;
    type?: ExportLogType;
}

export interface CentralBankExportLogListDto {
    id?: number;
    succeeded?: boolean;
    from?: string | null;
    to?: string | null;
    failReasons?: string[] | null;
    fileId?: number | null;
    fileName?: string | null;
    file?: FileDto;
    type?: ExportLogType;
}

export interface CentralBankRemittanceTransactionListDto {
    id?: number;
    created?: string;
    readonly formatedCreationDate?: string | null;
    number?: string | null;
    customerName?: string | null;
    customerId?: number;
    branch?: SimpleBranchDto;
    type?: SupportedTransactionsFilter;
    status?: TransactionStatuses;
    centralBankExportStatus?: TransactionLogProcessingStatuses;
    exported?: boolean | null;
}

export interface CentralBankSynchronizationLogDto {
    id?: number;
    succeeded?: boolean;
    notes?: string[] | null;
    startDate?: string;
    finishDate?: string;
    logFailType?: SynchronizationLogFailType;
    operationType?: string | null;
    created?: string;
    lastModified?: string | null;
}

export interface CentralBankSynchronizationLogListDto {
    id?: number;
    succeeded?: boolean;
    notes?: string[] | null;
    startDate?: string;
    finishDate?: string;
    logFailType?: SynchronizationLogFailType;
    operationType?: string | null;
    created?: string;
    lastModified?: string | null;
}

export interface CentralBankTransactionFileDto {
    id?: number;
    file?: FileDto;
    fileId?: number;
    fileName?: string | null;
    mappedRecordsCount?: number;
    unMappedRecordsCount?: number;
    lastProcessedSendTransactionId?: number | null;
    lastProcessedReceiveTransactionId?: number | null;
    succeeded?: boolean;
    processedDate?: string | null;
    type?: TransactionFileLogType;
    processedByFileName?: string | null;
    created?: string;
    createdBy?: number | null;
    createdByName?: string | null;
    lastModified?: string | null;
    fromDate?: string | null;
    toDate?: string | null;
    actionType?: ActionType;
    details?: CentralBankTransactionLogListDto[] | null;
}

export interface CentralBankTransactionFileListDto {
    id?: number;
    file?: FileDto;
    fileId?: number;
    fileName?: string | null;
    mappedRecordsCount?: number;
    unMappedRecordsCount?: number;
    lastProcessedSendTransactionId?: number | null;
    lastProcessedReceiveTransactionId?: number | null;
    succeeded?: boolean;
    processedDate?: string | null;
    type?: TransactionFileLogType;
    processedByFileName?: string | null;
    created?: string;
    createdBy?: number | null;
    createdByName?: string | null;
    lastModified?: string | null;
    fromDate?: string | null;
    toDate?: string | null;
    actionType?: ActionType;
}

export interface CentralBankTransactionLogDto {
    id?: number;
    transactionType?: TransactionTypes;
    transactionId?: number;
    lineNumber?: string | null;
    type?: TransactionLogType;
    transactionLogProcessingStatuses?: TransactionLogProcessingStatuses;
    actionType?: ActionType;
    actionName?: string | null;
    failReasons?: string[] | null;
    created?: string;
    lastModified?: string | null;
    centralBankTransactionFileName?: string | null;
    centralBankTransactionFileId?: number | null;
    updateLogParent?: CentralBankTransactionLogDto;
    updateLogParentId?: number | null;
}

export interface CentralBankTransactionLogListDto {
    id?: number;
    transactionType?: TransactionTypes;
    transactionId?: number;
    lineNumber?: string | null;
    type?: TransactionLogType;
    transactionLogProcessingStatuses?: TransactionLogProcessingStatuses;
    actionType?: ActionType;
    actionName?: string | null;
    failReasons?: string[] | null;
    created?: string;
    lastModified?: string | null;
    centralBankTransactionFileName?: string | null;
    centralBankTransactionFileId?: number | null;
    updateLogParent?: CentralBankTransactionLogDto;
    updateLogParentId?: number | null;
}

export interface ChangeStatusModel {
    ids: number[];
    active: boolean;
    reason?: string | null;
}

export interface CommonLookupDto {
    data?: any[] | null;
}

export enum CommonLookups {
    Purpose = "Purpose",
    SourceOfFund = "SourceOfFund",
    TransactionType = "TransactionType",
}

export interface DateTimeRangeFilter {
    from?: string;
    to?: string;
}

export enum ExportLogType {
    SendTransactions = "SendTransactions",
    ReceiveTransactions = "ReceiveTransactions",
    Exchange = "Exchange",
}

export interface ExportTransactionsOptions {
    recordsPerFile?: number | null;
    exportTransactionsType?: ExportTransactionsType;
    date?: DateTimeRangeFilter;
}

export interface ExportTransactionsResultDto {
    file?: FileDto;
    failRecordsCount?: number;
    mappedRecordsCount?: number;
    unMappedTransactions?: RecordMappingResult[] | null;
}

export enum ExportTransactionsType {
    NewTransactions = "NewTransactions",
    NewTransactionsAndWaitingForAcknowledgment = "NewTransactionsAndWaitingForAcknowledgment",
}

export interface ExportUpdatedTransactionsOptions {
    date?: DateTimeRangeFilter;
}

export interface ExternaItemDto {
    id?: string | null;
    name?: string | null;
}

export interface ExternalSystemDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
}

export interface ExternalSystemDtoIPaginatedList {
    readonly items?: ExternalSystemDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface FileDto {
    id?: number;
    name?: string | null;
    extension?: string | null;
    link?: string | null;
    created?: string;
}

export interface FullExternalSystemDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface FullLookupCategoryDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: LookupCategoryDataTypes;
}

export interface FullPurposeDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface FullRelationDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface FullSourceOfFundDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export enum LookupCategoryDataTypes {
    Country = "Country",
    CustomerSubType = "CustomerSubType",
    Purpose = "Purpose",
    Currency = "Currency",
    SourceOfFund = "SourceOfFund",
    DeliveryMethod = "DeliveryMethod",
    Relation = "Relation",
    IdentityType = "IdentityType",
    Activity = "Activity",
    AddressType = "AddressType",
    DelegationType = "DelegationType",
    Gender = "Gender",
    Industry = "Industry",
    LiabilityType = "LiabilityType",
    OwnershipType = "OwnershipType",
    PartnershipType = "PartnershipType",
    Profession = "Profession",
    ResidencyType = "ResidencyType",
    Branch = "Branch",
    City = "City",
    Text = "Text",
    Provider = "Provider",
    ProviderProfile = "ProviderProfile",
    Number = "Number",
    Decimal = "Decimal",
}

export interface LookupCategoryDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
    type?: LookupCategoryDataTypes;
}

export interface LookupCategoryDtoIPaginatedList {
    readonly items?: LookupCategoryDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum LookupCategoryFileTypes {
    XML = "XML",
    Excel = "Excel",
    CSV = "CSV",
    Json = "Json",
}

export interface LookupMappingDto {
    id?: number;
    externalSystem?: ExternalSystemDto;
    lookupCategory?: LookupCategoryDto;
    externalId?: string | null;
    externalName?: string | null;
    localId?: number;
}

export enum MappingType {
    Key = "Key",
    Index = "Index",
}

export interface NewExternalSystemDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface NewLookupCategoryDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: LookupCategoryDataTypes;
}

export interface NewPurposeDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface NewRelationDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface PurposeDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
}

export interface PurposeDtoIPaginatedList {
    readonly items?: PurposeDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface RecordMappingResult {
    succeed?: boolean;
    transactionId?: number | null;
    transactionNumber?: string | null;
    transactionType?: TransactionTypes;
    reasons?: string[] | null;
}

export interface RelationDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
}

export interface RelationDtoIPaginatedList {
    readonly items?: RelationDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum SahabModules {
    Common = "Common",
    Customer = "Customer",
    FCExchange = "FCExchange",
    Finance = "Finance",
    EntityManagement = "EntityManagement",
    Compliance = "Compliance",
    Utilities = "Utilities",
    Remittance = "Remittance",
    Accounting = "Accounting",
    SystemSettings = "SystemSettings",
    Complaint = "Complaint",
}

export interface SimpleBranchDto {
    id?: number;
    name?: string | null;
    code?: string | null;
}

export interface SourceOfFundDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
}

export interface SourceOfFundDtoIPaginatedList {
    readonly items?: SourceOfFundDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum SupportedTransactionsFilter {
    Send = "Send",
    Receive = "Receive",
}

export enum SynchronizationLogFailType {
    Configurations = "Configurations",
    Connection = "Connection",
    Validation = "Validation",
}

export enum TransactionFileLogType {
    CentralBank = "CentralBank",
}

export enum TransactionLogProcessingStatuses {
    Pending = "Pending",
    WaitingForAcknowledgment = "WaitingForAcknowledgment",
    Succeeded = "Succeeded",
    Failed = "Failed",
    Closed = "Closed",
}

export enum TransactionLogType {
    CentralBank = "CentralBank",
    Validation = "Validation",
}

export enum TransactionStatuses {
    PendingForCompliance = "PendingForCompliance",
    Blocked = "Blocked",
    PendingForCash = "PendingForCash",
    Completed = "Completed",
    PendingForCancel = "PendingForCancel",
    Canceled = "Canceled",
    PendingForRefund = "PendingForRefund",
    Refunded = "Refunded",
    ReadyForDelivery = "ReadyForDelivery",
    Delivered = "Delivered",
    PendingForEdit = "PendingForEdit",
    BlockedForRefund = "BlockedForRefund",
    BlockedForReserve = "BlockedForReserve",
    PendingForApproval = "PendingForApproval",
    Rejected = "Rejected",
    PendingForSenderApproval = "PendingForSenderApproval",
    PendingForReceiverApproval = "PendingForReceiverApproval",
    PendingForSenderCash = "PendingForSenderCash",
    PendingForReceiverCash = "PendingForReceiverCash",
    ComplianceProcessing = "ComplianceProcessing",
}

export enum TransactionTypes {
    FC_Sale = "FC_Sale",
    FC_Purchase = "FC_Purchase",
    SendMoney = "SendMoney",
    ReceiveMoney = "ReceiveMoney",
    Income = "Income",
    Expenses = "Expenses",
    InternalTransfer = "InternalTransfer",
    ExternalTransfer = "ExternalTransfer",
    StockTransaction = "StockTransaction",
}

export interface UpdateExternalSystemDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface UpdateLookupCategoryDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: LookupCategoryDataTypes;
}

export interface UpdateLookupMappingDto {
    id: number;
    externalSystemId: number;
    lookupCategoryId: number;
    externalId: string;
    externalName: string;
    localId: number;
}

export interface UpdatePurposeDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface UpdateRelationDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface UpdateSourceOfFundDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}