//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AccountingReportClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param exportAs (optional) 
     * @param date (optional) 
     * @param level (optional) 
     * @param branchIds (optional) 
     * @param currency_Type (optional) 
     * @param currency_CurrencyIds (optional) 
     * @param balanceOnly (optional) 
     * @param generationMethods (optional) 
     * @param rateType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportTrialBalance(exportAs: ReportTypes | undefined, date: string | undefined, level: number | undefined, branchIds: number[] | undefined, currency_Type: CurrencyFilters | undefined, currency_CurrencyIds: number[] | undefined, balanceOnly: boolean | undefined, generationMethods: ReportGenerationMethods | undefined, rateType: RateTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/ExportTrialBalance?";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent("" + date) + "&";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "Level=" + encodeURIComponent("" + level) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (currency_Type === null)
            throw new Error("The parameter 'currency_Type' cannot be null.");
        else if (currency_Type !== undefined)
            url_ += "Currency.Type=" + encodeURIComponent("" + currency_Type) + "&";
        if (currency_CurrencyIds === null)
            throw new Error("The parameter 'currency_CurrencyIds' cannot be null.");
        else if (currency_CurrencyIds !== undefined)
            currency_CurrencyIds && currency_CurrencyIds.forEach(item => { url_ += "Currency.CurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (balanceOnly === null)
            throw new Error("The parameter 'balanceOnly' cannot be null.");
        else if (balanceOnly !== undefined)
            url_ += "BalanceOnly=" + encodeURIComponent("" + balanceOnly) + "&";
        if (generationMethods === null)
            throw new Error("The parameter 'generationMethods' cannot be null.");
        else if (generationMethods !== undefined)
            url_ += "GenerationMethods=" + encodeURIComponent("" + generationMethods) + "&";
        if (rateType === null)
            throw new Error("The parameter 'rateType' cannot be null.");
        else if (rateType !== undefined)
            url_ += "RateType=" + encodeURIComponent("" + rateType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportTrialBalance(_response);
        });
    }

    protected processExportTrialBalance(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param exportAs (optional) 
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param currency_Type (optional) 
     * @param currency_CurrencyIds (optional) 
     * @param resultType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportAccountStatement(exportAs: ReportTypes | undefined, accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, currency_Type: CurrencyFilters | undefined, currency_CurrencyIds: number[] | undefined, resultType: AccountStatementResultTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/ExportAccountStatement?";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (currency_Type === null)
            throw new Error("The parameter 'currency_Type' cannot be null.");
        else if (currency_Type !== undefined)
            url_ += "Currency.Type=" + encodeURIComponent("" + currency_Type) + "&";
        if (currency_CurrencyIds === null)
            throw new Error("The parameter 'currency_CurrencyIds' cannot be null.");
        else if (currency_CurrencyIds !== undefined)
            currency_CurrencyIds && currency_CurrencyIds.forEach(item => { url_ += "Currency.CurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (resultType === null)
            throw new Error("The parameter 'resultType' cannot be null.");
        else if (resultType !== undefined)
            url_ += "ResultType=" + encodeURIComponent("" + resultType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportAccountStatement(_response);
        });
    }

    protected processExportAccountStatement(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param exportAs (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param branchIds (optional) 
     * @param journalIds (optional) 
     * @param openingRateId (optional) 
     * @param revaluationRateId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportFCYReport(exportAs: ReportTypes | undefined, fromDate: string | undefined, toDate: string | undefined, branchIds: number[] | undefined, journalIds: number[] | undefined, openingRateId: number | undefined, revaluationRateId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/ExportFCYReport?";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (journalIds === null)
            throw new Error("The parameter 'journalIds' cannot be null.");
        else if (journalIds !== undefined)
            journalIds && journalIds.forEach(item => { url_ += "JournalIds=" + encodeURIComponent("" + item) + "&"; });
        if (openingRateId === null)
            throw new Error("The parameter 'openingRateId' cannot be null.");
        else if (openingRateId !== undefined)
            url_ += "OpeningRateId=" + encodeURIComponent("" + openingRateId) + "&";
        if (revaluationRateId === null)
            throw new Error("The parameter 'revaluationRateId' cannot be null.");
        else if (revaluationRateId !== undefined)
            url_ += "RevaluationRateId=" + encodeURIComponent("" + revaluationRateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportFCYReport(_response);
        });
    }

    protected processExportFCYReport(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date (optional) 
     * @param level (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportBalanceSheet(date: string | undefined, level: number | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/ExportBalanceSheet?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent("" + date) + "&";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "Level=" + encodeURIComponent("" + level) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportBalanceSheet(_response);
        });
    }

    protected processExportBalanceSheet(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date (optional) 
     * @param level (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportProfitAndLoss(date: string | undefined, level: number | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/ExportProfitAndLoss?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent("" + date) + "&";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "Level=" + encodeURIComponent("" + level) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportProfitAndLoss(_response);
        });
    }

    protected processExportProfitAndLoss(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param journalIds (optional) 
     * @param revaluationRateId (optional) 
     * @param openingBalance (optional) 
     * @param showZeroVariancePoints (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportFCYAnalysis(date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, journalIds: number[] | undefined, revaluationRateId: number | undefined, openingBalance: OpeningBalanceOption | undefined, showZeroVariancePoints: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/ExportFCYAnalysis?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (journalIds === null)
            throw new Error("The parameter 'journalIds' cannot be null.");
        else if (journalIds !== undefined)
            journalIds && journalIds.forEach(item => { url_ += "JournalIds=" + encodeURIComponent("" + item) + "&"; });
        if (revaluationRateId === null)
            throw new Error("The parameter 'revaluationRateId' cannot be null.");
        else if (revaluationRateId !== undefined)
            url_ += "RevaluationRateId=" + encodeURIComponent("" + revaluationRateId) + "&";
        if (openingBalance === null)
            throw new Error("The parameter 'openingBalance' cannot be null.");
        else if (openingBalance !== undefined)
            url_ += "OpeningBalance=" + encodeURIComponent("" + openingBalance) + "&";
        if (showZeroVariancePoints === null)
            throw new Error("The parameter 'showZeroVariancePoints' cannot be null.");
        else if (showZeroVariancePoints !== undefined)
            url_ += "ShowZeroVariancePoints=" + encodeURIComponent("" + showZeroVariancePoints) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportFCYAnalysis(_response);
        });
    }

    protected processExportFCYAnalysis(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    printEntry(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/PrintEntry?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrintEntry(_response);
        });
    }

    protected processPrintEntry(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param currency_Type (optional) 
     * @param currency_CurrencyIds (optional) 
     * @param resultType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getAccountStatement(accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, currency_Type: CurrencyFilters | undefined, currency_CurrencyIds: number[] | undefined, resultType: AccountStatementResultTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountStatementModel[]> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/GetAccountStatement?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (currency_Type === null)
            throw new Error("The parameter 'currency_Type' cannot be null.");
        else if (currency_Type !== undefined)
            url_ += "Currency.Type=" + encodeURIComponent("" + currency_Type) + "&";
        if (currency_CurrencyIds === null)
            throw new Error("The parameter 'currency_CurrencyIds' cannot be null.");
        else if (currency_CurrencyIds !== undefined)
            currency_CurrencyIds && currency_CurrencyIds.forEach(item => { url_ += "Currency.CurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (resultType === null)
            throw new Error("The parameter 'resultType' cannot be null.");
        else if (resultType !== undefined)
            url_ += "ResultType=" + encodeURIComponent("" + resultType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccountStatement(_response);
        });
    }

    protected processGetAccountStatement(response: AxiosResponse): Promise<AccountStatementModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountStatementModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountStatementModel[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @param level (optional) 
     * @param branchIds (optional) 
     * @param currency_Type (optional) 
     * @param currency_CurrencyIds (optional) 
     * @param balanceOnly (optional) 
     * @param generationMethods (optional) 
     * @param rateType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTrialBalance(date: string | undefined, level: number | undefined, branchIds: number[] | undefined, currency_Type: CurrencyFilters | undefined, currency_CurrencyIds: number[] | undefined, balanceOnly: boolean | undefined, generationMethods: ReportGenerationMethods | undefined, rateType: RateTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TrialBalanceModel[]> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/GetTrialBalance?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent("" + date) + "&";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "Level=" + encodeURIComponent("" + level) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (currency_Type === null)
            throw new Error("The parameter 'currency_Type' cannot be null.");
        else if (currency_Type !== undefined)
            url_ += "Currency.Type=" + encodeURIComponent("" + currency_Type) + "&";
        if (currency_CurrencyIds === null)
            throw new Error("The parameter 'currency_CurrencyIds' cannot be null.");
        else if (currency_CurrencyIds !== undefined)
            currency_CurrencyIds && currency_CurrencyIds.forEach(item => { url_ += "Currency.CurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (balanceOnly === null)
            throw new Error("The parameter 'balanceOnly' cannot be null.");
        else if (balanceOnly !== undefined)
            url_ += "BalanceOnly=" + encodeURIComponent("" + balanceOnly) + "&";
        if (generationMethods === null)
            throw new Error("The parameter 'generationMethods' cannot be null.");
        else if (generationMethods !== undefined)
            url_ += "GenerationMethods=" + encodeURIComponent("" + generationMethods) + "&";
        if (rateType === null)
            throw new Error("The parameter 'rateType' cannot be null.");
        else if (rateType !== undefined)
            url_ += "RateType=" + encodeURIComponent("" + rateType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTrialBalance(_response);
        });
    }

    protected processGetTrialBalance(response: AxiosResponse): Promise<TrialBalanceModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TrialBalanceModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrialBalanceModel[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @param level (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getBalanceSheet(date: string | undefined, level: number | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<BalanceModel[]> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/GetBalanceSheet?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent("" + date) + "&";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "Level=" + encodeURIComponent("" + level) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBalanceSheet(_response);
        });
    }

    protected processGetBalanceSheet(response: AxiosResponse): Promise<BalanceModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BalanceModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BalanceModel[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @param level (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getProfitAndLoss(date: string | undefined, level: number | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<BalanceModel[]> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/GetProfitAndLoss?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent("" + date) + "&";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "Level=" + encodeURIComponent("" + level) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfitAndLoss(_response);
        });
    }

    protected processGetProfitAndLoss(response: AxiosResponse): Promise<BalanceModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BalanceModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BalanceModel[]>(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param branchIds (optional) 
     * @param journalIds (optional) 
     * @param openingRateId (optional) 
     * @param revaluationRateId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    fCY(fromDate: string | null | undefined, toDate: string | null | undefined, branchIds: number[] | null | undefined, journalIds: number[] | null | undefined, openingRateId: number | null | undefined, revaluationRateId: number | null | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FCYExchangeTransactionReportModel> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/FCY?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (branchIds !== undefined && branchIds !== null)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (journalIds !== undefined && journalIds !== null)
            journalIds && journalIds.forEach(item => { url_ += "JournalIds=" + encodeURIComponent("" + item) + "&"; });
        if (openingRateId !== undefined && openingRateId !== null)
            url_ += "OpeningRateId=" + encodeURIComponent("" + openingRateId) + "&";
        if (revaluationRateId !== undefined && revaluationRateId !== null)
            url_ += "RevaluationRateId=" + encodeURIComponent("" + revaluationRateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFCY(_response);
        });
    }

    protected processFCY(response: AxiosResponse): Promise<FCYExchangeTransactionReportModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FCYExchangeTransactionReportModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FCYExchangeTransactionReportModel>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param journalIds (optional) 
     * @param revaluationRateId (optional) 
     * @param openingBalance (optional) 
     * @param showZeroVariancePoints (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    fCYDetailed(date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, journalIds: number[] | undefined, revaluationRateId: number | undefined, openingBalance: OpeningBalanceOption | undefined, showZeroVariancePoints: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FCYDetailedExchangeTransactionReportModel> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/FCYDetailed?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (journalIds === null)
            throw new Error("The parameter 'journalIds' cannot be null.");
        else if (journalIds !== undefined)
            journalIds && journalIds.forEach(item => { url_ += "JournalIds=" + encodeURIComponent("" + item) + "&"; });
        if (revaluationRateId === null)
            throw new Error("The parameter 'revaluationRateId' cannot be null.");
        else if (revaluationRateId !== undefined)
            url_ += "RevaluationRateId=" + encodeURIComponent("" + revaluationRateId) + "&";
        if (openingBalance === null)
            throw new Error("The parameter 'openingBalance' cannot be null.");
        else if (openingBalance !== undefined)
            url_ += "OpeningBalance=" + encodeURIComponent("" + openingBalance) + "&";
        if (showZeroVariancePoints === null)
            throw new Error("The parameter 'showZeroVariancePoints' cannot be null.");
        else if (showZeroVariancePoints !== undefined)
            url_ += "ShowZeroVariancePoints=" + encodeURIComponent("" + showZeroVariancePoints) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFCYDetailed(_response);
        });
    }

    protected processFCYDetailed(response: AxiosResponse): Promise<FCYDetailedExchangeTransactionReportModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FCYDetailedExchangeTransactionReportModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FCYDetailedExchangeTransactionReportModel>(null as any);
    }

    /**
     * @param profitCarryoverAmount (optional) 
     * @param profitCarryoverAccountId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param branchIds (optional) 
     * @param journalIds (optional) 
     * @param openingRateId (optional) 
     * @param revaluationRateId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    carryover(profitCarryoverAmount: number | undefined, profitCarryoverAccountId: number | undefined, fromDate: string | undefined, toDate: string | undefined, branchIds: number[] | undefined, journalIds: number[] | undefined, openingRateId: number | undefined, revaluationRateId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/Carryover?";
        if (profitCarryoverAmount === null)
            throw new Error("The parameter 'profitCarryoverAmount' cannot be null.");
        else if (profitCarryoverAmount !== undefined)
            url_ += "ProfitCarryoverAmount=" + encodeURIComponent("" + profitCarryoverAmount) + "&";
        if (profitCarryoverAccountId === null)
            throw new Error("The parameter 'profitCarryoverAccountId' cannot be null.");
        else if (profitCarryoverAccountId !== undefined)
            url_ += "ProfitCarryoverAccountId=" + encodeURIComponent("" + profitCarryoverAccountId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (journalIds === null)
            throw new Error("The parameter 'journalIds' cannot be null.");
        else if (journalIds !== undefined)
            journalIds && journalIds.forEach(item => { url_ += "JournalIds=" + encodeURIComponent("" + item) + "&"; });
        if (openingRateId === null)
            throw new Error("The parameter 'openingRateId' cannot be null.");
        else if (openingRateId !== undefined)
            url_ += "OpeningRateId=" + encodeURIComponent("" + openingRateId) + "&";
        if (revaluationRateId === null)
            throw new Error("The parameter 'revaluationRateId' cannot be null.");
        else if (revaluationRateId !== undefined)
            url_ += "RevaluationRateId=" + encodeURIComponent("" + revaluationRateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarryover(_response);
        });
    }

    protected processCarryover(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchesIds (optional) 
     * @param currenciesIds (optional) 
     * @param created (optional) 
     * @param statuses (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getRatesList(branchesIds: number[] | undefined, currenciesIds: number[] | undefined, created: string | undefined, statuses: CurrencyRateStatuses[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<BranchCurrencyRateVersionsDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/AccountingReport/GetRatesList?";
        if (branchesIds === null)
            throw new Error("The parameter 'branchesIds' cannot be null.");
        else if (branchesIds !== undefined)
            branchesIds && branchesIds.forEach(item => { url_ += "BranchesIds=" + encodeURIComponent("" + item) + "&"; });
        if (currenciesIds === null)
            throw new Error("The parameter 'currenciesIds' cannot be null.");
        else if (currenciesIds !== undefined)
            currenciesIds && currenciesIds.forEach(item => { url_ += "CurrenciesIds=" + encodeURIComponent("" + item) + "&"; });
        if (created === null)
            throw new Error("The parameter 'created' cannot be null.");
        else if (created !== undefined)
            url_ += "Created=" + encodeURIComponent("" + created) + "&";
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRatesList(_response);
        });
    }

    protected processGetRatesList(response: AxiosResponse): Promise<BranchCurrencyRateVersionsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BranchCurrencyRateVersionsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BranchCurrencyRateVersionsDto[]>(null as any);
    }
}

export class AccountsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    exportDbAccountsTree(branchIdHeader: string | undefined, body: AccountExportTreeRequest | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/ExportDbAccountsTree";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportDbAccountsTree(_response);
        });
    }

    protected processExportDbAccountsTree(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountDto> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<AccountDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getAccountsTree(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountTreeDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/GetAccountsTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccountsTree(_response);
        });
    }

    protected processGetAccountsTree(response: AxiosResponse): Promise<AccountTreeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountTreeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountTreeDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullAccountDto> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullAccountDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullAccountDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullAccountDto>(null as any);
    }

    /**
     * @param key (optional) 
     * @param type (optional) 
     * @param active (optional) 
     * @param allowedForManualEntry (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookups(key: string | undefined, type: AccountTypes | undefined, active: boolean | undefined, allowedForManualEntry: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountLookupDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/GetLookups?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (allowedForManualEntry === null)
            throw new Error("The parameter 'allowedForManualEntry' cannot be null.");
        else if (allowedForManualEntry !== undefined)
            url_ += "AllowedForManualEntry=" + encodeURIComponent("" + allowedForManualEntry) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookups(_response);
        });
    }

    protected processGetLookups(response: AxiosResponse): Promise<AccountLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountLookupDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountLookupDto[]>(null as any);
    }

    /**
     * @param key (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToParentLookups(key: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountLookupDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/GetToParentLookups?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToParentLookups(_response);
        });
    }

    protected processGetToParentLookups(response: AxiosResponse): Promise<AccountLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountLookupDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountLookupDto[]>(null as any);
    }

    /**
     * @param key (optional) 
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToEntryItemLookups(key: string | undefined, usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountLookupDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/GetToEntryItemLookups?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToEntryItemLookups(_response);
        });
    }

    protected processGetToEntryItemLookups(response: AxiosResponse): Promise<AccountLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountLookupDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountLookupDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: NewAccountDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateAccountDto | undefined, signal?: AbortSignal): Promise<UpdateAccountDto> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateAccountDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateAccountDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateAccountDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    favoriteAccountToggle(branchIdHeader: string | undefined, body: number | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/FavoriteAccountToggle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFavoriteAccountToggle(_response);
        });
    }

    protected processFavoriteAccountToggle(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getFavoriteAccounts(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountLookupDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/GetFavoriteAccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFavoriteAccounts(_response);
        });
    }

    protected processGetFavoriteAccounts(response: AxiosResponse): Promise<AccountLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountLookupDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountLookupDto[]>(null as any);
    }

    /**
     * @param parentId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getNextCode(parentId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/GetNextCode?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetNextCode(_response);
        });
    }

    protected processGetNextCode(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param file (optional) 
     * @return Success
     */
    importDbAccountsTree(branchIdHeader: string | undefined, file: FileParameter | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/ImportDbAccountsTree";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImportDbAccountsTree(_response);
        });
    }

    protected processImportDbAccountsTree(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getNameById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountLookupDto> {
        let url_ = this.baseUrl + "/api/Accounting/Accounts/GetNameById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetNameById(_response);
        });
    }

    protected processGetNameById(response: AxiosResponse): Promise<AccountLookupDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountLookupDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountLookupDto>(null as any);
    }
}

export class CurrencyRateClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CurrencyRateDto> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/GetToUpdate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<CurrencyRateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CurrencyRateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyRateDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getApproved(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CurrencyRateDto> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/GetApproved";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetApproved(_response);
        });
    }

    protected processGetApproved(response: AxiosResponse): Promise<CurrencyRateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CurrencyRateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyRateDto>(null as any);
    }

    /**
     * @param versionId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getArchived(versionId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CurrencyRateDto> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/GetArchived?";
        if (versionId === null)
            throw new Error("The parameter 'versionId' cannot be null.");
        else if (versionId !== undefined)
            url_ += "versionId=" + encodeURIComponent("" + versionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetArchived(_response);
        });
    }

    protected processGetArchived(response: AxiosResponse): Promise<CurrencyRateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CurrencyRateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyRateDto>(null as any);
    }

    /**
     * @param branchesIds (optional) 
     * @param currenciesIds (optional) 
     * @param created (optional) 
     * @param statuses (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getVersionsList(branchesIds: number[] | undefined, currenciesIds: number[] | undefined, created: string | undefined, statuses: CurrencyRateStatuses[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<BranchCurrencyRateVersionsDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/GetVersionsList?";
        if (branchesIds === null)
            throw new Error("The parameter 'branchesIds' cannot be null.");
        else if (branchesIds !== undefined)
            branchesIds && branchesIds.forEach(item => { url_ += "BranchesIds=" + encodeURIComponent("" + item) + "&"; });
        if (currenciesIds === null)
            throw new Error("The parameter 'currenciesIds' cannot be null.");
        else if (currenciesIds !== undefined)
            currenciesIds && currenciesIds.forEach(item => { url_ += "CurrenciesIds=" + encodeURIComponent("" + item) + "&"; });
        if (created === null)
            throw new Error("The parameter 'created' cannot be null.");
        else if (created !== undefined)
            url_ += "Created=" + encodeURIComponent("" + created) + "&";
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVersionsList(_response);
        });
    }

    protected processGetVersionsList(response: AxiosResponse): Promise<BranchCurrencyRateVersionsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BranchCurrencyRateVersionsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BranchCurrencyRateVersionsDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateCurrencyRateDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CurrencyRateDto> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CurrencyRateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CurrencyRateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyRateDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    copyToDraft(branchIdHeader: string | undefined, body: number | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/CopyToDraft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCopyToDraft(_response);
        });
    }

    protected processCopyToDraft(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveDraftToArchive(branchIdHeader: string | undefined, body: number[] | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/SaveDraftToArchive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveDraftToArchive(_response);
        });
    }

    protected processSaveDraftToArchive(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    approve(branchIdHeader: string | undefined, body: number[] | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/Approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApprove(_response);
        });
    }

    protected processApprove(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCurrencyRateBranches(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CurrencyRateApprovedBranchDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/GetCurrencyRateBranches?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrencyRateBranches(_response);
        });
    }

    protected processGetCurrencyRateBranches(response: AxiosResponse): Promise<CurrencyRateApprovedBranchDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CurrencyRateApprovedBranchDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyRateApprovedBranchDto[]>(null as any);
    }

    /**
     * @param fromCurrencyId (optional) 
     * @param toCurrencyId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getEstimatedRate(fromCurrencyId: number | undefined, toCurrencyId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/GetEstimatedRate?";
        if (fromCurrencyId === null)
            throw new Error("The parameter 'fromCurrencyId' cannot be null.");
        else if (fromCurrencyId !== undefined)
            url_ += "FromCurrencyId=" + encodeURIComponent("" + fromCurrencyId) + "&";
        if (toCurrencyId === null)
            throw new Error("The parameter 'toCurrencyId' cannot be null.");
        else if (toCurrencyId !== undefined)
            url_ += "ToCurrencyId=" + encodeURIComponent("" + toCurrencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEstimatedRate(_response);
        });
    }

    protected processGetEstimatedRate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param currencies (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getEstimatedRates(currencies: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CurrencyRateDetailDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/CurrencyRate/GetEstimatedRates?";
        if (currencies === null)
            throw new Error("The parameter 'currencies' cannot be null.");
        else if (currencies !== undefined)
            currencies && currencies.forEach(item => { url_ += "Currencies=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEstimatedRates(_response);
        });
    }

    protected processGetEstimatedRates(response: AxiosResponse): Promise<CurrencyRateDetailDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CurrencyRateDetailDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyRateDetailDto[]>(null as any);
    }
}

export class DashboardClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getAccountCurrencies(accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetAccountCurrenciesAsync?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccountCurrencies(_response);
        });
    }

    protected processGetAccountCurrencies(response: AxiosResponse): Promise<SimpleCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleCurrencyDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getChartOfAccounts(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ChartOfAccounts> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetChartOfAccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChartOfAccounts(_response);
        });
    }

    protected processGetChartOfAccounts(response: AxiosResponse): Promise<ChartOfAccounts> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ChartOfAccounts>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChartOfAccounts>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getChartOfEntries(accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ChartOfEntries> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetChartOfEntries?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChartOfEntries(_response);
        });
    }

    protected processGetChartOfEntries(response: AxiosResponse): Promise<ChartOfEntries> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ChartOfEntries>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChartOfEntries>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getFiscalPeriod(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FiscalPeriodDto> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetFiscalPeriod?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFiscalPeriod(_response);
        });
    }

    protected processGetFiscalPeriod(response: AxiosResponse): Promise<FiscalPeriodDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FiscalPeriodDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FiscalPeriodDto>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getAssets(accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountDashboard> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetAssets?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAssets(_response);
        });
    }

    protected processGetAssets(response: AxiosResponse): Promise<AccountDashboard> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountDashboard>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountDashboard>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getEquities(accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountDashboard> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetEquities?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEquities(_response);
        });
    }

    protected processGetEquities(response: AxiosResponse): Promise<AccountDashboard> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountDashboard>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountDashboard>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getExpense(accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountDashboard> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetExpense?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExpense(_response);
        });
    }

    protected processGetExpense(response: AxiosResponse): Promise<AccountDashboard> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountDashboard>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountDashboard>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getIncome(accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountDashboard> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetIncome?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIncome(_response);
        });
    }

    protected processGetIncome(response: AxiosResponse): Promise<AccountDashboard> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountDashboard>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountDashboard>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLiabilities(accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AccountDashboard> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetLiabilities?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLiabilities(_response);
        });
    }

    protected processGetLiabilities(response: AxiosResponse): Promise<AccountDashboard> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AccountDashboard>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountDashboard>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getProfit(accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ProfitModel> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetProfit?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfit(_response);
        });
    }

    protected processGetProfit(response: AxiosResponse): Promise<ProfitModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ProfitModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfitModel>(null as any);
    }

    /**
     * @param accountId (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getProfitPoint(accountId: number | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ProfitPointModel[]> {
        let url_ = this.baseUrl + "/api/Accounting/Dashboard/GetProfitPoint?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "AccountId=" + encodeURIComponent("" + accountId) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfitPoint(_response);
        });
    }

    protected processGetProfitPoint(response: AxiosResponse): Promise<ProfitPointModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ProfitPointModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfitPointModel[]>(null as any);
    }
}

export class EntriesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param exportAs (optional) 
     * @param searchKey (optional) 
     * @param number (optional) 
     * @param note (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param journalIds (optional) 
     * @param status (optional) 
     * @param isAutomatic (optional) 
     * @param isReversal (optional) 
     * @param isReversed (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportEntries(exportAs: ReportTypes | undefined, searchKey: string | undefined, number: string | undefined, note: string | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, journalIds: number[] | undefined, status: EntryStatuses[] | undefined, isAutomatic: boolean | undefined, isReversal: boolean | undefined, isReversed: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/ExportEntries?";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (note === null)
            throw new Error("The parameter 'note' cannot be null.");
        else if (note !== undefined)
            url_ += "Note=" + encodeURIComponent("" + note) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (journalIds === null)
            throw new Error("The parameter 'journalIds' cannot be null.");
        else if (journalIds !== undefined)
            journalIds && journalIds.forEach(item => { url_ += "JournalIds=" + encodeURIComponent("" + item) + "&"; });
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (isAutomatic === null)
            throw new Error("The parameter 'isAutomatic' cannot be null.");
        else if (isAutomatic !== undefined)
            url_ += "IsAutomatic=" + encodeURIComponent("" + isAutomatic) + "&";
        if (isReversal === null)
            throw new Error("The parameter 'isReversal' cannot be null.");
        else if (isReversal !== undefined)
            url_ += "IsReversal=" + encodeURIComponent("" + isReversal) + "&";
        if (isReversed === null)
            throw new Error("The parameter 'isReversed' cannot be null.");
        else if (isReversed !== undefined)
            url_ += "IsReversed=" + encodeURIComponent("" + isReversed) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportEntries(_response);
        });
    }

    protected processExportEntries(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param exportAs (optional) 
     * @param searchKey (optional) 
     * @param number (optional) 
     * @param note (optional) 
     * @param isAutomatic (optional) 
     * @param isReversal (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param accountIds (optional) 
     * @param branchIds (optional) 
     * @param journalIds (optional) 
     * @param currencyIds (optional) 
     * @param amount_From (optional) 
     * @param amount_To (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportEntryItems(exportAs: ReportTypes | undefined, searchKey: string | undefined, number: string | undefined, note: string | undefined, isAutomatic: boolean | undefined, isReversal: boolean | undefined, date_From: string | undefined, date_To: string | undefined, accountIds: number[] | undefined, branchIds: number[] | undefined, journalIds: number[] | undefined, currencyIds: number[] | undefined, amount_From: number | undefined, amount_To: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/ExportEntryItems?";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (note === null)
            throw new Error("The parameter 'note' cannot be null.");
        else if (note !== undefined)
            url_ += "Note=" + encodeURIComponent("" + note) + "&";
        if (isAutomatic === null)
            throw new Error("The parameter 'isAutomatic' cannot be null.");
        else if (isAutomatic !== undefined)
            url_ += "IsAutomatic=" + encodeURIComponent("" + isAutomatic) + "&";
        if (isReversal === null)
            throw new Error("The parameter 'isReversal' cannot be null.");
        else if (isReversal !== undefined)
            url_ += "IsReversal=" + encodeURIComponent("" + isReversal) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (accountIds === null)
            throw new Error("The parameter 'accountIds' cannot be null.");
        else if (accountIds !== undefined)
            accountIds && accountIds.forEach(item => { url_ += "AccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (journalIds === null)
            throw new Error("The parameter 'journalIds' cannot be null.");
        else if (journalIds !== undefined)
            journalIds && journalIds.forEach(item => { url_ += "JournalIds=" + encodeURIComponent("" + item) + "&"; });
        if (currencyIds === null)
            throw new Error("The parameter 'currencyIds' cannot be null.");
        else if (currencyIds !== undefined)
            currencyIds && currencyIds.forEach(item => { url_ += "CurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (amount_From === null)
            throw new Error("The parameter 'amount_From' cannot be null.");
        else if (amount_From !== undefined)
            url_ += "Amount.From=" + encodeURIComponent("" + amount_From) + "&";
        if (amount_To === null)
            throw new Error("The parameter 'amount_To' cannot be null.");
        else if (amount_To !== undefined)
            url_ += "Amount.To=" + encodeURIComponent("" + amount_To) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportEntryItems(_response);
        });
    }

    protected processExportEntryItems(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportEntryProfile(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/ExportEntryProfile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportEntryProfile(_response);
        });
    }

    protected processExportEntryProfile(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<EntryDto> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<EntryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<EntryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntryDto>(null as any);
    }

    /**
     * @param searchKey (optional) 
     * @param number (optional) 
     * @param note (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param journalIds (optional) 
     * @param status (optional) 
     * @param isAutomatic (optional) 
     * @param isReversal (optional) 
     * @param isReversed (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(searchKey: string | undefined, number: string | undefined, note: string | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, journalIds: number[] | undefined, status: EntryStatuses[] | undefined, isAutomatic: boolean | undefined, isReversal: boolean | undefined, isReversed: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<EntryListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/GetList?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (note === null)
            throw new Error("The parameter 'note' cannot be null.");
        else if (note !== undefined)
            url_ += "Note=" + encodeURIComponent("" + note) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (journalIds === null)
            throw new Error("The parameter 'journalIds' cannot be null.");
        else if (journalIds !== undefined)
            journalIds && journalIds.forEach(item => { url_ += "JournalIds=" + encodeURIComponent("" + item) + "&"; });
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (isAutomatic === null)
            throw new Error("The parameter 'isAutomatic' cannot be null.");
        else if (isAutomatic !== undefined)
            url_ += "IsAutomatic=" + encodeURIComponent("" + isAutomatic) + "&";
        if (isReversal === null)
            throw new Error("The parameter 'isReversal' cannot be null.");
        else if (isReversal !== undefined)
            url_ += "IsReversal=" + encodeURIComponent("" + isReversal) + "&";
        if (isReversed === null)
            throw new Error("The parameter 'isReversed' cannot be null.");
        else if (isReversed !== undefined)
            url_ += "IsReversed=" + encodeURIComponent("" + isReversed) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<EntryListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<EntryListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntryListDtoIPaginatedList>(null as any);
    }

    /**
     * @param currencyId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getRate(currencyId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/GetRate?";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRate(_response);
        });
    }

    protected processGetRate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddEntryDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateEntryDto | undefined, signal?: AbortSignal): Promise<UpdateEntryDto> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateEntryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateEntryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateEntryDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    post(branchIdHeader: string | undefined, body: number | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/Post";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    cancel(branchIdHeader: string | undefined, body: number | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/Cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    revers(branchIdHeader: string | undefined, body: number | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/Revers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRevers(_response);
        });
    }

    protected processRevers(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param searchKey (optional) 
     * @param number (optional) 
     * @param note (optional) 
     * @param isAutomatic (optional) 
     * @param isReversal (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param accountIds (optional) 
     * @param branchIds (optional) 
     * @param journalIds (optional) 
     * @param currencyIds (optional) 
     * @param amount_From (optional) 
     * @param amount_To (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getEntryItems(searchKey: string | undefined, number: string | undefined, note: string | undefined, isAutomatic: boolean | undefined, isReversal: boolean | undefined, date_From: string | undefined, date_To: string | undefined, accountIds: number[] | undefined, branchIds: number[] | undefined, journalIds: number[] | undefined, currencyIds: number[] | undefined, amount_From: number | undefined, amount_To: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullEntryItemDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/GetEntryItems?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (note === null)
            throw new Error("The parameter 'note' cannot be null.");
        else if (note !== undefined)
            url_ += "Note=" + encodeURIComponent("" + note) + "&";
        if (isAutomatic === null)
            throw new Error("The parameter 'isAutomatic' cannot be null.");
        else if (isAutomatic !== undefined)
            url_ += "IsAutomatic=" + encodeURIComponent("" + isAutomatic) + "&";
        if (isReversal === null)
            throw new Error("The parameter 'isReversal' cannot be null.");
        else if (isReversal !== undefined)
            url_ += "IsReversal=" + encodeURIComponent("" + isReversal) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (accountIds === null)
            throw new Error("The parameter 'accountIds' cannot be null.");
        else if (accountIds !== undefined)
            accountIds && accountIds.forEach(item => { url_ += "AccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (journalIds === null)
            throw new Error("The parameter 'journalIds' cannot be null.");
        else if (journalIds !== undefined)
            journalIds && journalIds.forEach(item => { url_ += "JournalIds=" + encodeURIComponent("" + item) + "&"; });
        if (currencyIds === null)
            throw new Error("The parameter 'currencyIds' cannot be null.");
        else if (currencyIds !== undefined)
            currencyIds && currencyIds.forEach(item => { url_ += "CurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (amount_From === null)
            throw new Error("The parameter 'amount_From' cannot be null.");
        else if (amount_From !== undefined)
            url_ += "Amount.From=" + encodeURIComponent("" + amount_From) + "&";
        if (amount_To === null)
            throw new Error("The parameter 'amount_To' cannot be null.");
        else if (amount_To !== undefined)
            url_ += "Amount.To=" + encodeURIComponent("" + amount_To) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEntryItems(_response);
        });
    }

    protected processGetEntryItems(response: AxiosResponse): Promise<FullEntryItemDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullEntryItemDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullEntryItemDtoIPaginatedList>(null as any);
    }

    /**
     * @param transactionNumber (optional) 
     * @param transactionType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    transactionEntries(transactionNumber: string | undefined, transactionType: TransactionTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<EntryDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/Entries/TransactionEntries?";
        if (transactionNumber === null)
            throw new Error("The parameter 'transactionNumber' cannot be null.");
        else if (transactionNumber !== undefined)
            url_ += "TransactionNumber=" + encodeURIComponent("" + transactionNumber) + "&";
        if (transactionType === null)
            throw new Error("The parameter 'transactionType' cannot be null.");
        else if (transactionType !== undefined)
            url_ += "TransactionType=" + encodeURIComponent("" + transactionType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTransactionEntries(_response);
        });
    }

    protected processTransactionEntries(response: AxiosResponse): Promise<EntryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<EntryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntryDto[]>(null as any);
    }
}

export class EntryItemRoutingsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param fileName (optional) 
     * @param entryRoutingId (optional) 
     * @param applyFor (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    export(fileName: string | undefined, entryRoutingId: number | undefined, applyFor: EntryItemRoutingApplyFor | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportEntryItemRoutingsResultDto> {
        let url_ = this.baseUrl + "/api/Accounting/EntryItemRoutings/Export?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (entryRoutingId === null)
            throw new Error("The parameter 'entryRoutingId' cannot be null.");
        else if (entryRoutingId !== undefined)
            url_ += "EntryRoutingId=" + encodeURIComponent("" + entryRoutingId) + "&";
        if (applyFor === null)
            throw new Error("The parameter 'applyFor' cannot be null.");
        else if (applyFor !== undefined)
            url_ += "ApplyFor=" + encodeURIComponent("" + applyFor) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<ExportEntryItemRoutingsResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportEntryItemRoutingsResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportEntryItemRoutingsResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<EntryItemRoutingDto> {
        let url_ = this.baseUrl + "/api/Accounting/EntryItemRoutings/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<EntryItemRoutingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<EntryItemRoutingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntryItemRoutingDto>(null as any);
    }

    /**
     * @param entryRoutingId (optional) 
     * @param applyFor (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(entryRoutingId: number | undefined, applyFor: EntryItemRoutingApplyFor | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<EntryItemRoutingListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Accounting/EntryItemRoutings/GetPaginatedList?";
        if (entryRoutingId === null)
            throw new Error("The parameter 'entryRoutingId' cannot be null.");
        else if (entryRoutingId !== undefined)
            url_ += "EntryRoutingId=" + encodeURIComponent("" + entryRoutingId) + "&";
        if (applyFor === null)
            throw new Error("The parameter 'applyFor' cannot be null.");
        else if (applyFor !== undefined)
            url_ += "ApplyFor=" + encodeURIComponent("" + applyFor) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<EntryItemRoutingListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<EntryItemRoutingListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntryItemRoutingListDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateEntryItemRoutingDto | undefined, signal?: AbortSignal): Promise<UpdateEntryItemRoutingDto> {
        let url_ = this.baseUrl + "/api/Accounting/EntryItemRoutings/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateEntryItemRoutingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateEntryItemRoutingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateEntryItemRoutingDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/EntryItemRoutings/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class EntryRoutingsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param fileName (optional) 
     * @param transactionType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    export(fileName: string | undefined, transactionType: TransactionTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportEntryRoutingsResultDto> {
        let url_ = this.baseUrl + "/api/Accounting/EntryRoutings/Export?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (transactionType === null)
            throw new Error("The parameter 'transactionType' cannot be null.");
        else if (transactionType !== undefined)
            url_ += "TransactionType=" + encodeURIComponent("" + transactionType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<ExportEntryRoutingsResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportEntryRoutingsResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportEntryRoutingsResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<EntryRoutingDto> {
        let url_ = this.baseUrl + "/api/Accounting/EntryRoutings/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<EntryRoutingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<EntryRoutingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntryRoutingDto>(null as any);
    }

    /**
     * @param transactionType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(transactionType: TransactionTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<EntryRoutingListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Accounting/EntryRoutings/GetPaginatedList?";
        if (transactionType === null)
            throw new Error("The parameter 'transactionType' cannot be null.");
        else if (transactionType !== undefined)
            url_ += "TransactionType=" + encodeURIComponent("" + transactionType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<EntryRoutingListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<EntryRoutingListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntryRoutingListDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateEntryRoutingDto | undefined, signal?: AbortSignal): Promise<UpdateEntryRoutingDto> {
        let url_ = this.baseUrl + "/api/Accounting/EntryRoutings/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateEntryRoutingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateEntryRoutingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateEntryRoutingDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/EntryRoutings/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class FiscalPeriodClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullFiscalPeriodDto> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullFiscalPeriodDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullFiscalPeriodDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullFiscalPeriodDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeFiscalPeriodStatus(branchIdHeader: string | undefined, body: UpdateFiscalPeriodStatusDto | undefined, signal?: AbortSignal): Promise<UpdateFiscalPeriodStatusDto> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/ChangeFiscalPeriodStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeFiscalPeriodStatus(_response);
        });
    }

    protected processChangeFiscalPeriodStatus(response: AxiosResponse): Promise<UpdateFiscalPeriodStatusDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateFiscalPeriodStatusDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateFiscalPeriodStatusDto>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookups(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FiscalPeriodLookupDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/GetLookups?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookups(_response);
        });
    }

    protected processGetLookups(response: AxiosResponse): Promise<FiscalPeriodLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FiscalPeriodLookupDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FiscalPeriodLookupDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCurrentFiscalPeriod(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FiscalPeriodDto> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/GetCurrentFiscalPeriod";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentFiscalPeriod(_response);
        });
    }

    protected processGetCurrentFiscalPeriod(response: AxiosResponse): Promise<FiscalPeriodDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FiscalPeriodDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FiscalPeriodDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPreviousFiscalPeriod(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FiscalPeriodDto> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/GetPreviousFiscalPeriod";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPreviousFiscalPeriod(_response);
        });
    }

    protected processGetPreviousFiscalPeriod(response: AxiosResponse): Promise<FiscalPeriodDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FiscalPeriodDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FiscalPeriodDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FiscalPeriodDto> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<FiscalPeriodDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FiscalPeriodDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FiscalPeriodDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FiscalPeriodDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<FiscalPeriodDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FiscalPeriodDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FiscalPeriodDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FiscalPeriodDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<FiscalPeriodDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FiscalPeriodDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FiscalPeriodDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddFiscalPeriodDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateFiscalPeriodDto | undefined, signal?: AbortSignal): Promise<UpdateFiscalPeriodDto> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateFiscalPeriodDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateFiscalPeriodDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateFiscalPeriodDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/FiscalPeriod/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class JournalClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullJournalDto> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullJournalDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullJournalDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullJournalDto>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookups(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<JournalLookupDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/GetLookups?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookups(_response);
        });
    }

    protected processGetLookups(response: AxiosResponse): Promise<JournalLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<JournalLookupDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JournalLookupDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    setJournalLockDate(branchIdHeader: string | undefined, body: SetJournalLockDateDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/SetJournalLockDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetJournalLockDate(_response);
        });
    }

    protected processSetJournalLockDate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    reorderJournalsSequance(branchIdHeader: string | undefined, body: number[] | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/ReorderJournalsSequance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReorderJournalsSequance(_response);
        });
    }

    protected processReorderJournalsSequance(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<JournalDto> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<JournalDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<JournalDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JournalDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<JournalDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<JournalDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<JournalDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JournalDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<JournalDto[]> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<JournalDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<JournalDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JournalDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: NewJournalDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateJournalDto | undefined, signal?: AbortSignal): Promise<UpdateJournalDto> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateJournalDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateJournalDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateJournalDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/Journal/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class RecalculationAccountBalanceClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    recalculate(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Accounting/RecalculationAccountBalance/Recalculate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecalculate(_response);
        });
    }

    protected processRecalculate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class TestAccountingClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    generate(branchIdHeader: string | undefined, body: GenerateAutoEntriesModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Accounting/TestAccounting/Generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenerate(_response);
        });
    }

    protected processGenerate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface AccountBalanceDto {
    currency?: SimpleCurrencyDto;
    balance?: number;
    isMain?: boolean;
}

export interface AccountDashboard {
    id?: number;
    name?: string | null;
    balance?: number;
    fiscalPeriod?: FiscalPeriodModel;
    children?: AccountModel[] | null;
}

export interface AccountDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    parent?: AccountLookupDto;
    parentId?: number | null;
    isSystemControlled?: boolean;
    type?: AccountTypes;
    code?: string | null;
    fullCode?: string | null;
    isFavorit?: boolean;
    active?: boolean;
    children?: AccountLookupDto[] | null;
    balance?: number;
    accountBalances?: AccountBalanceDto[] | null;
    allowedForManualEntry?: boolean;
}

export interface AccountExportTreeRequest {
    exculdedAccountsIds?: number[] | null;
}

export interface AccountLookupDto {
    id?: number;
    name?: string | null;
    fullCode?: string | null;
    active?: boolean;
}

export interface AccountModel {
    id?: number;
    name?: string | null;
    balance?: number;
}

export interface AccountStatementAggregatedItem {
    amountInCurrency?: number;
    debitLC?: number;
    creditLC?: number;
    balanceLC?: number;
    currency?: SimpleCurrencyDto;
    debitFC?: number;
    creditFC?: number;
    balanceFC?: number;
}

export interface AccountStatementItem {
    id?: number;
    date?: string;
    number?: string | null;
    reference?: string | null;
    referenceType?: TransactionTypes;
    entryId?: string | null;
    entryNumber?: string | null;
    note?: string | null;
    debitLC?: number;
    creditLC?: number;
    balance?: number;
    currency?: SimpleCurrencyDto;
    currencyRate?: number;
    debitFC?: number;
    creditFC?: number;
}

export interface AccountStatementModel {
    openingBalance?: OpeningBalanceModel;
    data?: AccountStatementItem[] | null;
    aggregatedData?: AccountStatementAggregatedItem[] | null;
    closingBalance?: ClosingBalanceModel;
}

export enum AccountStatementResultTypes {
    Detailed = "Detailed",
    Aggregated = "Aggregated",
}

export interface AccountTreeDto {
    id?: number;
    name?: string | null;
    isSystemControlled?: boolean;
    type?: AccountTypes;
    code?: string | null;
    fullCode?: string | null;
    level?: number;
    parentId?: number | null;
    active?: boolean;
    isFavorite?: boolean;
    balance?: number;
    allowedForManualEntry?: boolean;
    accountBalances?: AccountBalanceDto[] | null;
}

export enum AccountTypes {
    Aggregate = "Aggregate",
    Journal = "Journal",
}

export interface AddEntryDto {
    isPost?: boolean;
    journalId: number;
    accountingDate?: string | null;
    transactionReferenceId?: string | null;
    note?: string | null;
    items: AddEntryItemDto[];
}

export interface AddEntryItemDto {
    accountId: number;
    note?: string | null;
    debit?: number;
    credit?: number;
    currencyId: number;
    branchId?: number | null;
    currencyRate: number;
    amountInCurrency: number;
}

export interface AddFiscalPeriodDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    startDate?: string;
    endDate?: string;
    period?: FiscalPeriods;
}

export interface BalanceModel {
    id?: number;
    name?: string | null;
    parentId?: number | null;
    fullCode?: string | null;
    balance?: number;
    level?: number;
    type?: AccountTypes;
}

export interface BranchCurrencyRateVersionsDto {
    id?: number;
    name?: string | null;
    branch?: SimpleBranchDto;
    created?: string;
    status?: CurrencyRateStatuses;
}

export interface ChangeStatusModel {
    ids: number[];
    active: boolean;
    reason?: string | null;
}

export interface ChartOfAccounts {
    levels?: number;
    accounts?: number;
}

export interface ChartOfEntries {
    all?: number;
    draft?: number;
    posted?: number;
    reversed?: number;
}

export interface ClosingBalanceModel {
    date?: string;
    debit?: number;
    credit?: number;
    balance?: number;
    currencyId?: string | null;
    currencyCode?: string | null;
    currency?: SimpleCurrencyDto;
    amount?: number;
}

export enum CurrencyFilters {
    AllSeparated = "AllSeparated",
    AllConsolidated = "AllConsolidated",
}

export interface CurrencyRateApprovedBranchDto {
    id?: number;
    branch?: SimpleBranchDto;
    approved?: boolean;
}

export interface CurrencyRateDetailDto {
    id?: number;
    currency?: SimpleCurrencyDto;
    currencyId?: number;
    rate?: number;
    active?: boolean;
}

export interface CurrencyRateDto {
    id?: number;
    name?: string | null;
    currency?: SimpleCurrencyDto;
    currencyId?: number;
    isDraft?: boolean;
    created?: string;
    details?: CurrencyRateDetailDto[] | null;
}

export enum CurrencyRateStatuses {
    Approved = "Approved",
    Archived = "Archived",
}

export interface EntryDto {
    id?: number;
    journal?: JournalDto;
    journalId?: number;
    createdBranch?: SimpleBranchDto;
    createdBranchId?: number;
    sequence?: number;
    accountingDate?: string;
    number?: string | null;
    transactionReferenceNumber?: string | null;
    note?: string | null;
    totalDebit?: number;
    totalCredit?: number;
    balance?: number;
    reversedByEntryId?: number | null;
    reversedByEntryNumber?: string | null;
    reverseOfEntryId?: number | null;
    reverseOfEntryNumber?: string | null;
    status?: EntryStatuses;
    isAutomatic?: boolean;
    items?: EntryItemDto[] | null;
    active?: boolean;
    created?: string;
}

export interface EntryItemDto {
    sequence?: number;
    account?: AccountLookupDto;
    accountId?: number;
    note?: string | null;
    debit?: number;
    credit?: number;
    balance?: number;
    currency?: SimpleCurrencyDto;
    currencyId?: number;
    currencyRate?: number | null;
    amountInCurrency?: number | null;
    active?: boolean;
    created?: string;
    transactionReferenceNumber?: string | null;
    branch?: SimpleBranchDto;
    branchId?: number;
}

export enum EntryItemRoutingApplyFor {
    Transaction = "Transaction",
    TransactionDetails = "TransactionDetails",
    Summary = "Summary",
}

export interface EntryItemRoutingDto {
    entryRouting?: EntryRoutingSimpleDto;
    entryRoutingId?: number;
    applyFor?: EntryItemRoutingApplyFor;
    sequence?: number;
    condition?: string | null;
    branchIdExpression?: string | null;
    accountIdExpression?: string | null;
    notesExpression?: string | null;
    currencyIdExpression?: string | null;
    currencyRateExpression?: string | null;
    amountInCurrencyCalculation?: string | null;
    debitCalculation?: string | null;
    creditCalculation?: string | null;
    active?: boolean;
}

export interface EntryItemRoutingListDto {
    id?: number;
    entryRouting?: EntryRoutingSimpleDto;
    entryRoutingId?: number;
    applyFor?: EntryItemRoutingApplyFor;
    sequence?: number;
    condition?: string | null;
    branchIdExpression?: string | null;
    accountIdExpression?: string | null;
    notesExpression?: string | null;
    currencyIdExpression?: string | null;
    currencyRateExpression?: string | null;
    amountInCurrencyCalculation?: string | null;
    debitCalculation?: string | null;
    creditCalculation?: string | null;
    active?: boolean;
}

export interface EntryItemRoutingListDtoIPaginatedList {
    readonly items?: EntryItemRoutingListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface EntryListDto {
    id?: number;
    journal?: JournalDto;
    journalId?: number;
    createdBranch?: SimpleBranchDto;
    createdBranchId?: number;
    sequence?: number;
    accountingDate?: string;
    number?: string | null;
    transactionReferenceNumber?: string | null;
    note?: string | null;
    totalDebit?: number;
    totalCredit?: number;
    reversedByEntryId?: number | null;
    reversedByEntryNumber?: string | null;
    reverseOfEntryId?: number | null;
    reverseOfEntryNumber?: string | null;
    status?: EntryStatuses;
    isAutomatic?: boolean;
    active?: boolean;
    created?: string;
}

export interface EntryListDtoIPaginatedList {
    readonly items?: EntryListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface EntryRoutingDto {
    code?: string | null;
    transactionType?: TransactionTypes;
    companyId?: number;
    sequence?: number;
    condition?: string | null;
    journalIdExpression?: string | null;
    accountingDateExpression?: string | null;
    referenceIdExpression?: string | null;
    notesExpression?: string | null;
    statusExpression?: string | null;
    active?: boolean;
}

export interface EntryRoutingListDto {
    id?: number;
    code?: string | null;
    transactionType?: TransactionTypes;
    companyId?: number;
    sequence?: number;
    condition?: string | null;
    journalIdExpression?: string | null;
    accountingDateExpression?: string | null;
    referenceIdExpression?: string | null;
    notesExpression?: string | null;
    statusExpression?: string | null;
    active?: boolean;
}

export interface EntryRoutingListDtoIPaginatedList {
    readonly items?: EntryRoutingListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface EntryRoutingSimpleDto {
    id?: number;
    code?: string | null;
    transactionType?: TransactionTypes;
    companyId?: number;
    sequence?: number;
    condition?: string | null;
    journalIdExpression?: string | null;
    accountingDateExpression?: string | null;
    referenceIdExpression?: string | null;
    notesExpression?: string | null;
    statusExpression?: string | null;
    active?: boolean;
}

export enum EntryStatuses {
    Draft = "Draft",
    Posted = "Posted",
    Cancelled = "Cancelled",
}

export interface ExportEntryItemRoutingsResultDto {
    id?: number;
    fileName?: string | null;
    content?: string | null;
}

export interface ExportEntryRoutingsResultDto {
    id?: number;
    fileName?: string | null;
    content?: string | null;
}

export interface FCYDetailedExchangeTransactionReportItemModel {
    entryId?: number;
    number?: string | null;
    accountingDate?: string;
    variance?: number;
    balance?: number;
}

export interface FCYDetailedExchangeTransactionReportModel {
    openingBalance?: number;
    items?: FCYDetailedExchangeTransactionReportItemModel[] | null;
}

export interface FCYExchangeTransactionReportFilter {
    fromDate?: string | null;
    toDate?: string | null;
    branchIds?: number[] | null;
    journalIds?: number[] | null;
    openingRateId?: number | null;
    revaluationRateId?: number | null;
}

export interface FCYExchangeTransactionReportModel {
    fcyReportCurrenciesModels?: FCYReportCurrenciesModel[] | null;
    readonly sumTotalOpeningLC?: number;
    readonly sumTotalPurchaseLC?: number;
    readonly sumTotalStockLC?: number;
    readonly sumSaleLC?: number;
    readonly sumTotalProfit?: number;
    readonly sumClosingLC?: number | null;
    readonly sumTotalProfitLoss?: number | null;
    readonly sumTotalRevaluationLC?: number | null;
    readonly sumTotalRevaluationProfit?: number | null;
    profitCarryovers?: number;
    readonly netFCYProfit?: number;
}

export interface FCYReportCurrenciesModel {
    currencyId?: number;
    branchId?: number;
    currencyCode?: string | null;
    openingFC?: number;
    openingRate?: number;
    readonly openingLC?: number;
    buyFC?: number;
    buyLC?: number;
    readonly buyRate?: number | null;
    readonly totalStockFC?: number;
    readonly totalStockLC?: number;
    readonly averageRate?: number | null;
    sellFC?: number;
    sellLC?: number;
    readonly sellRate?: number | null;
    readonly sellProfit?: number;
    readonly closingFC?: number;
    readonly closingRate?: number | null;
    readonly closingLC?: number | null;
    revaluationRate?: number | null;
    readonly revaluationLC?: number | null;
    readonly revaluationProfit?: number;
    readonly totalProfit?: number | null;
}

export interface FileDto {
    id?: number;
    name?: string | null;
    extension?: string | null;
    link?: string | null;
    created?: string;
}

export interface FiscalPeriodDto {
    id?: number;
    name?: string | null;
    startDate?: string;
    endDate?: string;
    period?: FiscalPeriods;
    status?: FiscalPeriodStatuses;
    active?: boolean;
}

export interface FiscalPeriodDtoIPaginatedList {
    readonly items?: FiscalPeriodDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface FiscalPeriodLookupDto {
    id?: number;
    name?: string | null;
}

export interface FiscalPeriodModel {
    from?: string;
    to?: string;
}

export enum FiscalPeriodStatuses {
    Opened = "Opened",
    Locked = "Locked",
    Closed = "Closed",
}

export enum FiscalPeriods {
    Month = "Month",
    ThreeMonths = "ThreeMonths",
    SixMonths = "SixMonths",
    Year = "Year",
    Custom = "Custom",
}

export interface FullAccountDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    parentId?: number | null;
    isSystemControlled?: boolean;
    code?: string | null;
    active?: boolean;
    children?: AccountLookupDto[] | null;
    allowedForManualEntry?: boolean;
    type?: AccountTypes;
}

export interface FullEntryItemDto {
    entry?: EntryListDto;
    sequence?: number;
    account?: AccountLookupDto;
    accountId?: number;
    note?: string | null;
    debit?: number;
    credit?: number;
    balance?: number;
    currency?: SimpleCurrencyDto;
    currencyId?: number;
    currencyRate?: number | null;
    amountInCurrency?: number | null;
    active?: boolean;
    transactionReferenceNumber?: string | null;
    branch?: SimpleBranchDto;
    branchId?: number;
}

export interface FullEntryItemDtoIPaginatedList {
    readonly items?: FullEntryItemDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface FullFiscalPeriodDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    startDate?: string;
    endDate?: string;
    period?: FiscalPeriods;
    active?: boolean;
}

export interface FullJournalDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code?: string | null;
    active?: boolean;
}

export interface GenerateAutoEntriesModel {
    transactionValues?: { [key: string]: string; } | null;
    transactionDetailsValues?: { [key: string]: string; }[] | null;
    transactionSummariesValues?: { [key: string]: string; }[] | null;
}

export interface JournalDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    sequence?: number;
    lockDate?: string | null;
    active?: boolean;
}

export interface JournalDtoIPaginatedList {
    readonly items?: JournalDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface JournalLookupDto {
    id?: number;
    name?: string | null;
}

export interface NewAccountDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    parentId?: number | null;
    code: string;
    allowedForManualEntry?: boolean;
    type?: AccountTypes;
}

export interface NewJournalDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
}

export interface OpeningBalanceModel {
    date?: string;
    debit?: number;
    credit?: number;
    balance?: number;
    currencyId?: string | null;
    currencyCode?: string | null;
    currency?: SimpleCurrencyDto;
}

export enum OpeningBalanceOption {
    Cumulative = "Cumulative",
    Zero = "Zero",
}

export interface ProfitModel {
    id?: number;
    name?: string | null;
    balance?: number;
    fiscalPeriod?: FiscalPeriodModel;
    lastFiscalPeriod?: FiscalPeriodModel;
    previousProfit?: number | null;
    readonly profitMargin?: number | null;
    readonly profitMarginPercent?: number | null;
}

export interface ProfitPointModel {
    month?: number;
    readonly monthAbbreviatedName?: string | null;
    income?: number;
    expense?: number;
    readonly profit?: number;
}

export enum RateTypes {
    Original = "Original",
    Average = "Average",
    AccountingRates = "AccountingRates",
}

export enum ReportGenerationMethods {
    Cash = "Cash",
    Recalculate = "Recalculate",
}

export enum ReportTypes {
    Pdf = "Pdf",
    Excel = "Excel",
}

export interface SetJournalLockDateDto {
    id?: number;
    lockDate?: string;
}

export interface SimpleBranchDto {
    id?: number;
    name?: string | null;
    code?: string | null;
}

export interface SimpleCurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
}

export enum TransactionTypes {
    FC_Sale = "FC_Sale",
    FC_Purchase = "FC_Purchase",
    SendMoney = "SendMoney",
    ReceiveMoney = "ReceiveMoney",
    Income = "Income",
    Expenses = "Expenses",
    InternalTransfer = "InternalTransfer",
    ExternalTransfer = "ExternalTransfer",
    StockTransaction = "StockTransaction",
}

export interface TrialBalanceItemModel {
    currencyId?: number;
    currency?: SimpleCurrencyDto;
    debitFC?: number;
    creditFC?: number;
    debitLC?: number;
    creditLC?: number;
    creditRate?: number;
    debitRate?: number;
}

export interface TrialBalanceModel {
    id?: number;
    name?: string | null;
    parentId?: number | null;
    fullCode?: string | null;
    level?: number;
    type?: AccountTypes;
    debitLC?: number;
    creditLC?: number;
    items?: TrialBalanceItemModel[] | null;
}

export interface UpdateAccountDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code?: string | null;
    allowedForManualEntry?: boolean;
}

export interface UpdateCurrencyRateDetailDto {
    currencyId: number;
    rate: number;
}

export interface UpdateCurrencyRateDto {
    details: UpdateCurrencyRateDetailDto[] | null;
}

export interface UpdateEntryDto {
    id: number;
    isPost?: boolean;
    journalId: number;
    accountingDate: string;
    transactionReferenceId?: string | null;
    note?: string | null;
    items: AddEntryItemDto[];
}

export interface UpdateEntryItemRoutingDto {
    id?: number;
    applyFor?: EntryItemRoutingApplyFor;
    sequence?: number;
    condition?: string | null;
    branchIdExpression?: string | null;
    accountIdExpression?: string | null;
    notesExpression?: string | null;
    currencyIdExpression?: string | null;
    currencyRateExpression?: string | null;
    amountInCurrencyCalculation?: string | null;
    debitCalculation?: string | null;
    creditCalculation?: string | null;
    active?: boolean;
}

export interface UpdateEntryRoutingDto {
    id?: number;
    condition?: string | null;
    journalIdExpression?: string | null;
    accountingDateExpression?: string | null;
    referenceIdExpression?: string | null;
    notesExpression?: string | null;
    statusExpression?: string | null;
    active?: boolean;
}

export interface UpdateFiscalPeriodDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    startDate?: string;
    endDate?: string;
    period?: FiscalPeriods;
}

export interface UpdateFiscalPeriodStatusDto {
    id: number;
    status?: FiscalPeriodStatuses;
}

export interface UpdateJournalDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}