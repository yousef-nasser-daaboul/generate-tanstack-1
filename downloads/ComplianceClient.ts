//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AmlRiskClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullAmlRiskDto> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRisk/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullAmlRiskDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullAmlRiskDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullAmlRiskDto>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookupList(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AmlRiskSimpleDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRisk/GetLookupList?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookupList(_response);
        });
    }

    protected processGetLookupList(response: AxiosResponse): Promise<AmlRiskSimpleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AmlRiskSimpleDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AmlRiskSimpleDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AmlRiskDto> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRisk/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<AmlRiskDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AmlRiskDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AmlRiskDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, body: AddAmlRiskDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRisk/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateAmlRiskDto | undefined, signal?: AbortSignal): Promise<UpdateAmlRiskDto> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRisk/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateAmlRiskDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateAmlRiskDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateAmlRiskDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRisk/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRisk/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class AmlRuleClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AmlRuleDto> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRule/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<AmlRuleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AmlRuleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AmlRuleDto>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookups(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AmlRuleLookupDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRule/GetLookups?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookups(_response);
        });
    }

    protected processGetLookups(response: AxiosResponse): Promise<AmlRuleLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AmlRuleLookupDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AmlRuleLookupDto[]>(null as any);
    }

    /**
     * @param key (optional) 
     * @param active (optional) 
     * @param products (optional) 
     * @param policies (optional) 
     * @param reviewPolicies (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(key: string | undefined, active: boolean | undefined, products: Products[] | undefined, policies: ActionPolicies[] | undefined, reviewPolicies: ReviewPolicies[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AmlRuleDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRule/GetPaginatedList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "Products=" + encodeURIComponent("" + item) + "&"; });
        if (policies === null)
            throw new Error("The parameter 'policies' cannot be null.");
        else if (policies !== undefined)
            policies && policies.forEach(item => { url_ += "Policies=" + encodeURIComponent("" + item) + "&"; });
        if (reviewPolicies === null)
            throw new Error("The parameter 'reviewPolicies' cannot be null.");
        else if (reviewPolicies !== undefined)
            reviewPolicies && reviewPolicies.forEach(item => { url_ += "ReviewPolicies=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<AmlRuleDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AmlRuleDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AmlRuleDtoIPaginatedList>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullAmlRuleDto> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRule/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullAmlRuleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullAmlRuleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullAmlRuleDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddAmlRuleDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRule/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    setCondition(branchIdHeader: string | undefined, body: SetConditionDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRule/SetCondition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetCondition(_response);
        });
    }

    protected processSetCondition(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateAmlRuleDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRule/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRule/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/AmlRule/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class BlacklistBankAccountsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: NewBlacklistBankAccountDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistBankAccounts/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateBlacklistBankAccountDto | undefined, signal?: AbortSignal): Promise<UpdateBlacklistBankAccountDto> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistBankAccounts/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateBlacklistBankAccountDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateBlacklistBankAccountDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateBlacklistBankAccountDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<BlacklistBankAccountForUpdateDto> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistBankAccounts/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<BlacklistBankAccountForUpdateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BlacklistBankAccountForUpdateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlacklistBankAccountForUpdateDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<BlacklistBankAccountDto> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistBankAccounts/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<BlacklistBankAccountDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BlacklistBankAccountDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlacklistBankAccountDto>(null as any);
    }

    /**
     * @param product (optional) 
     * @param bankCode (optional) 
     * @param bankName (optional) 
     * @param branchCode (optional) 
     * @param branchName (optional) 
     * @param accountNumber (optional) 
     * @param blacklistFor (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(product: Products | undefined, bankCode: string | undefined, bankName: string | undefined, branchCode: string | undefined, branchName: string | undefined, accountNumber: string | undefined, blacklistFor: BlacklistFor[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<BlacklistBankAccountListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistBankAccounts/GetPaginatedList?";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "Product=" + encodeURIComponent("" + product) + "&";
        if (bankCode === null)
            throw new Error("The parameter 'bankCode' cannot be null.");
        else if (bankCode !== undefined)
            url_ += "BankCode=" + encodeURIComponent("" + bankCode) + "&";
        if (bankName === null)
            throw new Error("The parameter 'bankName' cannot be null.");
        else if (bankName !== undefined)
            url_ += "BankName=" + encodeURIComponent("" + bankName) + "&";
        if (branchCode === null)
            throw new Error("The parameter 'branchCode' cannot be null.");
        else if (branchCode !== undefined)
            url_ += "BranchCode=" + encodeURIComponent("" + branchCode) + "&";
        if (branchName === null)
            throw new Error("The parameter 'branchName' cannot be null.");
        else if (branchName !== undefined)
            url_ += "BranchName=" + encodeURIComponent("" + branchName) + "&";
        if (accountNumber === null)
            throw new Error("The parameter 'accountNumber' cannot be null.");
        else if (accountNumber !== undefined)
            url_ += "AccountNumber=" + encodeURIComponent("" + accountNumber) + "&";
        if (blacklistFor === null)
            throw new Error("The parameter 'blacklistFor' cannot be null.");
        else if (blacklistFor !== undefined)
            blacklistFor && blacklistFor.forEach(item => { url_ += "BlacklistFor=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<BlacklistBankAccountListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BlacklistBankAccountListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlacklistBankAccountListDtoIPaginatedList>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistBankAccounts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    verify(branchIdHeader: string | undefined, body: VerifyBlacklistBankAccountDto | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistBankAccounts/Verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class BlacklistCountryClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOrUpdate(branchIdHeader: string | undefined, body: AddOrUpdateBlacklistCountryDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCountry/AddOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdate(_response);
        });
    }

    protected processAddOrUpdate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param product (optional) 
     * @param countryId (optional) 
     * @param blacklistFor (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(product: Products | undefined, countryId: number | undefined, blacklistFor: BlacklistFor[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<GroupedBlacklistCountryListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCountry/GetPaginatedList?";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "Product=" + encodeURIComponent("" + product) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (blacklistFor === null)
            throw new Error("The parameter 'blacklistFor' cannot be null.");
        else if (blacklistFor !== undefined)
            blacklistFor && blacklistFor.forEach(item => { url_ += "BlacklistFor=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<GroupedBlacklistCountryListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<GroupedBlacklistCountryListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupedBlacklistCountryListDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<GroupedBlacklistCountryListDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCountry/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<GroupedBlacklistCountryListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<GroupedBlacklistCountryListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupedBlacklistCountryListDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    delete(branchIdHeader: string | undefined, body: DeleteBlacklistCountryDto | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCountry/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param product (optional) 
     * @param countryId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(product: Products | undefined, countryId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<GroupedBlacklistCountryDto> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCountry/GetToUpdate?";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "Product=" + encodeURIComponent("" + product) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<GroupedBlacklistCountryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<GroupedBlacklistCountryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupedBlacklistCountryDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    verify(branchIdHeader: string | undefined, body: VerifyBlacklistCountryDto | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCountry/Verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class BlacklistCurrecnyClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOrUpdate(branchIdHeader: string | undefined, body: AddOrUpdateBlacklistCurrencyDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCurrecny/AddOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdate(_response);
        });
    }

    protected processAddOrUpdate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param product (optional) 
     * @param currencyId (optional) 
     * @param blacklistFor (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(product: Products | undefined, currencyId: number | undefined, blacklistFor: BlacklistFor[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<GroupedBlacklistCurrencyListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCurrecny/GetPaginatedList?";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "Product=" + encodeURIComponent("" + product) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (blacklistFor === null)
            throw new Error("The parameter 'blacklistFor' cannot be null.");
        else if (blacklistFor !== undefined)
            blacklistFor && blacklistFor.forEach(item => { url_ += "BlacklistFor=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<GroupedBlacklistCurrencyListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<GroupedBlacklistCurrencyListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupedBlacklistCurrencyListDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<GroupedBlacklistCurrencyListDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCurrecny/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<GroupedBlacklistCurrencyListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<GroupedBlacklistCurrencyListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupedBlacklistCurrencyListDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    delete(branchIdHeader: string | undefined, body: DeleteBlacklistCurrencyDto | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCurrecny/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param product (optional) 
     * @param currencyId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(product: Products | undefined, currencyId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<GroupedBlacklistCurrencyDto> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCurrecny/GetToUpdate?";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "Product=" + encodeURIComponent("" + product) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<GroupedBlacklistCurrencyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<GroupedBlacklistCurrencyDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupedBlacklistCurrencyDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    verify(branchIdHeader: string | undefined, body: VerifyBlacklistCurrencyDto | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistCurrecny/Verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class BlacklistTypeClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<BlacklistTypeDto> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistType/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<BlacklistTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BlacklistTypeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlacklistTypeDto>(null as any);
    }

    /**
     * @param product (optional) 
     * @param type (optional) 
     * @param blacklistFor (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(product: Products | undefined, type: BlacklistSourceType | undefined, blacklistFor: BlacklistFor[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<BlacklistTypeListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistType/GetPaginatedList?";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "Product=" + encodeURIComponent("" + product) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (blacklistFor === null)
            throw new Error("The parameter 'blacklistFor' cannot be null.");
        else if (blacklistFor !== undefined)
            blacklistFor && blacklistFor.forEach(item => { url_ += "BlacklistFor=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<BlacklistTypeListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BlacklistTypeListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlacklistTypeListDtoIPaginatedList>(null as any);
    }

    /**
     * @param type (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getProductsWithBlacklistForItems(type: BlacklistSourceType | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<Products[]> {
        let url_ = this.baseUrl + "/api/Compliance/BlacklistType/GetProductsWithBlacklistForItems?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProductsWithBlacklistForItems(_response);
        });
    }

    protected processGetProductsWithBlacklistForItems(response: AxiosResponse): Promise<Products[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Products[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Products[]>(null as any);
    }
}

export class CaseReasonsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param active (optional) 
     * @param types (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(active: boolean | undefined, types: CaseType[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CaseReasonDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/CaseReasons/GetList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CaseReasonDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CaseReasonDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CaseReasonDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CaseReasonToUpdateDto> {
        let url_ = this.baseUrl + "/api/Compliance/CaseReasons/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<CaseReasonToUpdateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CaseReasonToUpdateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CaseReasonToUpdateDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, body: AddCaseReasonDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/CaseReasons/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateCaseReasonDto | undefined, signal?: AbortSignal): Promise<UpdateCaseReasonDto> {
        let url_ = this.baseUrl + "/api/Compliance/CaseReasons/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCaseReasonDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCaseReasonDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCaseReasonDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/CaseReasons/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/CaseReasons/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CasesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param searchKey (optional) 
     * @param number (optional) 
     * @param products (optional) 
     * @param title (optional) 
     * @param types (optional) 
     * @param referenceNo (optional) 
     * @param customerName (optional) 
     * @param branches (optional) 
     * @param assignedTo (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param caseStatuses (optional) 
     * @param reasonId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    export(searchKey: string | undefined, number: string | undefined, products: Products[] | undefined, title: string | undefined, types: CaseType[] | undefined, referenceNo: string | undefined, customerName: string | undefined, branches: number[] | undefined, assignedTo: number[] | undefined, date_From: string | undefined, date_To: string | undefined, caseStatuses: number[] | undefined, reasonId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/Cases/Export?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "Products=" + encodeURIComponent("" + item) + "&"; });
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (referenceNo === null)
            throw new Error("The parameter 'referenceNo' cannot be null.");
        else if (referenceNo !== undefined)
            url_ += "ReferenceNo=" + encodeURIComponent("" + referenceNo) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (branches === null)
            throw new Error("The parameter 'branches' cannot be null.");
        else if (branches !== undefined)
            branches && branches.forEach(item => { url_ += "Branches=" + encodeURIComponent("" + item) + "&"; });
        if (assignedTo === null)
            throw new Error("The parameter 'assignedTo' cannot be null.");
        else if (assignedTo !== undefined)
            assignedTo && assignedTo.forEach(item => { url_ += "AssignedTo=" + encodeURIComponent("" + item) + "&"; });
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (caseStatuses === null)
            throw new Error("The parameter 'caseStatuses' cannot be null.");
        else if (caseStatuses !== undefined)
            caseStatuses && caseStatuses.forEach(item => { url_ += "CaseStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (reasonId === null)
            throw new Error("The parameter 'reasonId' cannot be null.");
        else if (reasonId !== undefined)
            url_ += "ReasonId=" + encodeURIComponent("" + reasonId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param title (optional) 
     * @param description (optional) 
     * @param type (optional) 
     * @param product (optional) 
     * @param referenceNo (optional) 
     * @param caseStatusId (optional) 
     * @param reasonId (optional) 
     * @param assignedToId (optional) 
     * @param attachment_Files (optional) 
     * @param customer_Name (optional) 
     * @param customer_Gender (optional) 
     * @param customer_BirthDate (optional) 
     * @param customer_Address (optional) 
     * @param customer_IdentityNo (optional) 
     * @param customer_IdentityExpiryDate (optional) 
     * @param customer_Phone (optional) 
     * @param customer_IdentityTypeId (optional) 
     * @param customer_IssuePlaceId (optional) 
     * @param customer_NationalityId (optional) 
     * @param customer_ProfessionId (optional) 
     * @param customerName (optional) 
     * @param entityId (optional) 
     * @param ruleLogId (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, title: string | undefined, description: string | undefined, type: CaseType | undefined, product: Products | undefined, referenceNo: string | undefined, caseStatusId: number | undefined, reasonId: number | undefined, assignedToId: number | undefined, attachment_Files: FileParameter[] | undefined, customer_Name: string | undefined, customer_Gender: Genders | undefined, customer_BirthDate: string | undefined, customer_Address: string | undefined, customer_IdentityNo: string | undefined, customer_IdentityExpiryDate: string | undefined, customer_Phone: string | undefined, customer_IdentityTypeId: number | undefined, customer_IssuePlaceId: number | undefined, customer_NationalityId: number | undefined, customer_ProfessionId: number | undefined, customerName: string | undefined, entityId: number | undefined, ruleLogId: number | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/Cases/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (title === null || title === undefined)
            throw new Error("The parameter 'title' cannot be null.");
        else
            content_.append("Title", title.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (product === null || product === undefined)
            throw new Error("The parameter 'product' cannot be null.");
        else
            content_.append("Product", product.toString());
        if (referenceNo === null || referenceNo === undefined)
            throw new Error("The parameter 'referenceNo' cannot be null.");
        else
            content_.append("ReferenceNo", referenceNo.toString());
        if (caseStatusId === null || caseStatusId === undefined)
            throw new Error("The parameter 'caseStatusId' cannot be null.");
        else
            content_.append("CaseStatusId", caseStatusId.toString());
        if (reasonId === null || reasonId === undefined)
            throw new Error("The parameter 'reasonId' cannot be null.");
        else
            content_.append("ReasonId", reasonId.toString());
        if (assignedToId === null || assignedToId === undefined)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else
            content_.append("AssignedToId", assignedToId.toString());
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );
        if (customer_Name === null || customer_Name === undefined)
            throw new Error("The parameter 'customer_Name' cannot be null.");
        else
            content_.append("Customer.Name", customer_Name.toString());
        if (customer_Gender === null || customer_Gender === undefined)
            throw new Error("The parameter 'customer_Gender' cannot be null.");
        else
            content_.append("Customer.Gender", customer_Gender.toString());
        if (customer_BirthDate === null || customer_BirthDate === undefined)
            throw new Error("The parameter 'customer_BirthDate' cannot be null.");
        else
            content_.append("Customer.BirthDate", customer_BirthDate.toString());
        if (customer_Address === null || customer_Address === undefined)
            throw new Error("The parameter 'customer_Address' cannot be null.");
        else
            content_.append("Customer.Address", customer_Address.toString());
        if (customer_IdentityNo === null || customer_IdentityNo === undefined)
            throw new Error("The parameter 'customer_IdentityNo' cannot be null.");
        else
            content_.append("Customer.IdentityNo", customer_IdentityNo.toString());
        if (customer_IdentityExpiryDate === null || customer_IdentityExpiryDate === undefined)
            throw new Error("The parameter 'customer_IdentityExpiryDate' cannot be null.");
        else
            content_.append("Customer.IdentityExpiryDate", customer_IdentityExpiryDate.toString());
        if (customer_Phone === null || customer_Phone === undefined)
            throw new Error("The parameter 'customer_Phone' cannot be null.");
        else
            content_.append("Customer.Phone", customer_Phone.toString());
        if (customer_IdentityTypeId === null || customer_IdentityTypeId === undefined)
            throw new Error("The parameter 'customer_IdentityTypeId' cannot be null.");
        else
            content_.append("Customer.IdentityTypeId", customer_IdentityTypeId.toString());
        if (customer_IssuePlaceId === null || customer_IssuePlaceId === undefined)
            throw new Error("The parameter 'customer_IssuePlaceId' cannot be null.");
        else
            content_.append("Customer.IssuePlaceId", customer_IssuePlaceId.toString());
        if (customer_NationalityId === null || customer_NationalityId === undefined)
            throw new Error("The parameter 'customer_NationalityId' cannot be null.");
        else
            content_.append("Customer.NationalityId", customer_NationalityId.toString());
        if (customer_ProfessionId === null || customer_ProfessionId === undefined)
            throw new Error("The parameter 'customer_ProfessionId' cannot be null.");
        else
            content_.append("Customer.ProfessionId", customer_ProfessionId.toString());
        if (customerName === null || customerName === undefined)
            throw new Error("The parameter 'customerName' cannot be null.");
        else
            content_.append("CustomerName", customerName.toString());
        if (entityId === null || entityId === undefined)
            throw new Error("The parameter 'entityId' cannot be null.");
        else
            content_.append("EntityId", entityId.toString());
        if (ruleLogId === null || ruleLogId === undefined)
            throw new Error("The parameter 'ruleLogId' cannot be null.");
        else
            content_.append("RuleLogId", ruleLogId.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param title (optional) 
     * @param description (optional) 
     * @param product (optional) 
     * @param referenceNo (optional) 
     * @param caseStatusId (optional) 
     * @param reasonId (optional) 
     * @param assignedToId (optional) 
     * @param attachment_RemovedIds (optional) 
     * @param attachment_Files (optional) 
     * @param attachment_Id (optional) 
     * @param customer_Name (optional) 
     * @param customer_Gender (optional) 
     * @param customer_BirthDate (optional) 
     * @param customer_Address (optional) 
     * @param customer_IdentityNo (optional) 
     * @param customer_IdentityExpiryDate (optional) 
     * @param customer_Phone (optional) 
     * @param customer_IdentityTypeId (optional) 
     * @param customer_IssuePlaceId (optional) 
     * @param customer_NationalityId (optional) 
     * @param customer_ProfessionId (optional) 
     * @param customer_Id (optional) 
     * @param customerName (optional) 
     * @param entityId (optional) 
     * @param ruleLogId (optional) 
     * @param id (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, title: string | undefined, description: string | undefined, product: Products | undefined, referenceNo: string | undefined, caseStatusId: number | undefined, reasonId: number | undefined, assignedToId: number | undefined, attachment_RemovedIds: number[] | undefined, attachment_Files: FileParameter[] | undefined, attachment_Id: number | undefined, customer_Name: string | undefined, customer_Gender: Genders | undefined, customer_BirthDate: string | undefined, customer_Address: string | undefined, customer_IdentityNo: string | undefined, customer_IdentityExpiryDate: string | undefined, customer_Phone: string | undefined, customer_IdentityTypeId: number | undefined, customer_IssuePlaceId: number | undefined, customer_NationalityId: number | undefined, customer_ProfessionId: number | undefined, customer_Id: number | undefined, customerName: string | undefined, entityId: number | undefined, ruleLogId: number | undefined, id: number | undefined, signal?: AbortSignal): Promise<UpdateCaseDto> {
        let url_ = this.baseUrl + "/api/Compliance/Cases/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (title === null || title === undefined)
            throw new Error("The parameter 'title' cannot be null.");
        else
            content_.append("Title", title.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (product === null || product === undefined)
            throw new Error("The parameter 'product' cannot be null.");
        else
            content_.append("Product", product.toString());
        if (referenceNo === null || referenceNo === undefined)
            throw new Error("The parameter 'referenceNo' cannot be null.");
        else
            content_.append("ReferenceNo", referenceNo.toString());
        if (caseStatusId === null || caseStatusId === undefined)
            throw new Error("The parameter 'caseStatusId' cannot be null.");
        else
            content_.append("CaseStatusId", caseStatusId.toString());
        if (reasonId === null || reasonId === undefined)
            throw new Error("The parameter 'reasonId' cannot be null.");
        else
            content_.append("ReasonId", reasonId.toString());
        if (assignedToId === null || assignedToId === undefined)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else
            content_.append("AssignedToId", assignedToId.toString());
        if (attachment_RemovedIds === null || attachment_RemovedIds === undefined)
            throw new Error("The parameter 'attachment_RemovedIds' cannot be null.");
        else
            attachment_RemovedIds.forEach(item_ => content_.append("Attachment.RemovedIds", item_.toString()));
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );
        if (attachment_Id === null || attachment_Id === undefined)
            throw new Error("The parameter 'attachment_Id' cannot be null.");
        else
            content_.append("Attachment.Id", attachment_Id.toString());
        if (customer_Name === null || customer_Name === undefined)
            throw new Error("The parameter 'customer_Name' cannot be null.");
        else
            content_.append("Customer.Name", customer_Name.toString());
        if (customer_Gender === null || customer_Gender === undefined)
            throw new Error("The parameter 'customer_Gender' cannot be null.");
        else
            content_.append("Customer.Gender", customer_Gender.toString());
        if (customer_BirthDate === null || customer_BirthDate === undefined)
            throw new Error("The parameter 'customer_BirthDate' cannot be null.");
        else
            content_.append("Customer.BirthDate", customer_BirthDate.toString());
        if (customer_Address === null || customer_Address === undefined)
            throw new Error("The parameter 'customer_Address' cannot be null.");
        else
            content_.append("Customer.Address", customer_Address.toString());
        if (customer_IdentityNo === null || customer_IdentityNo === undefined)
            throw new Error("The parameter 'customer_IdentityNo' cannot be null.");
        else
            content_.append("Customer.IdentityNo", customer_IdentityNo.toString());
        if (customer_IdentityExpiryDate === null || customer_IdentityExpiryDate === undefined)
            throw new Error("The parameter 'customer_IdentityExpiryDate' cannot be null.");
        else
            content_.append("Customer.IdentityExpiryDate", customer_IdentityExpiryDate.toString());
        if (customer_Phone === null || customer_Phone === undefined)
            throw new Error("The parameter 'customer_Phone' cannot be null.");
        else
            content_.append("Customer.Phone", customer_Phone.toString());
        if (customer_IdentityTypeId === null || customer_IdentityTypeId === undefined)
            throw new Error("The parameter 'customer_IdentityTypeId' cannot be null.");
        else
            content_.append("Customer.IdentityTypeId", customer_IdentityTypeId.toString());
        if (customer_IssuePlaceId === null || customer_IssuePlaceId === undefined)
            throw new Error("The parameter 'customer_IssuePlaceId' cannot be null.");
        else
            content_.append("Customer.IssuePlaceId", customer_IssuePlaceId.toString());
        if (customer_NationalityId === null || customer_NationalityId === undefined)
            throw new Error("The parameter 'customer_NationalityId' cannot be null.");
        else
            content_.append("Customer.NationalityId", customer_NationalityId.toString());
        if (customer_ProfessionId === null || customer_ProfessionId === undefined)
            throw new Error("The parameter 'customer_ProfessionId' cannot be null.");
        else
            content_.append("Customer.ProfessionId", customer_ProfessionId.toString());
        if (customer_Id === null || customer_Id === undefined)
            throw new Error("The parameter 'customer_Id' cannot be null.");
        else
            content_.append("Customer.Id", customer_Id.toString());
        if (customerName === null || customerName === undefined)
            throw new Error("The parameter 'customerName' cannot be null.");
        else
            content_.append("CustomerName", customerName.toString());
        if (entityId === null || entityId === undefined)
            throw new Error("The parameter 'entityId' cannot be null.");
        else
            content_.append("EntityId", entityId.toString());
        if (ruleLogId === null || ruleLogId === undefined)
            throw new Error("The parameter 'ruleLogId' cannot be null.");
        else
            content_.append("RuleLogId", ruleLogId.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCaseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCaseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCaseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CaseDto> {
        let url_ = this.baseUrl + "/api/Compliance/Cases/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CaseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CaseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CaseDto>(null as any);
    }

    /**
     * @param searchKey (optional) 
     * @param number (optional) 
     * @param products (optional) 
     * @param title (optional) 
     * @param types (optional) 
     * @param referenceNo (optional) 
     * @param customerName (optional) 
     * @param branches (optional) 
     * @param assignedTo (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param caseStatuses (optional) 
     * @param reasonId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(searchKey: string | undefined, number: string | undefined, products: Products[] | undefined, title: string | undefined, types: CaseType[] | undefined, referenceNo: string | undefined, customerName: string | undefined, branches: number[] | undefined, assignedTo: number[] | undefined, date_From: string | undefined, date_To: string | undefined, caseStatuses: number[] | undefined, reasonId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CaseListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/Cases/GetPaginatedList?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "Products=" + encodeURIComponent("" + item) + "&"; });
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (referenceNo === null)
            throw new Error("The parameter 'referenceNo' cannot be null.");
        else if (referenceNo !== undefined)
            url_ += "ReferenceNo=" + encodeURIComponent("" + referenceNo) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (branches === null)
            throw new Error("The parameter 'branches' cannot be null.");
        else if (branches !== undefined)
            branches && branches.forEach(item => { url_ += "Branches=" + encodeURIComponent("" + item) + "&"; });
        if (assignedTo === null)
            throw new Error("The parameter 'assignedTo' cannot be null.");
        else if (assignedTo !== undefined)
            assignedTo && assignedTo.forEach(item => { url_ += "AssignedTo=" + encodeURIComponent("" + item) + "&"; });
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (caseStatuses === null)
            throw new Error("The parameter 'caseStatuses' cannot be null.");
        else if (caseStatuses !== undefined)
            caseStatuses && caseStatuses.forEach(item => { url_ += "CaseStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (reasonId === null)
            throw new Error("The parameter 'reasonId' cannot be null.");
        else if (reasonId !== undefined)
            url_ += "ReasonId=" + encodeURIComponent("" + reasonId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<CaseListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CaseListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CaseListDtoIPaginatedList>(null as any);
    }

    /**
     * @param searchKey (optional) 
     * @param number (optional) 
     * @param products (optional) 
     * @param title (optional) 
     * @param types (optional) 
     * @param referenceNo (optional) 
     * @param customerName (optional) 
     * @param branches (optional) 
     * @param assignedTo (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param caseStatuses (optional) 
     * @param reasonId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getMyPaginatedList(searchKey: string | undefined, number: string | undefined, products: Products[] | undefined, title: string | undefined, types: CaseType[] | undefined, referenceNo: string | undefined, customerName: string | undefined, branches: number[] | undefined, assignedTo: number[] | undefined, date_From: string | undefined, date_To: string | undefined, caseStatuses: number[] | undefined, reasonId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CaseListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/Cases/GetMyPaginatedList?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "Products=" + encodeURIComponent("" + item) + "&"; });
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (referenceNo === null)
            throw new Error("The parameter 'referenceNo' cannot be null.");
        else if (referenceNo !== undefined)
            url_ += "ReferenceNo=" + encodeURIComponent("" + referenceNo) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (branches === null)
            throw new Error("The parameter 'branches' cannot be null.");
        else if (branches !== undefined)
            branches && branches.forEach(item => { url_ += "Branches=" + encodeURIComponent("" + item) + "&"; });
        if (assignedTo === null)
            throw new Error("The parameter 'assignedTo' cannot be null.");
        else if (assignedTo !== undefined)
            assignedTo && assignedTo.forEach(item => { url_ += "AssignedTo=" + encodeURIComponent("" + item) + "&"; });
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (caseStatuses === null)
            throw new Error("The parameter 'caseStatuses' cannot be null.");
        else if (caseStatuses !== undefined)
            caseStatuses && caseStatuses.forEach(item => { url_ += "CaseStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (reasonId === null)
            throw new Error("The parameter 'reasonId' cannot be null.");
        else if (reasonId !== undefined)
            url_ += "ReasonId=" + encodeURIComponent("" + reasonId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyPaginatedList(_response);
        });
    }

    protected processGetMyPaginatedList(response: AxiosResponse): Promise<CaseListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CaseListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CaseListDtoIPaginatedList>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/Cases/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param caseId (optional) 
     * @param assignedToId (optional) 
     * @param message (optional) 
     * @param caseStatusId (optional) 
     * @param attachment (optional) 
     * @return Success
     */
    createConversation(branchIdHeader: string | undefined, caseId: number | undefined, assignedToId: number | undefined, message: string | undefined, caseStatusId: number | undefined, attachment: FileParameter | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/Cases/CreateConversation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (caseId === null || caseId === undefined)
            throw new Error("The parameter 'caseId' cannot be null.");
        else
            content_.append("CaseId", caseId.toString());
        if (assignedToId === null || assignedToId === undefined)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else
            content_.append("AssignedToId", assignedToId.toString());
        if (message === null || message === undefined)
            throw new Error("The parameter 'message' cannot be null.");
        else
            content_.append("Message", message.toString());
        if (caseStatusId === null || caseStatusId === undefined)
            throw new Error("The parameter 'caseStatusId' cannot be null.");
        else
            content_.append("CaseStatusId", caseStatusId.toString());
        if (attachment === null || attachment === undefined)
            throw new Error("The parameter 'attachment' cannot be null.");
        else
            content_.append("Attachment", attachment.data, attachment.fileName ? attachment.fileName : "Attachment");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateConversation(_response);
        });
    }

    protected processCreateConversation(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param actionDate_From (optional) 
     * @param actionDate_To (optional) 
     * @param actions (optional) 
     * @param actionById (optional) 
     * @param assignedToId (optional) 
     * @param referanceNumber (optional) 
     * @param addComplianceLogs (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getActivityLog(actionDate_From: string | undefined, actionDate_To: string | undefined, actions: ActivityLogAction[] | undefined, actionById: number[] | undefined, assignedToId: number[] | undefined, referanceNumber: string | undefined, addComplianceLogs: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ActivityLogDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/Cases/GetActivityLog?";
        if (actionDate_From === null)
            throw new Error("The parameter 'actionDate_From' cannot be null.");
        else if (actionDate_From !== undefined)
            url_ += "ActionDate.From=" + encodeURIComponent("" + actionDate_From) + "&";
        if (actionDate_To === null)
            throw new Error("The parameter 'actionDate_To' cannot be null.");
        else if (actionDate_To !== undefined)
            url_ += "ActionDate.To=" + encodeURIComponent("" + actionDate_To) + "&";
        if (actions === null)
            throw new Error("The parameter 'actions' cannot be null.");
        else if (actions !== undefined)
            actions && actions.forEach(item => { url_ += "Actions=" + encodeURIComponent("" + item) + "&"; });
        if (actionById === null)
            throw new Error("The parameter 'actionById' cannot be null.");
        else if (actionById !== undefined)
            actionById && actionById.forEach(item => { url_ += "ActionById=" + encodeURIComponent("" + item) + "&"; });
        if (assignedToId === null)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else if (assignedToId !== undefined)
            assignedToId && assignedToId.forEach(item => { url_ += "AssignedToId=" + encodeURIComponent("" + item) + "&"; });
        if (referanceNumber === null)
            throw new Error("The parameter 'referanceNumber' cannot be null.");
        else if (referanceNumber !== undefined)
            url_ += "ReferanceNumber=" + encodeURIComponent("" + referanceNumber) + "&";
        if (addComplianceLogs === null)
            throw new Error("The parameter 'addComplianceLogs' cannot be null.");
        else if (addComplianceLogs !== undefined)
            url_ += "AddComplianceLogs=" + encodeURIComponent("" + addComplianceLogs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActivityLog(_response);
        });
    }

    protected processGetActivityLog(response: AxiosResponse): Promise<ActivityLogDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ActivityLogDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityLogDto[]>(null as any);
    }
}

export class CaseStatusesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param active (optional) 
     * @param types (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(active: boolean | undefined, types: CaseType[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CaseStatusDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/CaseStatuses/GetList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CaseStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CaseStatusDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CaseStatusDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CaseStatusToUpdateDto> {
        let url_ = this.baseUrl + "/api/Compliance/CaseStatuses/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<CaseStatusToUpdateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CaseStatusToUpdateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CaseStatusToUpdateDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, body: AddCaseStatusDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/CaseStatuses/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateCaseStatusDto | undefined, signal?: AbortSignal): Promise<UpdateCaseStatusDto> {
        let url_ = this.baseUrl + "/api/Compliance/CaseStatuses/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCaseStatusDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCaseStatusDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCaseStatusDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/CaseStatuses/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/CaseStatuses/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ComplianceLogActionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param dataType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookupName(id: number | undefined, dataType: DataTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/GetLookupName?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (dataType === null)
            throw new Error("The parameter 'dataType' cannot be null.");
        else if (dataType !== undefined)
            url_ += "dataType=" + encodeURIComponent("" + dataType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookupName(_response);
        });
    }

    protected processGetLookupName(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param action (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getValidUserForComplianceLog(action: ComplianceActionsNeededUser | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<LookupApplicationUserDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/GetValidUserForComplianceLog?";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidUserForComplianceLog(_response);
        });
    }

    protected processGetValidUserForComplianceLog(response: AxiosResponse): Promise<LookupApplicationUserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LookupApplicationUserDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupApplicationUserDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getValidComplianceAction(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ComplianceActions[]> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/GetValidComplianceAction?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidComplianceAction(_response);
        });
    }

    protected processGetValidComplianceAction(response: AxiosResponse): Promise<ComplianceActions[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ComplianceActions[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceActions[]>(null as any);
    }

    /**
     * @param referenceNumber (optional) 
     * @param product (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getValidComplianceActionByReferenceNumber(referenceNumber: string | undefined, product: Products | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ComplianceActions[]> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/GetValidComplianceActionByReferenceNumber?";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "referenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "product=" + encodeURIComponent("" + product) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidComplianceActionByReferenceNumber(_response);
        });
    }

    protected processGetValidComplianceActionByReferenceNumber(response: AxiosResponse): Promise<ComplianceActions[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ComplianceActions[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceActions[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param complianceLogId (optional) 
     * @param action (optional) 
     * @param remarks (optional) 
     * @param assignedToId (optional) 
     * @param addAttachment_Files (optional) 
     * @param closeOption (optional) 
     * @param blockBehavior (optional) 
     * @return Success
     */
    setComplianceAction(branchIdHeader: string | undefined, complianceLogId: number | undefined, action: ComplianceActions | undefined, remarks: string | undefined, assignedToId: number | undefined, addAttachment_Files: FileParameter[] | undefined, closeOption: CloseOptions | undefined, blockBehavior: BlockBehaviors | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/SetComplianceAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (complianceLogId === null || complianceLogId === undefined)
            throw new Error("The parameter 'complianceLogId' cannot be null.");
        else
            content_.append("ComplianceLogId", complianceLogId.toString());
        if (action === null || action === undefined)
            throw new Error("The parameter 'action' cannot be null.");
        else
            content_.append("Action", action.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (assignedToId === null || assignedToId === undefined)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else
            content_.append("AssignedToId", assignedToId.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );
        if (closeOption === null || closeOption === undefined)
            throw new Error("The parameter 'closeOption' cannot be null.");
        else
            content_.append("CloseOption", closeOption.toString());
        if (blockBehavior === null || blockBehavior === undefined)
            throw new Error("The parameter 'blockBehavior' cannot be null.");
        else
            content_.append("BlockBehavior", blockBehavior.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetComplianceAction(_response);
        });
    }

    protected processSetComplianceAction(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param referenceNumber (optional) 
     * @param product (optional) 
     * @param action (optional) 
     * @param remarks (optional) 
     * @param assignedToId (optional) 
     * @param addAttachment_Files (optional) 
     * @param closeOption (optional) 
     * @param blockBehavior (optional) 
     * @return Success
     */
    setComplianceActionByReferenceNumber(branchIdHeader: string | undefined, referenceNumber: string | undefined, product: Products | undefined, action: ComplianceActions | undefined, remarks: string | undefined, assignedToId: number | undefined, addAttachment_Files: FileParameter[] | undefined, closeOption: CloseOptions | undefined, blockBehavior: BlockBehaviors | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/SetComplianceActionByReferenceNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (referenceNumber === null || referenceNumber === undefined)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else
            content_.append("ReferenceNumber", referenceNumber.toString());
        if (product === null || product === undefined)
            throw new Error("The parameter 'product' cannot be null.");
        else
            content_.append("Product", product.toString());
        if (action === null || action === undefined)
            throw new Error("The parameter 'action' cannot be null.");
        else
            content_.append("Action", action.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (assignedToId === null || assignedToId === undefined)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else
            content_.append("AssignedToId", assignedToId.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );
        if (closeOption === null || closeOption === undefined)
            throw new Error("The parameter 'closeOption' cannot be null.");
        else
            content_.append("CloseOption", closeOption.toString());
        if (blockBehavior === null || blockBehavior === undefined)
            throw new Error("The parameter 'blockBehavior' cannot be null.");
        else
            content_.append("BlockBehavior", blockBehavior.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetComplianceActionByReferenceNumber(_response);
        });
    }

    protected processSetComplianceActionByReferenceNumber(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ruleLogId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getValidRuleActions(ruleLogId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RuleActions[]> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/GetValidRuleActions?";
        if (ruleLogId === null)
            throw new Error("The parameter 'ruleLogId' cannot be null.");
        else if (ruleLogId !== undefined)
            url_ += "ruleLogId=" + encodeURIComponent("" + ruleLogId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidRuleActions(_response);
        });
    }

    protected processGetValidRuleActions(response: AxiosResponse): Promise<RuleActions[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RuleActions[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RuleActions[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param ruleLogId (optional) 
     * @param action (optional) 
     * @param remarks (optional) 
     * @param assignedToId (optional) 
     * @param addAttachment_Files (optional) 
     * @param closeOption (optional) 
     * @param forceReleaseComplianceLog (optional) 
     * @param blockBehavior (optional) 
     * @return Success
     */
    setActionToRuleLog(branchIdHeader: string | undefined, ruleLogId: number | undefined, action: RuleActions | undefined, remarks: string | undefined, assignedToId: number | undefined, addAttachment_Files: FileParameter[] | undefined, closeOption: CloseOptions | undefined, forceReleaseComplianceLog: boolean | undefined, blockBehavior: BlockBehaviors | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/SetActionToRuleLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (ruleLogId === null || ruleLogId === undefined)
            throw new Error("The parameter 'ruleLogId' cannot be null.");
        else
            content_.append("RuleLogId", ruleLogId.toString());
        if (action === null || action === undefined)
            throw new Error("The parameter 'action' cannot be null.");
        else
            content_.append("Action", action.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (assignedToId === null || assignedToId === undefined)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else
            content_.append("AssignedToId", assignedToId.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );
        if (closeOption === null || closeOption === undefined)
            throw new Error("The parameter 'closeOption' cannot be null.");
        else
            content_.append("CloseOption", closeOption.toString());
        if (forceReleaseComplianceLog === null || forceReleaseComplianceLog === undefined)
            throw new Error("The parameter 'forceReleaseComplianceLog' cannot be null.");
        else
            content_.append("ForceReleaseComplianceLog", forceReleaseComplianceLog.toString());
        if (blockBehavior === null || blockBehavior === undefined)
            throw new Error("The parameter 'blockBehavior' cannot be null.");
        else
            content_.append("BlockBehavior", blockBehavior.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetActionToRuleLog(_response);
        });
    }

    protected processSetActionToRuleLog(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    complianceActionUsers(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleApplicationUserDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/ComplianceActionUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processComplianceActionUsers(_response);
        });
    }

    protected processComplianceActionUsers(response: AxiosResponse): Promise<SimpleApplicationUserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleApplicationUserDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleApplicationUserDto[]>(null as any);
    }

    /**
     * @param referenceNumber (optional) 
     * @param product (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getEntityComplianceHistory(referenceNumber: string | undefined, product: Products | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ComplianceLogHistoryDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/GetEntityComplianceHistory?";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "referenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "product=" + encodeURIComponent("" + product) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEntityComplianceHistory(_response);
        });
    }

    protected processGetEntityComplianceHistory(response: AxiosResponse): Promise<ComplianceLogHistoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ComplianceLogHistoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceLogHistoryDto[]>(null as any);
    }

    /**
     * @param complianceId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getComplianceLogById(complianceId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ComplianceLogDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceLogAction/GetComplianceLogById?";
        if (complianceId === null)
            throw new Error("The parameter 'complianceId' cannot be null.");
        else if (complianceId !== undefined)
            url_ += "complianceId=" + encodeURIComponent("" + complianceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetComplianceLogById(_response);
        });
    }

    protected processGetComplianceLogById(response: AxiosResponse): Promise<ComplianceLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ComplianceLogDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceLogDto>(null as any);
    }
}

export class ComplianceMonitoringClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param searchKey (optional) 
     * @param referenceNumber (optional) 
     * @param name (optional) 
     * @param products (optional) 
     * @param statuses (optional) 
     * @param branchIds (optional) 
     * @param assignedIds (optional) 
     * @param riskLevelIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportTMSMonitor(searchKey: string | undefined, referenceNumber: string | undefined, name: string | undefined, products: Products[] | undefined, statuses: ComplianceLogStatuses[] | undefined, branchIds: number[] | undefined, assignedIds: number[] | undefined, riskLevelIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceMonitoring/ExportTMSMonitor?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "ReferenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "Products=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (assignedIds === null)
            throw new Error("The parameter 'assignedIds' cannot be null.");
        else if (assignedIds !== undefined)
            assignedIds && assignedIds.forEach(item => { url_ += "AssignedIds=" + encodeURIComponent("" + item) + "&"; });
        if (riskLevelIds === null)
            throw new Error("The parameter 'riskLevelIds' cannot be null.");
        else if (riskLevelIds !== undefined)
            riskLevelIds && riskLevelIds.forEach(item => { url_ += "RiskLevelIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportTMSMonitor(_response);
        });
    }

    protected processExportTMSMonitor(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param searchKey (optional) 
     * @param cHKNumber (optional) 
     * @param roleLogNumber (optional) 
     * @param logNumber (optional) 
     * @param referenceNumber (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param customerName (optional) 
     * @param products (optional) 
     * @param branchIds (optional) 
     * @param amlRoleIds (optional) 
     * @param statuses (optional) 
     * @param assignedIds (optional) 
     * @param complianceLogIds (optional) 
     * @param isSanctionScreeningLogs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportRuleMonitor(searchKey: string | undefined, cHKNumber: string | undefined, roleLogNumber: string[] | undefined, logNumber: string | undefined, referenceNumber: string | undefined, date_From: string | undefined, date_To: string | undefined, customerName: string | undefined, products: Products[] | undefined, branchIds: number[] | undefined, amlRoleIds: number[] | undefined, statuses: RuleLogStatuses[] | undefined, assignedIds: number[] | undefined, complianceLogIds: number[] | undefined, isSanctionScreeningLogs: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceMonitoring/ExportRuleMonitor?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (cHKNumber === null)
            throw new Error("The parameter 'cHKNumber' cannot be null.");
        else if (cHKNumber !== undefined)
            url_ += "CHKNumber=" + encodeURIComponent("" + cHKNumber) + "&";
        if (roleLogNumber === null)
            throw new Error("The parameter 'roleLogNumber' cannot be null.");
        else if (roleLogNumber !== undefined)
            roleLogNumber && roleLogNumber.forEach(item => { url_ += "RoleLogNumber=" + encodeURIComponent("" + item) + "&"; });
        if (logNumber === null)
            throw new Error("The parameter 'logNumber' cannot be null.");
        else if (logNumber !== undefined)
            url_ += "LogNumber=" + encodeURIComponent("" + logNumber) + "&";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "ReferenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "Products=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (amlRoleIds === null)
            throw new Error("The parameter 'amlRoleIds' cannot be null.");
        else if (amlRoleIds !== undefined)
            amlRoleIds && amlRoleIds.forEach(item => { url_ += "AmlRoleIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (assignedIds === null)
            throw new Error("The parameter 'assignedIds' cannot be null.");
        else if (assignedIds !== undefined)
            assignedIds && assignedIds.forEach(item => { url_ += "AssignedIds=" + encodeURIComponent("" + item) + "&"; });
        if (complianceLogIds === null)
            throw new Error("The parameter 'complianceLogIds' cannot be null.");
        else if (complianceLogIds !== undefined)
            complianceLogIds && complianceLogIds.forEach(item => { url_ += "ComplianceLogIds=" + encodeURIComponent("" + item) + "&"; });
        if (isSanctionScreeningLogs === null)
            throw new Error("The parameter 'isSanctionScreeningLogs' cannot be null.");
        else if (isSanctionScreeningLogs !== undefined)
            url_ += "IsSanctionScreeningLogs=" + encodeURIComponent("" + isSanctionScreeningLogs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportRuleMonitor(_response);
        });
    }

    protected processExportRuleMonitor(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param searchKey (optional) 
     * @param cHKNumber (optional) 
     * @param roleLogNumber (optional) 
     * @param logNumber (optional) 
     * @param referenceNumber (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param customerName (optional) 
     * @param products (optional) 
     * @param branchIds (optional) 
     * @param amlRoleIds (optional) 
     * @param statuses (optional) 
     * @param assignedIds (optional) 
     * @param complianceLogIds (optional) 
     * @param isSanctionScreeningLogs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportScreeningMonitorList(searchKey: string | undefined, cHKNumber: string | undefined, roleLogNumber: string[] | undefined, logNumber: string | undefined, referenceNumber: string | undefined, date_From: string | undefined, date_To: string | undefined, customerName: string | undefined, products: Products[] | undefined, branchIds: number[] | undefined, amlRoleIds: number[] | undefined, statuses: RuleLogStatuses[] | undefined, assignedIds: number[] | undefined, complianceLogIds: number[] | undefined, isSanctionScreeningLogs: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceMonitoring/ExportScreeningMonitorList?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (cHKNumber === null)
            throw new Error("The parameter 'cHKNumber' cannot be null.");
        else if (cHKNumber !== undefined)
            url_ += "CHKNumber=" + encodeURIComponent("" + cHKNumber) + "&";
        if (roleLogNumber === null)
            throw new Error("The parameter 'roleLogNumber' cannot be null.");
        else if (roleLogNumber !== undefined)
            roleLogNumber && roleLogNumber.forEach(item => { url_ += "RoleLogNumber=" + encodeURIComponent("" + item) + "&"; });
        if (logNumber === null)
            throw new Error("The parameter 'logNumber' cannot be null.");
        else if (logNumber !== undefined)
            url_ += "LogNumber=" + encodeURIComponent("" + logNumber) + "&";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "ReferenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "Products=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (amlRoleIds === null)
            throw new Error("The parameter 'amlRoleIds' cannot be null.");
        else if (amlRoleIds !== undefined)
            amlRoleIds && amlRoleIds.forEach(item => { url_ += "AmlRoleIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (assignedIds === null)
            throw new Error("The parameter 'assignedIds' cannot be null.");
        else if (assignedIds !== undefined)
            assignedIds && assignedIds.forEach(item => { url_ += "AssignedIds=" + encodeURIComponent("" + item) + "&"; });
        if (complianceLogIds === null)
            throw new Error("The parameter 'complianceLogIds' cannot be null.");
        else if (complianceLogIds !== undefined)
            complianceLogIds && complianceLogIds.forEach(item => { url_ += "ComplianceLogIds=" + encodeURIComponent("" + item) + "&"; });
        if (isSanctionScreeningLogs === null)
            throw new Error("The parameter 'isSanctionScreeningLogs' cannot be null.");
        else if (isSanctionScreeningLogs !== undefined)
            url_ += "IsSanctionScreeningLogs=" + encodeURIComponent("" + isSanctionScreeningLogs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportScreeningMonitorList(_response);
        });
    }

    protected processExportScreeningMonitorList(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    testRisksAndRules(branchIdHeader: string | undefined, body: SourceProduct | undefined, signal?: AbortSignal): Promise<CalculationResult> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceMonitoring/TestRisksAndRules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTestRisksAndRules(_response);
        });
    }

    protected processTestRisksAndRules(response: AxiosResponse): Promise<CalculationResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CalculationResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CalculationResult>(null as any);
    }

    /**
     * @param searchKey (optional) 
     * @param referenceNumber (optional) 
     * @param name (optional) 
     * @param products (optional) 
     * @param statuses (optional) 
     * @param branchIds (optional) 
     * @param assignedIds (optional) 
     * @param riskLevelIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    tMSMonitor(searchKey: string | undefined, referenceNumber: string | undefined, name: string | undefined, products: Products[] | undefined, statuses: ComplianceLogStatuses[] | undefined, branchIds: number[] | undefined, assignedIds: number[] | undefined, riskLevelIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ComplianceLogListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceMonitoring/TMSMonitor?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "ReferenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "Products=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (assignedIds === null)
            throw new Error("The parameter 'assignedIds' cannot be null.");
        else if (assignedIds !== undefined)
            assignedIds && assignedIds.forEach(item => { url_ += "AssignedIds=" + encodeURIComponent("" + item) + "&"; });
        if (riskLevelIds === null)
            throw new Error("The parameter 'riskLevelIds' cannot be null.");
        else if (riskLevelIds !== undefined)
            riskLevelIds && riskLevelIds.forEach(item => { url_ += "RiskLevelIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTMSMonitor(_response);
        });
    }

    protected processTMSMonitor(response: AxiosResponse): Promise<ComplianceLogListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ComplianceLogListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceLogListDtoIPaginatedList>(null as any);
    }

    /**
     * @param searchKey (optional) 
     * @param cHKNumber (optional) 
     * @param roleLogNumber (optional) 
     * @param logNumber (optional) 
     * @param referenceNumber (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param customerName (optional) 
     * @param products (optional) 
     * @param branchIds (optional) 
     * @param amlRoleIds (optional) 
     * @param statuses (optional) 
     * @param assignedIds (optional) 
     * @param complianceLogIds (optional) 
     * @param isSanctionScreeningLogs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getRuleMonitorList(searchKey: string | undefined, cHKNumber: string | undefined, roleLogNumber: string[] | undefined, logNumber: string | undefined, referenceNumber: string | undefined, date_From: string | undefined, date_To: string | undefined, customerName: string | undefined, products: Products[] | undefined, branchIds: number[] | undefined, amlRoleIds: number[] | undefined, statuses: RuleLogStatuses[] | undefined, assignedIds: number[] | undefined, complianceLogIds: number[] | undefined, isSanctionScreeningLogs: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RuleMonitorDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceMonitoring/GetRuleMonitorList?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (cHKNumber === null)
            throw new Error("The parameter 'cHKNumber' cannot be null.");
        else if (cHKNumber !== undefined)
            url_ += "CHKNumber=" + encodeURIComponent("" + cHKNumber) + "&";
        if (roleLogNumber === null)
            throw new Error("The parameter 'roleLogNumber' cannot be null.");
        else if (roleLogNumber !== undefined)
            roleLogNumber && roleLogNumber.forEach(item => { url_ += "RoleLogNumber=" + encodeURIComponent("" + item) + "&"; });
        if (logNumber === null)
            throw new Error("The parameter 'logNumber' cannot be null.");
        else if (logNumber !== undefined)
            url_ += "LogNumber=" + encodeURIComponent("" + logNumber) + "&";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "ReferenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "Products=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (amlRoleIds === null)
            throw new Error("The parameter 'amlRoleIds' cannot be null.");
        else if (amlRoleIds !== undefined)
            amlRoleIds && amlRoleIds.forEach(item => { url_ += "AmlRoleIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (assignedIds === null)
            throw new Error("The parameter 'assignedIds' cannot be null.");
        else if (assignedIds !== undefined)
            assignedIds && assignedIds.forEach(item => { url_ += "AssignedIds=" + encodeURIComponent("" + item) + "&"; });
        if (complianceLogIds === null)
            throw new Error("The parameter 'complianceLogIds' cannot be null.");
        else if (complianceLogIds !== undefined)
            complianceLogIds && complianceLogIds.forEach(item => { url_ += "ComplianceLogIds=" + encodeURIComponent("" + item) + "&"; });
        if (isSanctionScreeningLogs === null)
            throw new Error("The parameter 'isSanctionScreeningLogs' cannot be null.");
        else if (isSanctionScreeningLogs !== undefined)
            url_ += "IsSanctionScreeningLogs=" + encodeURIComponent("" + isSanctionScreeningLogs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRuleMonitorList(_response);
        });
    }

    protected processGetRuleMonitorList(response: AxiosResponse): Promise<RuleMonitorDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RuleMonitorDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RuleMonitorDtoIPaginatedList>(null as any);
    }

    /**
     * @param searchKey (optional) 
     * @param cHKNumber (optional) 
     * @param roleLogNumber (optional) 
     * @param logNumber (optional) 
     * @param referenceNumber (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param customerName (optional) 
     * @param products (optional) 
     * @param branchIds (optional) 
     * @param amlRoleIds (optional) 
     * @param statuses (optional) 
     * @param assignedIds (optional) 
     * @param complianceLogIds (optional) 
     * @param isSanctionScreeningLogs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    screeningMonitorList(searchKey: string | undefined, cHKNumber: string | undefined, roleLogNumber: string[] | undefined, logNumber: string | undefined, referenceNumber: string | undefined, date_From: string | undefined, date_To: string | undefined, customerName: string | undefined, products: Products[] | undefined, branchIds: number[] | undefined, amlRoleIds: number[] | undefined, statuses: RuleLogStatuses[] | undefined, assignedIds: number[] | undefined, complianceLogIds: number[] | undefined, isSanctionScreeningLogs: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RuleMonitorDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceMonitoring/ScreeningMonitorList?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (cHKNumber === null)
            throw new Error("The parameter 'cHKNumber' cannot be null.");
        else if (cHKNumber !== undefined)
            url_ += "CHKNumber=" + encodeURIComponent("" + cHKNumber) + "&";
        if (roleLogNumber === null)
            throw new Error("The parameter 'roleLogNumber' cannot be null.");
        else if (roleLogNumber !== undefined)
            roleLogNumber && roleLogNumber.forEach(item => { url_ += "RoleLogNumber=" + encodeURIComponent("" + item) + "&"; });
        if (logNumber === null)
            throw new Error("The parameter 'logNumber' cannot be null.");
        else if (logNumber !== undefined)
            url_ += "LogNumber=" + encodeURIComponent("" + logNumber) + "&";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "ReferenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "Products=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (amlRoleIds === null)
            throw new Error("The parameter 'amlRoleIds' cannot be null.");
        else if (amlRoleIds !== undefined)
            amlRoleIds && amlRoleIds.forEach(item => { url_ += "AmlRoleIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (assignedIds === null)
            throw new Error("The parameter 'assignedIds' cannot be null.");
        else if (assignedIds !== undefined)
            assignedIds && assignedIds.forEach(item => { url_ += "AssignedIds=" + encodeURIComponent("" + item) + "&"; });
        if (complianceLogIds === null)
            throw new Error("The parameter 'complianceLogIds' cannot be null.");
        else if (complianceLogIds !== undefined)
            complianceLogIds && complianceLogIds.forEach(item => { url_ += "ComplianceLogIds=" + encodeURIComponent("" + item) + "&"; });
        if (isSanctionScreeningLogs === null)
            throw new Error("The parameter 'isSanctionScreeningLogs' cannot be null.");
        else if (isSanctionScreeningLogs !== undefined)
            url_ += "IsSanctionScreeningLogs=" + encodeURIComponent("" + isSanctionScreeningLogs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScreeningMonitorList(_response);
        });
    }

    protected processScreeningMonitorList(response: AxiosResponse): Promise<RuleMonitorDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RuleMonitorDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RuleMonitorDtoIPaginatedList>(null as any);
    }

    /**
     * @param referenceNumber (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getRuleMonitorByReferenceNumber(referenceNumber: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RuleMonitorByIdDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceMonitoring/GetRuleMonitorByReferenceNumber?";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "referenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRuleMonitorByReferenceNumber(_response);
        });
    }

    protected processGetRuleMonitorByReferenceNumber(response: AxiosResponse): Promise<RuleMonitorByIdDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RuleMonitorByIdDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RuleMonitorByIdDto>(null as any);
    }
}

export class ComplianceReportClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param name (optional) 
     * @param types (optional) 
     * @param subTypes (optional) 
     * @param nationalityIds (optional) 
     * @param identityTypeIds (optional) 
     * @param identityNumber (optional) 
     * @param professionIds (optional) 
     * @param riskScore_From (optional) 
     * @param riskScore_To (optional) 
     * @param riskLevels (optional) 
     * @param branchIds (optional) 
     * @param statuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCustomerRegistration(date_From: string | undefined, date_To: string | undefined, name: string | undefined, types: CustomerTypes[] | undefined, subTypes: number[] | undefined, nationalityIds: number[] | undefined, identityTypeIds: number[] | undefined, identityNumber: string | undefined, professionIds: number[] | undefined, riskScore_From: number | undefined, riskScore_To: number | undefined, riskLevels: number[] | undefined, branchIds: number[] | undefined, statuses: CustomerStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerRegistrationReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/GetCustomerRegistration?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (subTypes === null)
            throw new Error("The parameter 'subTypes' cannot be null.");
        else if (subTypes !== undefined)
            subTypes && subTypes.forEach(item => { url_ += "SubTypes=" + encodeURIComponent("" + item) + "&"; });
        if (nationalityIds === null)
            throw new Error("The parameter 'nationalityIds' cannot be null.");
        else if (nationalityIds !== undefined)
            nationalityIds && nationalityIds.forEach(item => { url_ += "NationalityIds=" + encodeURIComponent("" + item) + "&"; });
        if (identityTypeIds === null)
            throw new Error("The parameter 'identityTypeIds' cannot be null.");
        else if (identityTypeIds !== undefined)
            identityTypeIds && identityTypeIds.forEach(item => { url_ += "IdentityTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (identityNumber === null)
            throw new Error("The parameter 'identityNumber' cannot be null.");
        else if (identityNumber !== undefined)
            url_ += "IdentityNumber=" + encodeURIComponent("" + identityNumber) + "&";
        if (professionIds === null)
            throw new Error("The parameter 'professionIds' cannot be null.");
        else if (professionIds !== undefined)
            professionIds && professionIds.forEach(item => { url_ += "ProfessionIds=" + encodeURIComponent("" + item) + "&"; });
        if (riskScore_From === null)
            throw new Error("The parameter 'riskScore_From' cannot be null.");
        else if (riskScore_From !== undefined)
            url_ += "RiskScore.From=" + encodeURIComponent("" + riskScore_From) + "&";
        if (riskScore_To === null)
            throw new Error("The parameter 'riskScore_To' cannot be null.");
        else if (riskScore_To !== undefined)
            url_ += "RiskScore.To=" + encodeURIComponent("" + riskScore_To) + "&";
        if (riskLevels === null)
            throw new Error("The parameter 'riskLevels' cannot be null.");
        else if (riskLevels !== undefined)
            riskLevels && riskLevels.forEach(item => { url_ += "RiskLevels=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCustomerRegistration(_response);
        });
    }

    protected processGetCustomerRegistration(response: AxiosResponse): Promise<CustomerRegistrationReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerRegistrationReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerRegistrationReportModelIPaginatedList>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param ruleIds (optional) 
     * @param branchIds (optional) 
     * @param transactionTypeIds (optional) 
     * @param currencyIds (optional) 
     * @param fCAmount_From (optional) 
     * @param fCAmount_To (optional) 
     * @param lCAmount_From (optional) 
     * @param lCAmount_To (optional) 
     * @param ruleLogStatuses (optional) 
     * @param complianceActions (optional) 
     * @param actionBy (optional) 
     * @param transactionStatuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTMSFCExchangeTransaction(date_From: string | undefined, date_To: string | undefined, ruleIds: number[] | undefined, branchIds: number[] | undefined, transactionTypeIds: number[] | undefined, currencyIds: number[] | undefined, fCAmount_From: number | undefined, fCAmount_To: number | undefined, lCAmount_From: number | undefined, lCAmount_To: number | undefined, ruleLogStatuses: RuleLogStatuses[] | undefined, complianceActions: ComplianceActions[] | undefined, actionBy: number[] | undefined, transactionStatuses: TransactionStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TMSFCExchangeTransactionReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/GetTMSFCExchangeTransaction?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (ruleIds === null)
            throw new Error("The parameter 'ruleIds' cannot be null.");
        else if (ruleIds !== undefined)
            ruleIds && ruleIds.forEach(item => { url_ += "RuleIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (transactionTypeIds === null)
            throw new Error("The parameter 'transactionTypeIds' cannot be null.");
        else if (transactionTypeIds !== undefined)
            transactionTypeIds && transactionTypeIds.forEach(item => { url_ += "TransactionTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (currencyIds === null)
            throw new Error("The parameter 'currencyIds' cannot be null.");
        else if (currencyIds !== undefined)
            currencyIds && currencyIds.forEach(item => { url_ += "CurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (fCAmount_From === null)
            throw new Error("The parameter 'fCAmount_From' cannot be null.");
        else if (fCAmount_From !== undefined)
            url_ += "FCAmount.From=" + encodeURIComponent("" + fCAmount_From) + "&";
        if (fCAmount_To === null)
            throw new Error("The parameter 'fCAmount_To' cannot be null.");
        else if (fCAmount_To !== undefined)
            url_ += "FCAmount.To=" + encodeURIComponent("" + fCAmount_To) + "&";
        if (lCAmount_From === null)
            throw new Error("The parameter 'lCAmount_From' cannot be null.");
        else if (lCAmount_From !== undefined)
            url_ += "LCAmount.From=" + encodeURIComponent("" + lCAmount_From) + "&";
        if (lCAmount_To === null)
            throw new Error("The parameter 'lCAmount_To' cannot be null.");
        else if (lCAmount_To !== undefined)
            url_ += "LCAmount.To=" + encodeURIComponent("" + lCAmount_To) + "&";
        if (ruleLogStatuses === null)
            throw new Error("The parameter 'ruleLogStatuses' cannot be null.");
        else if (ruleLogStatuses !== undefined)
            ruleLogStatuses && ruleLogStatuses.forEach(item => { url_ += "RuleLogStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (complianceActions === null)
            throw new Error("The parameter 'complianceActions' cannot be null.");
        else if (complianceActions !== undefined)
            complianceActions && complianceActions.forEach(item => { url_ += "ComplianceActions=" + encodeURIComponent("" + item) + "&"; });
        if (actionBy === null)
            throw new Error("The parameter 'actionBy' cannot be null.");
        else if (actionBy !== undefined)
            actionBy && actionBy.forEach(item => { url_ += "ActionBy=" + encodeURIComponent("" + item) + "&"; });
        if (transactionStatuses === null)
            throw new Error("The parameter 'transactionStatuses' cannot be null.");
        else if (transactionStatuses !== undefined)
            transactionStatuses && transactionStatuses.forEach(item => { url_ += "TransactionStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTMSFCExchangeTransaction(_response);
        });
    }

    protected processGetTMSFCExchangeTransaction(response: AxiosResponse): Promise<TMSFCExchangeTransactionReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TMSFCExchangeTransactionReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TMSFCExchangeTransactionReportModelIPaginatedList>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param ruleIds (optional) 
     * @param branchIds (optional) 
     * @param providerIds (optional) 
     * @param countryIds (optional) 
     * @param payoutCurrencyIds (optional) 
     * @param payoutAmount_From (optional) 
     * @param payoutAmount_To (optional) 
     * @param complianceStatuses (optional) 
     * @param complianceActions (optional) 
     * @param actionBy (optional) 
     * @param statuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTMSSendTransaction(date_From: string | undefined, date_To: string | undefined, ruleIds: number[] | undefined, branchIds: number[] | undefined, providerIds: number[] | undefined, countryIds: number[] | undefined, payoutCurrencyIds: number[] | undefined, payoutAmount_From: number | undefined, payoutAmount_To: number | undefined, complianceStatuses: RuleLogStatuses[] | undefined, complianceActions: ComplianceActions[] | undefined, actionBy: number[] | undefined, statuses: TransactionStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TMSSendTransactionReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/GetTMSSendTransaction?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (ruleIds === null)
            throw new Error("The parameter 'ruleIds' cannot be null.");
        else if (ruleIds !== undefined)
            ruleIds && ruleIds.forEach(item => { url_ += "RuleIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "CountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (payoutCurrencyIds === null)
            throw new Error("The parameter 'payoutCurrencyIds' cannot be null.");
        else if (payoutCurrencyIds !== undefined)
            payoutCurrencyIds && payoutCurrencyIds.forEach(item => { url_ += "PayoutCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (payoutAmount_From === null)
            throw new Error("The parameter 'payoutAmount_From' cannot be null.");
        else if (payoutAmount_From !== undefined)
            url_ += "PayoutAmount.From=" + encodeURIComponent("" + payoutAmount_From) + "&";
        if (payoutAmount_To === null)
            throw new Error("The parameter 'payoutAmount_To' cannot be null.");
        else if (payoutAmount_To !== undefined)
            url_ += "PayoutAmount.To=" + encodeURIComponent("" + payoutAmount_To) + "&";
        if (complianceStatuses === null)
            throw new Error("The parameter 'complianceStatuses' cannot be null.");
        else if (complianceStatuses !== undefined)
            complianceStatuses && complianceStatuses.forEach(item => { url_ += "ComplianceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (complianceActions === null)
            throw new Error("The parameter 'complianceActions' cannot be null.");
        else if (complianceActions !== undefined)
            complianceActions && complianceActions.forEach(item => { url_ += "ComplianceActions=" + encodeURIComponent("" + item) + "&"; });
        if (actionBy === null)
            throw new Error("The parameter 'actionBy' cannot be null.");
        else if (actionBy !== undefined)
            actionBy && actionBy.forEach(item => { url_ += "ActionBy=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTMSSendTransaction(_response);
        });
    }

    protected processGetTMSSendTransaction(response: AxiosResponse): Promise<TMSSendTransactionReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TMSSendTransactionReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TMSSendTransactionReportModelIPaginatedList>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param ruleIds (optional) 
     * @param branchIds (optional) 
     * @param providerIds (optional) 
     * @param countryIds (optional) 
     * @param payoutAmount_From (optional) 
     * @param payoutAmount_To (optional) 
     * @param complianceStatuses (optional) 
     * @param complianceActions (optional) 
     * @param actionBy (optional) 
     * @param transactionStatuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTMSReceiveTransaction(date_From: string | undefined, date_To: string | undefined, ruleIds: number[] | undefined, branchIds: number[] | undefined, providerIds: number[] | undefined, countryIds: number[] | undefined, payoutAmount_From: number | undefined, payoutAmount_To: number | undefined, complianceStatuses: RuleLogStatuses[] | undefined, complianceActions: ComplianceActions[] | undefined, actionBy: number[] | undefined, transactionStatuses: TransactionStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TMSReceiveTransactionReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/GetTMSReceiveTransaction?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (ruleIds === null)
            throw new Error("The parameter 'ruleIds' cannot be null.");
        else if (ruleIds !== undefined)
            ruleIds && ruleIds.forEach(item => { url_ += "RuleIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "CountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (payoutAmount_From === null)
            throw new Error("The parameter 'payoutAmount_From' cannot be null.");
        else if (payoutAmount_From !== undefined)
            url_ += "PayoutAmount.From=" + encodeURIComponent("" + payoutAmount_From) + "&";
        if (payoutAmount_To === null)
            throw new Error("The parameter 'payoutAmount_To' cannot be null.");
        else if (payoutAmount_To !== undefined)
            url_ += "PayoutAmount.To=" + encodeURIComponent("" + payoutAmount_To) + "&";
        if (complianceStatuses === null)
            throw new Error("The parameter 'complianceStatuses' cannot be null.");
        else if (complianceStatuses !== undefined)
            complianceStatuses && complianceStatuses.forEach(item => { url_ += "ComplianceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (complianceActions === null)
            throw new Error("The parameter 'complianceActions' cannot be null.");
        else if (complianceActions !== undefined)
            complianceActions && complianceActions.forEach(item => { url_ += "ComplianceActions=" + encodeURIComponent("" + item) + "&"; });
        if (actionBy === null)
            throw new Error("The parameter 'actionBy' cannot be null.");
        else if (actionBy !== undefined)
            actionBy && actionBy.forEach(item => { url_ += "ActionBy=" + encodeURIComponent("" + item) + "&"; });
        if (transactionStatuses === null)
            throw new Error("The parameter 'transactionStatuses' cannot be null.");
        else if (transactionStatuses !== undefined)
            transactionStatuses && transactionStatuses.forEach(item => { url_ += "TransactionStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTMSReceiveTransaction(_response);
        });
    }

    protected processGetTMSReceiveTransaction(response: AxiosResponse): Promise<TMSReceiveTransactionReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TMSReceiveTransactionReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TMSReceiveTransactionReportModelIPaginatedList>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param complianceStatuses (optional) 
     * @param complianceActions (optional) 
     * @param actionBy (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCustomerProfileScreening(date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, complianceStatuses: RuleLogStatuses[] | undefined, complianceActions: ComplianceActions[] | undefined, actionBy: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerProfileScreeningReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/GetCustomerProfileScreening?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (complianceStatuses === null)
            throw new Error("The parameter 'complianceStatuses' cannot be null.");
        else if (complianceStatuses !== undefined)
            complianceStatuses && complianceStatuses.forEach(item => { url_ += "ComplianceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (complianceActions === null)
            throw new Error("The parameter 'complianceActions' cannot be null.");
        else if (complianceActions !== undefined)
            complianceActions && complianceActions.forEach(item => { url_ += "ComplianceActions=" + encodeURIComponent("" + item) + "&"; });
        if (actionBy === null)
            throw new Error("The parameter 'actionBy' cannot be null.");
        else if (actionBy !== undefined)
            actionBy && actionBy.forEach(item => { url_ += "ActionBy=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCustomerProfileScreening(_response);
        });
    }

    protected processGetCustomerProfileScreening(response: AxiosResponse): Promise<CustomerProfileScreeningReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerProfileScreeningReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerProfileScreeningReportModelIPaginatedList>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param transactionTypeIds (optional) 
     * @param providerIds (optional) 
     * @param customer (optional) 
     * @param customerSubTypeIds (optional) 
     * @param payinCurrencyIds (optional) 
     * @param payinAmount_From (optional) 
     * @param payinAmount_To (optional) 
     * @param payoutCurrencyIds (optional) 
     * @param payoutAmount_From (optional) 
     * @param payoutAmount_To (optional) 
     * @param userIds (optional) 
     * @param statuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getThirdPartyTransaction(date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, transactionTypeIds: TransactionTypes[] | undefined, providerIds: number[] | undefined, customer: string | undefined, customerSubTypeIds: number[] | undefined, payinCurrencyIds: number[] | undefined, payinAmount_From: number | undefined, payinAmount_To: number | undefined, payoutCurrencyIds: number[] | undefined, payoutAmount_From: number | undefined, payoutAmount_To: number | undefined, userIds: number[] | undefined, statuses: TransactionStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ThirdPartyTransactionReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/GetThirdPartyTransaction?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (transactionTypeIds === null)
            throw new Error("The parameter 'transactionTypeIds' cannot be null.");
        else if (transactionTypeIds !== undefined)
            transactionTypeIds && transactionTypeIds.forEach(item => { url_ += "TransactionTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (customer === null)
            throw new Error("The parameter 'customer' cannot be null.");
        else if (customer !== undefined)
            url_ += "Customer=" + encodeURIComponent("" + customer) + "&";
        if (customerSubTypeIds === null)
            throw new Error("The parameter 'customerSubTypeIds' cannot be null.");
        else if (customerSubTypeIds !== undefined)
            customerSubTypeIds && customerSubTypeIds.forEach(item => { url_ += "CustomerSubTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (payinCurrencyIds === null)
            throw new Error("The parameter 'payinCurrencyIds' cannot be null.");
        else if (payinCurrencyIds !== undefined)
            payinCurrencyIds && payinCurrencyIds.forEach(item => { url_ += "PayinCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (payinAmount_From === null)
            throw new Error("The parameter 'payinAmount_From' cannot be null.");
        else if (payinAmount_From !== undefined)
            url_ += "PayinAmount.From=" + encodeURIComponent("" + payinAmount_From) + "&";
        if (payinAmount_To === null)
            throw new Error("The parameter 'payinAmount_To' cannot be null.");
        else if (payinAmount_To !== undefined)
            url_ += "PayinAmount.To=" + encodeURIComponent("" + payinAmount_To) + "&";
        if (payoutCurrencyIds === null)
            throw new Error("The parameter 'payoutCurrencyIds' cannot be null.");
        else if (payoutCurrencyIds !== undefined)
            payoutCurrencyIds && payoutCurrencyIds.forEach(item => { url_ += "PayoutCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (payoutAmount_From === null)
            throw new Error("The parameter 'payoutAmount_From' cannot be null.");
        else if (payoutAmount_From !== undefined)
            url_ += "PayoutAmount.From=" + encodeURIComponent("" + payoutAmount_From) + "&";
        if (payoutAmount_To === null)
            throw new Error("The parameter 'payoutAmount_To' cannot be null.");
        else if (payoutAmount_To !== undefined)
            url_ += "PayoutAmount.To=" + encodeURIComponent("" + payoutAmount_To) + "&";
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "UserIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetThirdPartyTransaction(_response);
        });
    }

    protected processGetThirdPartyTransaction(response: AxiosResponse): Promise<ThirdPartyTransactionReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ThirdPartyTransactionReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ThirdPartyTransactionReportModelIPaginatedList>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param complianceStatuses (optional) 
     * @param complianceActions (optional) 
     * @param actionBy (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTransactionSanctionScreening(date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, complianceStatuses: RuleLogStatuses[] | undefined, complianceActions: ComplianceActions[] | undefined, actionBy: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TransactionSanctionScreeningReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/GetTransactionSanctionScreening?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (complianceStatuses === null)
            throw new Error("The parameter 'complianceStatuses' cannot be null.");
        else if (complianceStatuses !== undefined)
            complianceStatuses && complianceStatuses.forEach(item => { url_ += "ComplianceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (complianceActions === null)
            throw new Error("The parameter 'complianceActions' cannot be null.");
        else if (complianceActions !== undefined)
            complianceActions && complianceActions.forEach(item => { url_ += "ComplianceActions=" + encodeURIComponent("" + item) + "&"; });
        if (actionBy === null)
            throw new Error("The parameter 'actionBy' cannot be null.");
        else if (actionBy !== undefined)
            actionBy && actionBy.forEach(item => { url_ += "ActionBy=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTransactionSanctionScreening(_response);
        });
    }

    protected processGetTransactionSanctionScreening(response: AxiosResponse): Promise<TransactionSanctionScreeningReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionSanctionScreeningReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionSanctionScreeningReportModelIPaginatedList>(null as any);
    }

    /**
     * @param role (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getUsersByRole(role: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerRegistrationReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/GetUsersByRole?";
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsersByRole(_response);
        });
    }

    protected processGetUsersByRole(response: AxiosResponse): Promise<CustomerRegistrationReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerRegistrationReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerRegistrationReportModelIPaginatedList>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param ruleIds (optional) 
     * @param branchIds (optional) 
     * @param transactionTypeIds (optional) 
     * @param currencyIds (optional) 
     * @param fCAmount_From (optional) 
     * @param fCAmount_To (optional) 
     * @param lCAmount_From (optional) 
     * @param lCAmount_To (optional) 
     * @param ruleLogStatuses (optional) 
     * @param complianceActions (optional) 
     * @param actionBy (optional) 
     * @param transactionStatuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportTMSFCExchangeTransaction(date_From: string | undefined, date_To: string | undefined, ruleIds: number[] | undefined, branchIds: number[] | undefined, transactionTypeIds: number[] | undefined, currencyIds: number[] | undefined, fCAmount_From: number | undefined, fCAmount_To: number | undefined, lCAmount_From: number | undefined, lCAmount_To: number | undefined, ruleLogStatuses: RuleLogStatuses[] | undefined, complianceActions: ComplianceActions[] | undefined, actionBy: number[] | undefined, transactionStatuses: TransactionStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/ExportTMSFCExchangeTransaction?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (ruleIds === null)
            throw new Error("The parameter 'ruleIds' cannot be null.");
        else if (ruleIds !== undefined)
            ruleIds && ruleIds.forEach(item => { url_ += "RuleIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (transactionTypeIds === null)
            throw new Error("The parameter 'transactionTypeIds' cannot be null.");
        else if (transactionTypeIds !== undefined)
            transactionTypeIds && transactionTypeIds.forEach(item => { url_ += "TransactionTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (currencyIds === null)
            throw new Error("The parameter 'currencyIds' cannot be null.");
        else if (currencyIds !== undefined)
            currencyIds && currencyIds.forEach(item => { url_ += "CurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (fCAmount_From === null)
            throw new Error("The parameter 'fCAmount_From' cannot be null.");
        else if (fCAmount_From !== undefined)
            url_ += "FCAmount.From=" + encodeURIComponent("" + fCAmount_From) + "&";
        if (fCAmount_To === null)
            throw new Error("The parameter 'fCAmount_To' cannot be null.");
        else if (fCAmount_To !== undefined)
            url_ += "FCAmount.To=" + encodeURIComponent("" + fCAmount_To) + "&";
        if (lCAmount_From === null)
            throw new Error("The parameter 'lCAmount_From' cannot be null.");
        else if (lCAmount_From !== undefined)
            url_ += "LCAmount.From=" + encodeURIComponent("" + lCAmount_From) + "&";
        if (lCAmount_To === null)
            throw new Error("The parameter 'lCAmount_To' cannot be null.");
        else if (lCAmount_To !== undefined)
            url_ += "LCAmount.To=" + encodeURIComponent("" + lCAmount_To) + "&";
        if (ruleLogStatuses === null)
            throw new Error("The parameter 'ruleLogStatuses' cannot be null.");
        else if (ruleLogStatuses !== undefined)
            ruleLogStatuses && ruleLogStatuses.forEach(item => { url_ += "RuleLogStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (complianceActions === null)
            throw new Error("The parameter 'complianceActions' cannot be null.");
        else if (complianceActions !== undefined)
            complianceActions && complianceActions.forEach(item => { url_ += "ComplianceActions=" + encodeURIComponent("" + item) + "&"; });
        if (actionBy === null)
            throw new Error("The parameter 'actionBy' cannot be null.");
        else if (actionBy !== undefined)
            actionBy && actionBy.forEach(item => { url_ += "ActionBy=" + encodeURIComponent("" + item) + "&"; });
        if (transactionStatuses === null)
            throw new Error("The parameter 'transactionStatuses' cannot be null.");
        else if (transactionStatuses !== undefined)
            transactionStatuses && transactionStatuses.forEach(item => { url_ += "TransactionStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportTMSFCExchangeTransaction(_response);
        });
    }

    protected processExportTMSFCExchangeTransaction(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param ruleIds (optional) 
     * @param branchIds (optional) 
     * @param providerIds (optional) 
     * @param countryIds (optional) 
     * @param payoutAmount_From (optional) 
     * @param payoutAmount_To (optional) 
     * @param complianceStatuses (optional) 
     * @param complianceActions (optional) 
     * @param actionBy (optional) 
     * @param transactionStatuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportTMSReceiveTransaction(date_From: string | undefined, date_To: string | undefined, ruleIds: number[] | undefined, branchIds: number[] | undefined, providerIds: number[] | undefined, countryIds: number[] | undefined, payoutAmount_From: number | undefined, payoutAmount_To: number | undefined, complianceStatuses: RuleLogStatuses[] | undefined, complianceActions: ComplianceActions[] | undefined, actionBy: number[] | undefined, transactionStatuses: TransactionStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/ExportTMSReceiveTransaction?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (ruleIds === null)
            throw new Error("The parameter 'ruleIds' cannot be null.");
        else if (ruleIds !== undefined)
            ruleIds && ruleIds.forEach(item => { url_ += "RuleIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "CountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (payoutAmount_From === null)
            throw new Error("The parameter 'payoutAmount_From' cannot be null.");
        else if (payoutAmount_From !== undefined)
            url_ += "PayoutAmount.From=" + encodeURIComponent("" + payoutAmount_From) + "&";
        if (payoutAmount_To === null)
            throw new Error("The parameter 'payoutAmount_To' cannot be null.");
        else if (payoutAmount_To !== undefined)
            url_ += "PayoutAmount.To=" + encodeURIComponent("" + payoutAmount_To) + "&";
        if (complianceStatuses === null)
            throw new Error("The parameter 'complianceStatuses' cannot be null.");
        else if (complianceStatuses !== undefined)
            complianceStatuses && complianceStatuses.forEach(item => { url_ += "ComplianceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (complianceActions === null)
            throw new Error("The parameter 'complianceActions' cannot be null.");
        else if (complianceActions !== undefined)
            complianceActions && complianceActions.forEach(item => { url_ += "ComplianceActions=" + encodeURIComponent("" + item) + "&"; });
        if (actionBy === null)
            throw new Error("The parameter 'actionBy' cannot be null.");
        else if (actionBy !== undefined)
            actionBy && actionBy.forEach(item => { url_ += "ActionBy=" + encodeURIComponent("" + item) + "&"; });
        if (transactionStatuses === null)
            throw new Error("The parameter 'transactionStatuses' cannot be null.");
        else if (transactionStatuses !== undefined)
            transactionStatuses && transactionStatuses.forEach(item => { url_ += "TransactionStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportTMSReceiveTransaction(_response);
        });
    }

    protected processExportTMSReceiveTransaction(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param ruleIds (optional) 
     * @param branchIds (optional) 
     * @param providerIds (optional) 
     * @param countryIds (optional) 
     * @param payoutCurrencyIds (optional) 
     * @param payoutAmount_From (optional) 
     * @param payoutAmount_To (optional) 
     * @param complianceStatuses (optional) 
     * @param complianceActions (optional) 
     * @param actionBy (optional) 
     * @param statuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportTMSSendTransaction(date_From: string | undefined, date_To: string | undefined, ruleIds: number[] | undefined, branchIds: number[] | undefined, providerIds: number[] | undefined, countryIds: number[] | undefined, payoutCurrencyIds: number[] | undefined, payoutAmount_From: number | undefined, payoutAmount_To: number | undefined, complianceStatuses: RuleLogStatuses[] | undefined, complianceActions: ComplianceActions[] | undefined, actionBy: number[] | undefined, statuses: TransactionStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/ExportTMSSendTransaction?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (ruleIds === null)
            throw new Error("The parameter 'ruleIds' cannot be null.");
        else if (ruleIds !== undefined)
            ruleIds && ruleIds.forEach(item => { url_ += "RuleIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "CountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (payoutCurrencyIds === null)
            throw new Error("The parameter 'payoutCurrencyIds' cannot be null.");
        else if (payoutCurrencyIds !== undefined)
            payoutCurrencyIds && payoutCurrencyIds.forEach(item => { url_ += "PayoutCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (payoutAmount_From === null)
            throw new Error("The parameter 'payoutAmount_From' cannot be null.");
        else if (payoutAmount_From !== undefined)
            url_ += "PayoutAmount.From=" + encodeURIComponent("" + payoutAmount_From) + "&";
        if (payoutAmount_To === null)
            throw new Error("The parameter 'payoutAmount_To' cannot be null.");
        else if (payoutAmount_To !== undefined)
            url_ += "PayoutAmount.To=" + encodeURIComponent("" + payoutAmount_To) + "&";
        if (complianceStatuses === null)
            throw new Error("The parameter 'complianceStatuses' cannot be null.");
        else if (complianceStatuses !== undefined)
            complianceStatuses && complianceStatuses.forEach(item => { url_ += "ComplianceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (complianceActions === null)
            throw new Error("The parameter 'complianceActions' cannot be null.");
        else if (complianceActions !== undefined)
            complianceActions && complianceActions.forEach(item => { url_ += "ComplianceActions=" + encodeURIComponent("" + item) + "&"; });
        if (actionBy === null)
            throw new Error("The parameter 'actionBy' cannot be null.");
        else if (actionBy !== undefined)
            actionBy && actionBy.forEach(item => { url_ += "ActionBy=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportTMSSendTransaction(_response);
        });
    }

    protected processExportTMSSendTransaction(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param transactionTypeIds (optional) 
     * @param providerIds (optional) 
     * @param customer (optional) 
     * @param customerSubTypeIds (optional) 
     * @param payinCurrencyIds (optional) 
     * @param payinAmount_From (optional) 
     * @param payinAmount_To (optional) 
     * @param payoutCurrencyIds (optional) 
     * @param payoutAmount_From (optional) 
     * @param payoutAmount_To (optional) 
     * @param userIds (optional) 
     * @param statuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportThirdPartyTransaction(date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, transactionTypeIds: TransactionTypes[] | undefined, providerIds: number[] | undefined, customer: string | undefined, customerSubTypeIds: number[] | undefined, payinCurrencyIds: number[] | undefined, payinAmount_From: number | undefined, payinAmount_To: number | undefined, payoutCurrencyIds: number[] | undefined, payoutAmount_From: number | undefined, payoutAmount_To: number | undefined, userIds: number[] | undefined, statuses: TransactionStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/ExportThirdPartyTransaction?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (transactionTypeIds === null)
            throw new Error("The parameter 'transactionTypeIds' cannot be null.");
        else if (transactionTypeIds !== undefined)
            transactionTypeIds && transactionTypeIds.forEach(item => { url_ += "TransactionTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (customer === null)
            throw new Error("The parameter 'customer' cannot be null.");
        else if (customer !== undefined)
            url_ += "Customer=" + encodeURIComponent("" + customer) + "&";
        if (customerSubTypeIds === null)
            throw new Error("The parameter 'customerSubTypeIds' cannot be null.");
        else if (customerSubTypeIds !== undefined)
            customerSubTypeIds && customerSubTypeIds.forEach(item => { url_ += "CustomerSubTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (payinCurrencyIds === null)
            throw new Error("The parameter 'payinCurrencyIds' cannot be null.");
        else if (payinCurrencyIds !== undefined)
            payinCurrencyIds && payinCurrencyIds.forEach(item => { url_ += "PayinCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (payinAmount_From === null)
            throw new Error("The parameter 'payinAmount_From' cannot be null.");
        else if (payinAmount_From !== undefined)
            url_ += "PayinAmount.From=" + encodeURIComponent("" + payinAmount_From) + "&";
        if (payinAmount_To === null)
            throw new Error("The parameter 'payinAmount_To' cannot be null.");
        else if (payinAmount_To !== undefined)
            url_ += "PayinAmount.To=" + encodeURIComponent("" + payinAmount_To) + "&";
        if (payoutCurrencyIds === null)
            throw new Error("The parameter 'payoutCurrencyIds' cannot be null.");
        else if (payoutCurrencyIds !== undefined)
            payoutCurrencyIds && payoutCurrencyIds.forEach(item => { url_ += "PayoutCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (payoutAmount_From === null)
            throw new Error("The parameter 'payoutAmount_From' cannot be null.");
        else if (payoutAmount_From !== undefined)
            url_ += "PayoutAmount.From=" + encodeURIComponent("" + payoutAmount_From) + "&";
        if (payoutAmount_To === null)
            throw new Error("The parameter 'payoutAmount_To' cannot be null.");
        else if (payoutAmount_To !== undefined)
            url_ += "PayoutAmount.To=" + encodeURIComponent("" + payoutAmount_To) + "&";
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "UserIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportThirdPartyTransaction(_response);
        });
    }

    protected processExportThirdPartyTransaction(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param complianceStatuses (optional) 
     * @param complianceActions (optional) 
     * @param actionBy (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportCustomerProfileScreening(date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, complianceStatuses: RuleLogStatuses[] | undefined, complianceActions: ComplianceActions[] | undefined, actionBy: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/ExportCustomerProfileScreening?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (complianceStatuses === null)
            throw new Error("The parameter 'complianceStatuses' cannot be null.");
        else if (complianceStatuses !== undefined)
            complianceStatuses && complianceStatuses.forEach(item => { url_ += "ComplianceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (complianceActions === null)
            throw new Error("The parameter 'complianceActions' cannot be null.");
        else if (complianceActions !== undefined)
            complianceActions && complianceActions.forEach(item => { url_ += "ComplianceActions=" + encodeURIComponent("" + item) + "&"; });
        if (actionBy === null)
            throw new Error("The parameter 'actionBy' cannot be null.");
        else if (actionBy !== undefined)
            actionBy && actionBy.forEach(item => { url_ += "ActionBy=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportCustomerProfileScreening(_response);
        });
    }

    protected processExportCustomerProfileScreening(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param complianceStatuses (optional) 
     * @param complianceActions (optional) 
     * @param actionBy (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportTransactionSanctionScreening(date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, complianceStatuses: RuleLogStatuses[] | undefined, complianceActions: ComplianceActions[] | undefined, actionBy: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/ExportTransactionSanctionScreening?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (complianceStatuses === null)
            throw new Error("The parameter 'complianceStatuses' cannot be null.");
        else if (complianceStatuses !== undefined)
            complianceStatuses && complianceStatuses.forEach(item => { url_ += "ComplianceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (complianceActions === null)
            throw new Error("The parameter 'complianceActions' cannot be null.");
        else if (complianceActions !== undefined)
            complianceActions && complianceActions.forEach(item => { url_ += "ComplianceActions=" + encodeURIComponent("" + item) + "&"; });
        if (actionBy === null)
            throw new Error("The parameter 'actionBy' cannot be null.");
        else if (actionBy !== undefined)
            actionBy && actionBy.forEach(item => { url_ += "ActionBy=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportTransactionSanctionScreening(_response);
        });
    }

    protected processExportTransactionSanctionScreening(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param name (optional) 
     * @param types (optional) 
     * @param subTypes (optional) 
     * @param nationalityIds (optional) 
     * @param identityTypeIds (optional) 
     * @param identityNumber (optional) 
     * @param professionIds (optional) 
     * @param riskScore_From (optional) 
     * @param riskScore_To (optional) 
     * @param riskLevels (optional) 
     * @param branchIds (optional) 
     * @param statuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportCustomerRegistration(date_From: string | undefined, date_To: string | undefined, name: string | undefined, types: CustomerTypes[] | undefined, subTypes: number[] | undefined, nationalityIds: number[] | undefined, identityTypeIds: number[] | undefined, identityNumber: string | undefined, professionIds: number[] | undefined, riskScore_From: number | undefined, riskScore_To: number | undefined, riskLevels: number[] | undefined, branchIds: number[] | undefined, statuses: CustomerStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceReport/ExportCustomerRegistration?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (subTypes === null)
            throw new Error("The parameter 'subTypes' cannot be null.");
        else if (subTypes !== undefined)
            subTypes && subTypes.forEach(item => { url_ += "SubTypes=" + encodeURIComponent("" + item) + "&"; });
        if (nationalityIds === null)
            throw new Error("The parameter 'nationalityIds' cannot be null.");
        else if (nationalityIds !== undefined)
            nationalityIds && nationalityIds.forEach(item => { url_ += "NationalityIds=" + encodeURIComponent("" + item) + "&"; });
        if (identityTypeIds === null)
            throw new Error("The parameter 'identityTypeIds' cannot be null.");
        else if (identityTypeIds !== undefined)
            identityTypeIds && identityTypeIds.forEach(item => { url_ += "IdentityTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (identityNumber === null)
            throw new Error("The parameter 'identityNumber' cannot be null.");
        else if (identityNumber !== undefined)
            url_ += "IdentityNumber=" + encodeURIComponent("" + identityNumber) + "&";
        if (professionIds === null)
            throw new Error("The parameter 'professionIds' cannot be null.");
        else if (professionIds !== undefined)
            professionIds && professionIds.forEach(item => { url_ += "ProfessionIds=" + encodeURIComponent("" + item) + "&"; });
        if (riskScore_From === null)
            throw new Error("The parameter 'riskScore_From' cannot be null.");
        else if (riskScore_From !== undefined)
            url_ += "RiskScore.From=" + encodeURIComponent("" + riskScore_From) + "&";
        if (riskScore_To === null)
            throw new Error("The parameter 'riskScore_To' cannot be null.");
        else if (riskScore_To !== undefined)
            url_ += "RiskScore.To=" + encodeURIComponent("" + riskScore_To) + "&";
        if (riskLevels === null)
            throw new Error("The parameter 'riskLevels' cannot be null.");
        else if (riskLevels !== undefined)
            riskLevels && riskLevels.forEach(item => { url_ += "RiskLevels=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportCustomerRegistration(_response);
        });
    }

    protected processExportCustomerRegistration(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class ComplianceVariableClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullComplianceVariableDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceVariable/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullComplianceVariableDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullComplianceVariableDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullComplianceVariableDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ComplianceVariableDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceVariable/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ComplianceVariableDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ComplianceVariableDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceVariableDto>(null as any);
    }

    /**
     * @param key (optional) 
     * @param active (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(key: string | undefined, active: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ComplianceVariableDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceVariable/GetPaginatedList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<ComplianceVariableDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ComplianceVariableDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceVariableDtoIPaginatedList>(null as any);
    }

    /**
     * @param name (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(name: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ComplianceVariableDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceVariable/GetList?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<ComplianceVariableDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ComplianceVariableDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceVariableDto[]>(null as any);
    }

    /**
     * @param dataType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookups(dataType: DataTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ComplianceVariableDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceVariable/GetLookups?";
        if (dataType === null)
            throw new Error("The parameter 'dataType' cannot be null.");
        else if (dataType !== undefined)
            url_ += "dataType=" + encodeURIComponent("" + dataType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookups(_response);
        });
    }

    protected processGetLookups(response: AxiosResponse): Promise<ComplianceVariableDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ComplianceVariableDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceVariableDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddComplianceVariableDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceVariable/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateComplianceVariableDto | undefined, signal?: AbortSignal): Promise<UpdateComplianceVariableDto> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceVariable/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateComplianceVariableDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateComplianceVariableDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateComplianceVariableDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceVariable/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/ComplianceVariable/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class DashboardClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param count (optional) 
     * @param period (optional) 
     * @param branchIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCustomerRiskScore(count: number | undefined, period: TimePeriods | undefined, branchIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskScoreStatistic> {
        let url_ = this.baseUrl + "/api/Compliance/Dashboard/GetCustomerRiskScore?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCustomerRiskScore(_response);
        });
    }

    protected processGetCustomerRiskScore(response: AxiosResponse): Promise<RiskScoreStatistic> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskScoreStatistic>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskScoreStatistic>(null as any);
    }

    /**
     * @param count (optional) 
     * @param period (optional) 
     * @param branchIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getFCExchangeTransactionRiskScore(count: number | undefined, period: TimePeriods | undefined, branchIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskScoreStatistic> {
        let url_ = this.baseUrl + "/api/Compliance/Dashboard/GetFCExchangeTransactionRiskScore?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFCExchangeTransactionRiskScore(_response);
        });
    }

    protected processGetFCExchangeTransactionRiskScore(response: AxiosResponse): Promise<RiskScoreStatistic> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskScoreStatistic>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskScoreStatistic>(null as any);
    }

    /**
     * @param count (optional) 
     * @param period (optional) 
     * @param branchIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getSendTransactionRiskScore(count: number | undefined, period: TimePeriods | undefined, branchIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskScoreStatistic> {
        let url_ = this.baseUrl + "/api/Compliance/Dashboard/GetSendTransactionRiskScore?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSendTransactionRiskScore(_response);
        });
    }

    protected processGetSendTransactionRiskScore(response: AxiosResponse): Promise<RiskScoreStatistic> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskScoreStatistic>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskScoreStatistic>(null as any);
    }

    /**
     * @param count (optional) 
     * @param period (optional) 
     * @param branchIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getReceiveTransactionRiskScore(count: number | undefined, period: TimePeriods | undefined, branchIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskScoreStatistic> {
        let url_ = this.baseUrl + "/api/Compliance/Dashboard/GetReceiveTransactionRiskScore?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceiveTransactionRiskScore(_response);
        });
    }

    protected processGetReceiveTransactionRiskScore(response: AxiosResponse): Promise<RiskScoreStatistic> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskScoreStatistic>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskScoreStatistic>(null as any);
    }

    /**
     * @param count (optional) 
     * @param period (optional) 
     * @param branchIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getStatistics(count: number | undefined, period: TimePeriods | undefined, branchIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<DashboardStatistics> {
        let url_ = this.baseUrl + "/api/Compliance/Dashboard/GetStatistics?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStatistics(_response);
        });
    }

    protected processGetStatistics(response: AxiosResponse): Promise<DashboardStatistics> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<DashboardStatistics>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardStatistics>(null as any);
    }

    /**
     * @param count (optional) 
     * @param period (optional) 
     * @param branchIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTopViolatedRules(count: number | undefined, period: TimePeriods | undefined, branchIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ViolatedRule[]> {
        let url_ = this.baseUrl + "/api/Compliance/Dashboard/GetTopViolatedRules?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTopViolatedRules(_response);
        });
    }

    protected processGetTopViolatedRules(response: AxiosResponse): Promise<ViolatedRule[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ViolatedRule[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ViolatedRule[]>(null as any);
    }

    /**
     * @param count (optional) 
     * @param period (optional) 
     * @param branchIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getActiveCases(count: number | undefined, period: TimePeriods | undefined, branchIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ActiveCaseIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/Dashboard/GetActiveCases?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActiveCases(_response);
        });
    }

    protected processGetActiveCases(response: AxiosResponse): Promise<ActiveCaseIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ActiveCaseIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActiveCaseIPaginatedList>(null as any);
    }

    /**
     * @param count (optional) 
     * @param period (optional) 
     * @param branchIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getAmlViolationHistory(count: number | undefined, period: TimePeriods | undefined, branchIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<AmlViolated[]> {
        let url_ = this.baseUrl + "/api/Compliance/Dashboard/GetAmlViolationHistory?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAmlViolationHistory(_response);
        });
    }

    protected processGetAmlViolationHistory(response: AxiosResponse): Promise<AmlViolated[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AmlViolated[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AmlViolated[]>(null as any);
    }
}

export class RiskCategoryClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullRiskCategoryDto> {
        let url_ = this.baseUrl + "/api/Compliance/RiskCategory/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullRiskCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullRiskCategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullRiskCategoryDto>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookupList(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskCategorySimpleDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/RiskCategory/GetLookupList?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookupList(_response);
        });
    }

    protected processGetLookupList(response: AxiosResponse): Promise<RiskCategorySimpleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskCategorySimpleDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskCategorySimpleDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskCategoryDto> {
        let url_ = this.baseUrl + "/api/Compliance/RiskCategory/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<RiskCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskCategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskCategoryDto>(null as any);
    }

    /**
     * @param products (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(products: Products[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskCategoryDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/RiskCategory/GetList?";
        if (products === null)
            throw new Error("The parameter 'products' cannot be null.");
        else if (products !== undefined)
            products && products.forEach(item => { url_ += "products=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<RiskCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskCategoryDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddRiskCategoryDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/RiskCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateRiskCategoryDto | undefined, signal?: AbortSignal): Promise<UpdateRiskCategoryDto> {
        let url_ = this.baseUrl + "/api/Compliance/RiskCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateRiskCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateRiskCategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateRiskCategoryDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/RiskCategory/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/RiskCategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class RiskFactorsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param key (optional) 
     * @param name (optional) 
     * @param product (optional) 
     * @param dataType (optional) 
     * @param active (optional) 
     * @param includeCustomerProfile (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(key: string | undefined, name: string | undefined, product: Products | undefined, dataType: DataTypes | undefined, active: boolean | undefined, includeCustomerProfile: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskFactorDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/RiskFactors/GetList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "Product=" + encodeURIComponent("" + product) + "&";
        if (dataType === null)
            throw new Error("The parameter 'dataType' cannot be null.");
        else if (dataType !== undefined)
            url_ += "DataType=" + encodeURIComponent("" + dataType) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (includeCustomerProfile === null)
            throw new Error("The parameter 'includeCustomerProfile' cannot be null.");
        else if (includeCustomerProfile !== undefined)
            url_ += "IncludeCustomerProfile=" + encodeURIComponent("" + includeCustomerProfile) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<RiskFactorDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskFactorDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskFactorDto[]>(null as any);
    }

    /**
     * @param key (optional) 
     * @param name (optional) 
     * @param product (optional) 
     * @param dataType (optional) 
     * @param active (optional) 
     * @param includeCustomerProfile (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(key: string | undefined, name: string | undefined, product: Products | undefined, dataType: DataTypes | undefined, active: boolean | undefined, includeCustomerProfile: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskFactorDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/RiskFactors/GetPaginatedList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "Product=" + encodeURIComponent("" + product) + "&";
        if (dataType === null)
            throw new Error("The parameter 'dataType' cannot be null.");
        else if (dataType !== undefined)
            url_ += "DataType=" + encodeURIComponent("" + dataType) + "&";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (includeCustomerProfile === null)
            throw new Error("The parameter 'includeCustomerProfile' cannot be null.");
        else if (includeCustomerProfile !== undefined)
            url_ += "IncludeCustomerProfile=" + encodeURIComponent("" + includeCustomerProfile) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<RiskFactorDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskFactorDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskFactorDtoIPaginatedList>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookupList(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskFactorSimpleDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/RiskFactors/GetLookupList?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookupList(_response);
        });
    }

    protected processGetLookupList(response: AxiosResponse): Promise<RiskFactorSimpleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskFactorSimpleDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskFactorSimpleDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskFactorFullDto> {
        let url_ = this.baseUrl + "/api/Compliance/RiskFactors/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<RiskFactorFullDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskFactorFullDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskFactorFullDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, body: AddRiskFactorDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/RiskFactors/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateRiskFactorDto | undefined, signal?: AbortSignal): Promise<UpdateRiskFactorDto> {
        let url_ = this.baseUrl + "/api/Compliance/RiskFactors/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateRiskFactorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateRiskFactorDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateRiskFactorDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/RiskFactors/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/RiskFactors/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RiskLevelClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getFullList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullRiskLevelDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/RiskLevel/GetFullList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFullList(_response);
        });
    }

    protected processGetFullList(response: AxiosResponse): Promise<FullRiskLevelDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullRiskLevelDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullRiskLevelDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    set(branchIdHeader: string | undefined, body: SetRiskLevelModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/RiskLevel/Set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSet(_response);
        });
    }

    protected processSet(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param product (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(product: Products | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskLevelDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/RiskLevel/GetList?";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "product=" + encodeURIComponent("" + product) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<RiskLevelDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskLevelDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskLevelDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    setRiskLevelProduct(branchIdHeader: string | undefined, body: SetRiskLevelProductDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/RiskLevel/SetRiskLevelProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetRiskLevelProduct(_response);
        });
    }

    protected processSetRiskLevelProduct(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param product (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookups(product: Products | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskLevelSimpleDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/RiskLevel/GetLookups?";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "product=" + encodeURIComponent("" + product) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookups(_response);
        });
    }

    protected processGetLookups(response: AxiosResponse): Promise<RiskLevelSimpleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskLevelSimpleDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskLevelSimpleDto[]>(null as any);
    }

    /**
     * @param product (optional) 
     * @param score (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getByScore(product: Products | undefined, score: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RiskLevelDto> {
        let url_ = this.baseUrl + "/api/Compliance/RiskLevel/GetByScore?";
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "product=" + encodeURIComponent("" + product) + "&";
        if (score === null)
            throw new Error("The parameter 'score' cannot be null.");
        else if (score !== undefined)
            url_ += "score=" + encodeURIComponent("" + score) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByScore(_response);
        });
    }

    protected processGetByScore(response: AxiosResponse): Promise<RiskLevelDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RiskLevelDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RiskLevelDto>(null as any);
    }
}

export class ScreeningWhitelistClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddScreeningWhitelistDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Compliance/ScreeningWhitelist/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param key (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(key: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ScreeningWhitelistDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/ScreeningWhitelist/GetPaginatedList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<ScreeningWhitelistDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ScreeningWhitelistDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScreeningWhitelistDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateScreeningWhitelistDto | undefined, signal?: AbortSignal): Promise<UpdateScreeningWhitelistDto> {
        let url_ = this.baseUrl + "/api/Compliance/ScreeningWhitelist/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateScreeningWhitelistDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateScreeningWhitelistDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateScreeningWhitelistDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/ScreeningWhitelist/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Compliance/ScreeningWhitelist/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class WatchlistMembersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<WatchlistMemberDto> {
        let url_ = this.baseUrl + "/api/Compliance/WatchlistMembers/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<WatchlistMemberDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WatchlistMemberDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WatchlistMemberDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<WatchlistMemberFullDto> {
        let url_ = this.baseUrl + "/api/Compliance/WatchlistMembers/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<WatchlistMemberFullDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WatchlistMemberFullDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WatchlistMemberFullDto>(null as any);
    }

    /**
     * @param watchListIds (optional) 
     * @param customerType (optional) 
     * @param genders (optional) 
     * @param name (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(watchListIds: number[] | undefined, customerType: CustomerTypes | undefined, genders: Genders[] | undefined, name: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<WatchlistMemberDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/WatchlistMembers/GetPaginatedList?";
        if (watchListIds === null)
            throw new Error("The parameter 'watchListIds' cannot be null.");
        else if (watchListIds !== undefined)
            watchListIds && watchListIds.forEach(item => { url_ += "WatchListIds=" + encodeURIComponent("" + item) + "&"; });
        if (customerType === null)
            throw new Error("The parameter 'customerType' cannot be null.");
        else if (customerType !== undefined)
            url_ += "CustomerType=" + encodeURIComponent("" + customerType) + "&";
        if (genders === null)
            throw new Error("The parameter 'genders' cannot be null.");
        else if (genders !== undefined)
            genders && genders.forEach(item => { url_ += "Genders=" + encodeURIComponent("" + item) + "&"; });
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<WatchlistMemberDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WatchlistMemberDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WatchlistMemberDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, body: AddWatchlistMemberDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/WatchlistMembers/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateWatchlistMemberDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/WatchlistMembers/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/WatchlistMembers/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/WatchlistMembers/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class WatchlistsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<WatchlistDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<WatchlistDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WatchlistDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WatchlistDto[]>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookups(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<WatchlistSimpleDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/GetLookups?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookups(_response);
        });
    }

    protected processGetLookups(response: AxiosResponse): Promise<WatchlistSimpleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WatchlistSimpleDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WatchlistSimpleDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getMappedFieldsList(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<MappedFields[]> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/GetMappedFieldsList?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMappedFieldsList(_response);
        });
    }

    protected processGetMappedFieldsList(response: AxiosResponse): Promise<MappedFields[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<MappedFields[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MappedFields[]>(null as any);
    }

    /**
     * @param watchlistId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLogs(watchlistId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<WatchlistLogDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/GetLogs?";
        if (watchlistId === null)
            throw new Error("The parameter 'watchlistId' cannot be null.");
        else if (watchlistId !== undefined)
            url_ += "WatchlistId=" + encodeURIComponent("" + watchlistId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLogs(_response);
        });
    }

    protected processGetLogs(response: AxiosResponse): Promise<WatchlistLogDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WatchlistLogDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WatchlistLogDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateMappedFields(branchIdHeader: string | undefined, body: UpdateMappedFields | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/UpdateMappedFields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMappedFields(_response);
        });
    }

    protected processUpdateMappedFields(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getForUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<WatchlistFullDto> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/GetForUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetForUpdate(_response);
        });
    }

    protected processGetForUpdate(response: AxiosResponse): Promise<WatchlistFullDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WatchlistFullDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WatchlistFullDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, body: AddWatchlistDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateWatchlistDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param id (optional) 
     * @param headerLineNumber (optional) 
     * @param ignoreStrings (optional) 
     * @param dataFile (optional) 
     * @return Success
     */
    sync(branchIdHeader: string | undefined, id: number | undefined, headerLineNumber: number | undefined, ignoreStrings: string[] | undefined, dataFile: FileParameter | undefined, signal?: AbortSignal): Promise<WatchListMemberImportResultDto> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/Sync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (headerLineNumber === null || headerLineNumber === undefined)
            throw new Error("The parameter 'headerLineNumber' cannot be null.");
        else
            content_.append("HeaderLineNumber", headerLineNumber.toString());
        if (ignoreStrings === null || ignoreStrings === undefined)
            throw new Error("The parameter 'ignoreStrings' cannot be null.");
        else
            ignoreStrings.forEach(item_ => content_.append("IgnoreStrings", item_.toString()));
        if (dataFile === null || dataFile === undefined)
            throw new Error("The parameter 'dataFile' cannot be null.");
        else
            content_.append("DataFile", dataFile.data, dataFile.fileName ? dataFile.fileName : "DataFile");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSync(_response);
        });
    }

    protected processSync(response: AxiosResponse): Promise<WatchListMemberImportResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WatchListMemberImportResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WatchListMemberImportResultDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getIsSyncingNowWatchlists(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<WatchlistDto[]> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/GetIsSyncingNowWatchlists";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIsSyncingNowWatchlists(_response);
        });
    }

    protected processGetIsSyncingNowWatchlists(response: AxiosResponse): Promise<WatchlistDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<WatchlistDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WatchlistDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    search(branchIdHeader: string | undefined, body: SearchFilter | undefined, signal?: AbortSignal): Promise<SearchResult> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<SearchResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SearchResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SearchResult>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getProfile(id: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<MemberProfile> {
        let url_ = this.baseUrl + "/api/Compliance/Watchlists/GetProfile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfile(_response);
        });
    }

    protected processGetProfile(response: AxiosResponse): Promise<MemberProfile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<MemberProfile>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberProfile>(null as any);
    }
}

export interface AMLRiskResult {
    riskLevel?: RiskLevelSimpleDto;
    score?: number;
    weight?: number;
    readonly result?: number;
    amlRiskId?: number;
    name?: string | null;
    categoryId?: number;
    factorId?: number;
    factor?: string | null;
    factorCode?: string | null;
    value?: string | null;
    formula?: string | null;
    actualFormula?: string | null;
    isOverriding?: boolean;
    isMaxRiskLevel?: boolean;
}

export enum AccuracyRatios {
    Custom = "Custom",
    Broad = "Broad",
    Near = "Near",
    Precise = "Precise",
}

export enum ActionPolicies {
    Block = "Block",
    Alert = "Alert",
}

export interface ActiveCase {
    id?: number;
    title?: string | null;
    description?: string | null;
    type?: CaseType;
    product?: Products;
    referenceNo?: string | null;
    caseStatus?: CaseStatusDto;
    reason?: CaseReasonDto;
    customer?: CaseCustomerDto;
    customerId?: number | null;
    customerName?: string | null;
    ruleLogId?: number | null;
    assignedToId?: number | null;
    created?: string;
    createdBy?: string | null;
    number?: string | null;
    assignedTo?: string | null;
    branch?: string | null;
    conversationsCount?: number;
}

export interface ActiveCaseIPaginatedList {
    readonly items?: ActiveCase[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum ActivityLogAction {
    AMLCheck = "AMLCheck",
    AMLRecheck = "AMLRecheck",
    Block = "Block",
    Release = "Release",
    Escalate = "Escalate",
    Returned = "Returned",
    Comment = "Comment",
    Reassign = "Reassign",
    Case = "Case",
    Create = "Create",
    Edit = "Edit",
    Cancel = "Cancel",
    Refund = "Refund",
    Approve = "Approve",
    Reject = "Reject",
    Cash = "Cash",
}

export interface ActivityLogDto {
    actionDate?: string;
    actionName?: string | null;
    actionBy?: string | null;
    actionById?: number | null;
    assignedTo?: string | null;
    remarks?: string | null;
    status?: string | null;
    transactionType?: string | null;
    referenceNumber?: string | null;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
    attachments?: AttachmentDto[] | null;
}

export interface AddAmlRiskDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    riskCategoryId: number;
    riskFactorId: number;
    weight?: number;
    isOverriding?: boolean;
    riskScores: SetRiskScoreDto[];
}

export interface AddAmlRuleDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
    product?: Products;
    actionPolicy?: ActionPolicies;
    reviewPolicy?: ReviewPolicies;
    priority?: Priority;
    alertEvery?: number | null;
}

export interface AddCaseReasonDto {
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: CaseType;
    active?: boolean;
}

export interface AddCaseStatusDto {
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: CaseType;
    active?: boolean;
}

export interface AddComplianceVariableDto {
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    dataType?: DataTypes;
    value?: string | null;
    code?: string | null;
}

export interface AddOrUpdateBlacklistCountryDto {
    product?: Products;
    countryId?: number;
    blacklistFor: BlacklistFor[];
    oldProduct?: Products;
    oldCountryId?: number | null;
}

export interface AddOrUpdateBlacklistCurrencyDto {
    product?: Products;
    currencyId?: number;
    blacklistFor: BlacklistFor[];
    oldProduct?: Products;
    oldCurrencyId?: number | null;
}

export interface AddRiskCategoryDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    product?: Products;
    weight?: number;
}

export interface AddRiskFactorDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    product?: Products;
    dataType?: DataTypes;
    values?: string[] | null;
    code: string;
    mappingProperty?: string | null;
    isCalculated?: boolean;
    isMultiple?: boolean;
}

export interface AddSanctionScreeningLogDetailDto {
    riskFactorId?: number;
    value?: string | null;
    screended?: boolean;
}

export interface AddSanctionScreeningLogDto {
    riskFactorCode?: string | null;
    riskFactorName?: string | null;
    riskFactorId?: number;
    matching?: number;
    screenedName?: string | null;
    records?: string | null;
    excepted?: boolean;
    screeningWhitelistId?: number | null;
    sanctionScreeningLogDetails?: AddSanctionScreeningLogDetailDto[] | null;
}

export interface AddScreeningWhitelistDto {
    riskFactorId?: number | null;
    referenceSanctionScreeningLogId?: number;
    expiryDate?: string;
    includedScreeningWhitelistFactors?: number[] | null;
}

export interface AddWatchlistDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    syncSource?: SyncSources;
    sourceType?: WatchlistFileTypes;
    syncFrequency?: number | null;
    url?: string | null;
    deltaScreening?: boolean;
    includeType?: WatchlistIncludeType;
}

export interface AddWatchlistMemberDto {
    watchlistId: number;
    fullName: string;
    fullNameLang?: string | null;
    type?: CustomerTypes;
    sourceReference?: string | null;
    nationalityId?: number | null;
    address?: string | null;
    countryId?: number | null;
    identityTypeId?: number | null;
    identityNumber?: string | null;
    issuePlaceId?: number | null;
    gender?: Genders;
    dateOfBirth?: string | null;
    mobileNumber?: string | null;
    remarks?: string | null;
    blockedFrom?: string | null;
    blockedTo?: string | null;
}

export interface AmlRiskDto {
    id?: number;
    name?: string | null;
    riskCategory?: RiskCategoryDto;
    riskCategoryId?: number;
    riskFactor?: RiskFactorDto;
    riskFactorId?: number;
    weight?: number;
    isOverriding?: boolean;
    active?: boolean;
    riskScores?: RiskScoreDto[] | null;
}

export interface AmlRiskListDto {
    id?: number;
    name?: string | null;
    riskFactor?: RiskFactorSimpleDto;
    weight?: number;
    isOverriding?: boolean;
    active?: boolean;
}

export interface AmlRiskSimpleDto {
    id?: number;
    name?: string | null;
}

export interface AmlRuleDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    product?: Products;
    condition?: string | null;
    actionPolicy?: ActionPolicies;
    reviewPolicy?: ReviewPolicies;
    priority?: Priority;
    alertEvery?: number | null;
    active?: boolean;
    hasLogs?: boolean;
    isSystemControlled?: boolean;
}

export interface AmlRuleDtoIPaginatedList {
    readonly items?: AmlRuleDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface AmlRuleLookupDto {
    id?: number;
    code?: string | null;
    product?: Products;
}

export interface AmlViolated {
    violatedCustomers?: number;
    violatedTransactions?: number;
    date?: string;
}

export interface AttachmentDto {
    id?: number;
    files?: FileDto[] | null;
}

export interface BlacklistBankAccountDto {
    id?: number;
    product?: Products;
    bankCode?: string | null;
    bankName?: string | null;
    branchCode?: string | null;
    branchName?: string | null;
    accountNumber?: string | null;
    blacklistFor?: BlacklistFor;
}

export interface BlacklistBankAccountForUpdateDto {
    id?: number;
    product?: Products;
    bankCode?: string | null;
    bankName?: string | null;
    branchCode?: string | null;
    branchName?: string | null;
    accountNumber?: string | null;
    blacklistFor?: BlacklistFor;
}

export interface BlacklistBankAccountListDto {
    id?: number;
    product?: Products;
    bankCode?: string | null;
    bankName?: string | null;
    branchCode?: string | null;
    branchName?: string | null;
    accountNumber?: string | null;
    blacklistFor?: BlacklistFor;
}

export interface BlacklistBankAccountListDtoIPaginatedList {
    readonly items?: BlacklistBankAccountListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum BlacklistFor {
    CustomerNationality = "CustomerNationality",
    IdentityIssuePlace = "IdentityIssuePlace",
    AddressCountry = "AddressCountry",
    PartnerNationality = "PartnerNationality",
    DelegateNationality = "DelegateNationality",
    CounterpartyNationality = "CounterpartyNationality",
    SourceCountry = "SourceCountry",
    DestinationCountry = "DestinationCountry",
    ExchangeCurrency = "ExchangeCurrency",
    ReceiveCurrency = "ReceiveCurrency",
    ReceiverBank = "ReceiverBank",
    SendCurrency = "SendCurrency",
}

export enum BlacklistSourceType {
    Country = "Country",
    Currency = "Currency",
    Bank = "Bank",
}

export interface BlacklistTypeDto {
    id?: number;
    product?: Products;
    type?: BlacklistSourceType;
    blacklistFor?: BlacklistFor;
}

export interface BlacklistTypeListDto {
    id?: number;
    product?: Products;
    type?: BlacklistSourceType;
    blacklistFor?: BlacklistFor;
}

export interface BlacklistTypeListDtoIPaginatedList {
    readonly items?: BlacklistTypeListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum BlockBehaviors {
    BlockedForRefund = "BlockedForRefund",
    BlockedForReserve = "BlockedForReserve",
}

export interface CalculationResult {
    riskCalculation?: RiskCalculationResult;
    violations?: RuleEvaluationResult[] | null;
}

export interface CaseConversationDto {
    id?: number;
    created?: string;
    createdBy?: string | null;
    caseId?: number;
    message?: string | null;
    caseStatus?: CaseStatusDto;
    caseStatusId?: number;
    messageById?: number;
    messageBy?: string | null;
    assignedToId?: number | null;
    assignedTo?: string | null;
    attachment?: FileDto;
    attachmentId?: number | null;
}

export interface CaseCustomerDto {
    id?: number;
    name?: string | null;
    gender?: Genders;
    birthDate?: string;
    address?: string | null;
    identityNo?: string | null;
    identityExpiryDate?: string;
    phone?: string | null;
    identityTypeId?: number;
    issuePlace?: CountryDto;
    issuePlaceId?: number;
    nationality?: CountryDto;
    nationalityId?: number;
    professionId?: number;
}

export interface CaseDto {
    id?: number;
    title?: string | null;
    description?: string | null;
    type?: CaseType;
    product?: Products;
    referenceNo?: string | null;
    caseStatus?: CaseStatusDto;
    reason?: CaseReasonDto;
    customer?: CaseCustomerDto;
    entityId?: number | null;
    customerName?: string | null;
    ruleLog?: RuleMonitorByIdDto;
    ruleLogId?: number | null;
    assignedToId?: number | null;
    created?: string;
    createdBy?: string | null;
    number?: string | null;
    assignedTo?: string | null;
    branch?: string | null;
    branchId?: number | null;
    attachment?: AttachmentDto;
    conversations?: CaseConversationDto[] | null;
}

export interface CaseListDto {
    id?: number;
    title?: string | null;
    description?: string | null;
    type?: CaseType;
    product?: Products;
    referenceNo?: string | null;
    caseStatus?: CaseStatusDto;
    reason?: CaseReasonDto;
    customer?: CaseCustomerDto;
    customerName?: string | null;
    entityId?: number | null;
    ruleLogId?: number | null;
    assignedToId?: number | null;
    created?: string;
    createdBy?: string | null;
    number?: string | null;
    assignedTo?: string | null;
    branch?: string | null;
}

export interface CaseListDtoIPaginatedList {
    readonly items?: CaseListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface CaseReasonDto {
    id?: number;
    name?: string | null;
    type?: CaseType;
    active?: boolean;
}

export interface CaseReasonToUpdateDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    type?: CaseType;
    active?: boolean;
}

export interface CaseStatusDto {
    id?: number;
    name?: string | null;
    type?: CaseType;
    active?: boolean;
    isSystemControlled?: boolean;
}

export interface CaseStatusToUpdateDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    active?: boolean;
    type?: CaseType;
    isSystemControlled?: boolean;
}

export enum CaseType {
    Case = "Case",
    SAR = "SAR",
    STR = "STR",
}

export interface ChangeStatusModel {
    ids: number[];
    active: boolean;
    reason?: string | null;
}

export enum CloseOptions {
    CloseAll = "CloseAll",
    CloseBlockedRulesOnly = "CloseBlockedRulesOnly",
    CloseAlertRulesOnly = "CloseAlertRulesOnly",
    LeaveAll = "LeaveAll",
}

export interface ComplianceActionDto {
    id?: number;
    actionDate?: string;
    action?: ComplianceActions;
    actionBy?: SimpleApplicationUserDto;
    remarks?: string | null;
    attachment?: AttachmentDto;
}

export enum ComplianceActions {
    Block = "Block",
    Release = "Release",
    Escalate = "Escalate",
    Returned = "Returned",
    Comment = "Comment",
    Reassign = "Reassign",
}

export enum ComplianceActionsNeededUser {
    Escalate = "Escalate",
    Returned = "Returned",
    Reassign = "Reassign",
}

export enum ComplianceCheckTypes {
    Check = "Check",
    Recheck = "Recheck",
    RiskCalculation = "RiskCalculation",
    OnBoard = "OnBoard",
}

export interface ComplianceLogDto {
    id?: number;
    number?: string | null;
    logDate?: string;
    pendingStatus?: ComplianceLogPendingStatuses;
    referenceNumber?: string | null;
    recheckedReferenceNo?: string | null;
    branch?: SimpleBranchDto;
    product?: Products;
    complianceCheckType?: ComplianceCheckTypes;
    customerName?: string | null;
    customerType?: CustomerTypes;
    riskScore?: number;
    violationsCount?: number;
    assignedTo?: LookupApplicationUserDto;
    status?: ComplianceLogStatuses;
    violatedBlockRulesCount?: number;
    violatedAlertRulesCount?: number;
    ruleLogs?: RuleMonitorDto[] | null;
    riskCategoryLogs?: RiskCategoryLogDto[] | null;
    complianceActions?: ComplianceActionDto[] | null;
}

export interface ComplianceLogHistoryDto {
    id?: number;
    number?: string | null;
    logDate?: string;
    referenceNumber?: string | null;
    recheckedReferenceNo?: string | null;
    product?: Products;
    complianceCheckType?: ComplianceCheckTypes;
    status?: ComplianceLogStatuses;
    isMain?: boolean;
    pendingStatus?: ComplianceLogPendingStatuses;
}

export interface ComplianceLogListDto {
    id?: number;
    number?: string | null;
    logDate?: string;
    referenceNumber?: string | null;
    recheckedReferenceNo?: string | null;
    branch?: SimpleBranchDto;
    product?: Products;
    pendingStatus?: ComplianceLogPendingStatuses;
    complianceCheckType?: ComplianceCheckTypes;
    customerName?: string | null;
    customerType?: CustomerTypes;
    riskScore?: number;
    riskLevel?: string | null;
    violationsCount?: number;
    violatedBlockRulesCount?: number;
    violatedAlertRulesCount?: number;
    assignedTo?: LookupApplicationUserDto;
    status?: ComplianceLogStatuses;
    relatedComplianceLog?: ComplianceLogListWithoutComplianceLogDto;
}

export interface ComplianceLogListDtoIPaginatedList {
    readonly items?: ComplianceLogListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface ComplianceLogListWithoutComplianceLogDto {
    id?: number;
    number?: string | null;
    logDate?: string;
    referenceNumber?: string | null;
    recheckedReferenceNo?: string | null;
    branch?: SimpleBranchDto;
    product?: Products;
    complianceCheckType?: ComplianceCheckTypes;
    customerName?: string | null;
    customerType?: CustomerTypes;
    riskScore?: number;
    violationsCount?: number;
    assignedTo?: LookupApplicationUserDto;
    status?: ComplianceLogStatuses;
}

export enum ComplianceLogPendingStatuses {
    PendingForCancel = "PendingForCancel",
    Canceled = "Canceled",
    Rechecked = "Rechecked",
}

export enum ComplianceLogStatuses {
    Passed = "Passed",
    Violated = "Violated",
    Released = "Released",
    Blocked = "Blocked",
    Escalated = "Escalated",
    Returned = "Returned",
}

export interface ComplianceVariableDto {
    id?: number;
    name?: string | null;
    dataType?: DataTypes;
    value?: string | null;
    active?: boolean;
    code?: string | null;
}

export interface ComplianceVariableDtoIPaginatedList {
    readonly items?: ComplianceVariableDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface CountryDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    iso3Code?: string | null;
    countryCode?: string | null;
    active?: boolean;
    aliases?: string[] | null;
    currencyId?: number;
}

export interface CurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
    isBase?: boolean;
}

export interface CustomerProfileScreeningReportModel {
    date?: string;
    customerNumber?: string | null;
    alertNumber?: string | null;
    customerName?: string | null;
    screeningResult?: number;
    status?: RuleLogStatuses;
    action?: RuleActions;
    actionDate?: string | null;
    actionBy?: string | null;
    remarks?: string | null;
}

export interface CustomerProfileScreeningReportModelIPaginatedList {
    readonly items?: CustomerProfileScreeningReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface CustomerRegistrationReportModel {
    id?: number;
    number?: string | null;
    created?: string;
    name?: string | null;
    type?: CustomerTypes;
    status?: CustomerStatuses;
    nationality?: CountryDto;
    branch?: UpdateBranchDto;
    birthDate?: string;
    birthPlace?: CountryDto;
    identity?: string | null;
    residencyType?: string | null;
    address?: string | null;
    phone?: string | null;
    profession?: string | null;
    riskScore?: number;
    riskLevel?: RiskLevelSimpleDto;
}

export interface CustomerRegistrationReportModelIPaginatedList {
    readonly items?: CustomerRegistrationReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum CustomerStatuses {
    PendingForCompliance = "PendingForCompliance",
    Active = "Active",
    Blocked = "Blocked",
    Disabled = "Disabled",
    PendingForEdit = "PendingForEdit",
}

export enum CustomerTypes {
    Person = "Person",
    Corporate = "Corporate",
}

export interface DashboardStatistics {
    pendingCustomerViolations?: number;
    pendingTransactionsViolations?: number;
    readonly pendingViolations?: number;
    amlRules?: number;
    amlRiskScore?: number;
    watchlists?: number;
    watchlistMembers?: number;
}

export enum DataTypes {
    Text = "Text",
    TextArea = "TextArea",
    SecureText = "SecureText",
    Number = "Number",
    Decimal = "Decimal",
    Percentage = "Percentage",
    DateOnly = "DateOnly",
    TimeOnly = "TimeOnly",
    DateTime = "DateTime",
    ScreeningResult = "ScreeningResult",
    Boolean = "Boolean",
    CustomLookup = "CustomLookup",
    Country = "Country",
    CustomerType = "CustomerType",
    CustomerSubType = "CustomerSubType",
    Purpose = "Purpose",
    Currency = "Currency",
    Activity = "Activity",
    Nationality = "Nationality",
    IdentityType = "IdentityType",
    SourceOfFund = "SourceOfFund",
    DeliveryMethod = "DeliveryMethod",
    Relation = "Relation",
    AddressType = "AddressType",
    DelegationType = "DelegationType",
    Gender = "Gender",
    Industry = "Industry",
    LiabilityType = "LiabilityType",
    OwnershipType = "OwnershipType",
    PartnershipType = "PartnershipType",
    Profession = "Profession",
    ResidencyType = "ResidencyType",
    Product = "Product",
    CustomerStatus = "CustomerStatus",
    Channel = "Channel",
    PaymentMode = "PaymentMode",
    Account = "Account",
    AggregateAccount = "AggregateAccount",
    JournalAccount = "JournalAccount",
    DeltaScreening = "DeltaScreening",
}

export interface DeleteBlacklistCountryDto {
    product?: Products;
    countryId?: number;
}

export interface DeleteBlacklistCurrencyDto {
    product?: Products;
    currencyId?: number;
}

export interface FileDto {
    id?: number;
    name?: string | null;
    extension?: string | null;
    link?: string | null;
    created?: string;
}

export interface FullAmlRiskDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    riskCategoryId?: number;
    riskFactorId?: number;
    weight?: number;
    isOverriding?: boolean;
    riskScores?: RiskScoreDto[] | null;
    active?: boolean;
}

export interface FullAmlRuleDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code?: string | null;
    actionPolicy?: ActionPolicies;
    reviewPolicy?: ReviewPolicies;
    priority?: Priority;
    alertEvery?: number | null;
    product?: Products;
    active?: boolean;
    hasLogs?: boolean;
    condition?: string | null;
    isSystemControlled?: boolean;
}

export interface FullComplianceVariableDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    dataType?: DataTypes;
    value?: string | null;
    active?: boolean;
    code?: string | null;
}

export interface FullRiskCategoryDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    product?: Products;
    weight?: number;
    active?: boolean;
}

export interface FullRiskLevelDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    fromScore?: number;
    toScore?: number;
    order?: number;
}

export enum Genders {
    Male = "Male",
    Female = "Female",
}

export interface GroupedBlacklistCountryDto {
    product?: Products;
    countryId?: number;
    country?: CountryDto;
    blacklistFor?: BlacklistFor[] | null;
}

export interface GroupedBlacklistCountryListDto {
    product?: Products;
    countryId?: number;
    country?: CountryDto;
    blacklistFor?: BlacklistFor[] | null;
}

export interface GroupedBlacklistCountryListDtoIPaginatedList {
    readonly items?: GroupedBlacklistCountryListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface GroupedBlacklistCurrencyDto {
    product?: Products;
    currencyId?: number;
    currency?: CurrencyDto;
    blacklistFor?: BlacklistFor[] | null;
}

export interface GroupedBlacklistCurrencyListDto {
    product?: Products;
    currencyId?: number;
    currency?: CurrencyDto;
    blacklistFor?: BlacklistFor[] | null;
}

export interface GroupedBlacklistCurrencyListDtoIPaginatedList {
    readonly items?: GroupedBlacklistCurrencyListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface Identity {
    number?: string | null;
    type?: IdentityTypes;
}

export enum IdentityTypes {
    NationalID = "NationalID",
    PassportNo = "PassportNo",
    DrivingLicenseNo = "DrivingLicenseNo",
    TradeLicense = "TradeLicense",
    TaxCard = "TaxCard",
    BankIdentifierCode = "BankIdentifierCode",
    CompanyIdentificationNo = "CompanyIdentificationNo",
    NationalTaxNo = "NationalTaxNo",
}

export interface LookupApplicationUserDto {
    id?: number;
    email?: string | null;
    fullName?: string | null;
    mobile?: string | null;
}

export interface MappedFields {
    sourceName?: string | null;
    sourceFormat?: string | null;
    mappedField?: string | null;
    title?: string | null;
    mappedType?: DataTypes;
}

export interface MemberProfile {
    fullName?: string | null;
    aliases?: string[] | null;
    sanctionsList?: string[] | null;
    originalScriptNames?: string[] | null;
    type?: CustomerTypes;
    gender?: Genders;
    datesOfBirth?: string[] | null;
    categories?: WatchlistCategory[] | null;
    resultFrom?: SearchType;
    nationality?: string | null;
    watchlistName?: string | null;
    residence?: string | null;
    isDeceased?: boolean | null;
    notes?: string | null;
    images?: string[] | null;
    isLowerThreshold?: boolean;
    relationships?: Relationship[] | null;
    values?: string | null;
}

export interface Name {
    fullName?: string | null;
    accuracyRatio?: AccuracyRatios;
    accuracyPercent?: number | null;
}

export interface NewBlacklistBankAccountDto {
    product?: Products;
    bankCode?: string | null;
    bankName?: string | null;
    branchCode?: string | null;
    branchName?: string | null;
    accountNumber?: string | null;
    blacklistFor?: BlacklistFor;
}

export interface ParameterDetailsModel {
    name?: string | null;
    type?: string | null;
    value?: string | null;
    dataType?: DataTypes;
    isRiskLevel?: boolean;
}

export enum Priority {
    Low = "Low",
    Medium = "Medium",
    High = "High",
    MediumHigh = "MediumHigh",
}

export enum Products {
    CustomerProfile = "CustomerProfile",
    CurrencyExchange = "CurrencyExchange",
    ReceiveRemittance = "ReceiveRemittance",
    SendRemittance = "SendRemittance",
}

export enum ProviderTypes {
    Online = "Online",
    Offline = "Offline",
    Manual = "Manual",
}

export interface Relationship {
    fullName?: string | null;
    type?: string | null;
    connectionType?: string | null;
}

export enum ReviewPolicies {
    OfficerOnly = "OfficerOnly",
    OfficerAndManager = "OfficerAndManager",
}

export interface RiskCalculationResult {
    riskLevel?: RiskLevelSimpleDto;
    score?: number;
    weight?: number;
    readonly result?: number;
    categoriesResult?: RiskCategoryResult[] | null;
}

export interface RiskCategoryDto {
    id?: number;
    name?: string | null;
    product?: Products;
    weight?: number;
    active?: boolean;
    amlRisks?: AmlRiskListDto[] | null;
}

export interface RiskCategoryLogDto {
    categoryName?: string | null;
    categoryId?: number;
    score?: number;
    weight?: number;
    weightedScore?: number;
    product?: Products;
    riskLogs?: RiskLogDto[] | null;
}

export interface RiskCategoryResult {
    riskLevel?: RiskLevelSimpleDto;
    score?: number;
    weight?: number;
    readonly result?: number;
    categoryId?: number;
    category?: string | null;
    riskResult?: AMLRiskResult[] | null;
}

export interface RiskCategorySimpleDto {
    id?: number;
    name?: string | null;
}

export interface RiskFactorDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    product?: Products;
    dataType?: DataTypes;
    code?: string | null;
    active?: boolean;
    mappingProperty?: string | null;
    supportRiskLevel?: boolean;
    isSystemControlled?: boolean;
    isMultiple?: boolean;
    isCalculated?: boolean;
    values?: string[] | null;
}

export interface RiskFactorDtoIPaginatedList {
    readonly items?: RiskFactorDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface RiskFactorFullDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    mappingProperty?: string | null;
    isCalculated?: boolean;
    isMultiple?: boolean;
    active?: boolean;
    isSystemControlled?: boolean;
    values?: string[] | null;
    product?: Products;
    dataType?: DataTypes;
    code?: string | null;
}

export interface RiskFactorSimpleDto {
    id?: number;
    name?: string | null;
    dataType?: DataTypes;
    values?: string[] | null;
}

export interface RiskLevelDto {
    id?: number;
    name?: string | null;
    fromScore?: number;
    toScore?: number;
}

export interface RiskLevelProductDto {
    riskLevelId: number;
    fromScore?: number;
    toScore?: number;
}

export interface RiskLevelSimpleDto {
    id?: number;
    name?: string | null;
}

export interface RiskLogDto {
    amlRiskName?: string | null;
    amlRiskId?: number;
    factorValue?: string | null;
    scoreFormula?: string | null;
    actualFormula?: string | null;
    dataType?: DataTypes;
    score?: number;
    weight?: number;
    weightedScore?: number;
}

export interface RiskScoreDto {
    id?: number;
    name?: string | null;
    valueId?: number | null;
    formula?: string | null;
    riskLevel?: RiskLevelSimpleDto;
    riskLevelId?: number;
    value?: any | null;
}

export interface RiskScoreStatistic {
    currentRiskScore?: number;
    riskScoreStatisticRecords?: RiskScoreStatisticRecord[] | null;
}

export interface RiskScoreStatisticRecord {
    riskLevel?: RiskLevelSimpleDto;
    count?: number;
}

export interface RuleActionDto {
    action?: RuleActions;
    actionDate?: string;
    actionBy?: SimpleApplicationUserDto;
    assignedTo?: SimpleApplicationUserDto;
    remarks?: string | null;
    attachment?: AttachmentDto;
}

export enum RuleActions {
    Block = "Block",
    Release = "Release",
    Escalate = "Escalate",
    Returned = "Returned",
    Comment = "Comment",
    Revoke = "Revoke",
    Reassign = "Reassign",
    Close = "Close",
}

export interface RuleEvaluationResult {
    ruleId?: number;
    name?: string | null;
    status?: RuleLogStatuses;
    condition?: string | null;
    actualCondition?: string | null;
    policy?: ActionPolicies;
    parameterDetails?: string[] | null;
    sanctionScreeningLogs?: AddSanctionScreeningLogDto[] | null;
}

export enum RuleLogStatuses {
    Passed = "Passed",
    Violated = "Violated",
    Released = "Released",
    Blocked = "Blocked",
    Escalated = "Escalated",
    Returned = "Returned",
    Closed = "Closed",
}

export interface RuleMonitorByIdDto {
    id?: number;
    logDate?: string;
    pendingStatus?: ComplianceLogPendingStatuses;
    number?: string | null;
    ruleId?: number;
    ruleName?: string | null;
    condition?: string | null;
    actualCondition?: string | null;
    code?: string | null;
    referenceNumber?: string | null;
    actionPolicy?: ActionPolicies;
    reviewPolicy?: ReviewPolicies;
    product?: Products;
    priority?: Priority;
    assignedTo?: SimpleApplicationUserDto;
    status?: RuleLogStatuses;
    lastAction?: RuleActionDto;
    created?: SimpleApplicationUserDto;
    parametersDetails?: ParameterDetailsModel[] | null;
}

export interface RuleMonitorDto {
    id?: number;
    complianceLogId?: number;
    pendingStatus?: ComplianceLogPendingStatuses;
    priority?: Priority;
    logDate?: string;
    number?: string | null;
    ruleId?: number;
    ruleName?: string | null;
    condition?: string | null;
    actualCondition?: string | null;
    code?: string | null;
    actionPolicy?: ActionPolicies;
    reviewPolicy?: ReviewPolicies;
    product?: Products;
    referenceNumber?: string | null;
    complianceCheckType?: ComplianceCheckTypes;
    isScreeningRule?: boolean;
    customerName?: string | null;
    customerType?: CustomerTypes;
    customerReferenceNumber?: string | null;
    branch?: SimpleBranchDto;
    assignedTo?: SimpleApplicationUserDto;
    created?: SimpleApplicationUserDto;
    status?: RuleLogStatuses;
    lastAction?: RuleActionDto;
    ruleActions?: RuleActionDto[] | null;
    sanctionScreeningLogs?: SanctionScreeningLogDto[] | null;
    parametersDetails?: ParameterDetailsModel[] | null;
    violatedBlockRulesCount?: number;
    violatedAlertRulesCount?: number;
    checkType?: string | null;
    isLastViolationRule?: boolean;
    showReleaseAction?: boolean;
}

export interface RuleMonitorDtoIPaginatedList {
    readonly items?: RuleMonitorDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum SahabProviderAlgorithm {
    Difference = "Difference",
    Levenshtein = "Levenshtein",
}

export interface SanctionScreeningLogDetailDto {
    riskFactor?: RiskFactorSimpleDto;
    value?: string | null;
    screended?: boolean;
}

export interface SanctionScreeningLogDto {
    id?: number;
    riskFactor?: RiskFactorSimpleDto;
    screenedName?: string | null;
    matchingPercent?: number;
    excepted?: boolean;
    screeningWhitelistId?: number | null;
    referenceLogNumber?: string | null;
    searchResult?: SearchResultItem[] | null;
    sanctionScreeningLogDetails?: SanctionScreeningLogDetailDto[] | null;
}

export interface ScreeningWhitelistDto {
    id?: number;
    whitelistedName?: string | null;
    riskFactor?: RiskFactorSimpleDto;
    expiryDate?: string;
    expired?: boolean;
    referenceLog?: string | null;
    active?: boolean;
    lastModifiedByUser?: string | null;
    lastModified?: string | null;
    screeningWhitelistFactors?: ScreeningWhitelistFactorDto[] | null;
}

export interface ScreeningWhitelistDtoIPaginatedList {
    readonly items?: ScreeningWhitelistDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface ScreeningWhitelistFactorDto {
    riskFactor?: RiskFactorSimpleDto;
    value?: string | null;
}

export interface SearchFilter {
    pageNumber?: number;
    pageSize?: number;
    name: Name;
    dateOfBirth?: string | null;
    identity?: Identity;
    countriesIds?: number[] | null;
    watchlistIds?: number[] | null;
    customerType?: CustomerTypes;
    searchType?: SearchType;
    exculededAlgorithms?: SahabProviderAlgorithm[] | null;
    ignoreOptionalWatchLists?: boolean;
    searchScope?: string | null;
}

export interface SearchResult {
    onlineTotalCount?: number;
    offlineTotalCount?: number;
    data?: SearchResultItemIPaginatedList;
    readonly hasErrors?: boolean;
    errors?: string[] | null;
}

export interface SearchResultItem {
    id?: string | null;
    name?: string | null;
    nameLang?: string | null;
    type?: CustomerTypes;
    gender?: Genders;
    nationality?: CountryDto;
    residentCountry?: CountryDto;
    datesOfBirth?: string[] | null;
    matching?: number;
    notes?: string | null;
    sanctionListName?: string | null;
    categories?: WatchlistCategory[] | null;
    resultFrom?: SearchType;
}

export interface SearchResultItemIPaginatedList {
    readonly items?: SearchResultItem[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum SearchType {
    Online = "Online",
    Offline = "Offline",
}

export interface SetConditionDto {
    id: number;
    condition: string;
}

export interface SetRiskLevelDto {
    id?: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    fromScore?: number;
    toScore?: number;
    order: number;
}

export interface SetRiskLevelModel {
    riskLevels?: SetRiskLevelDto[] | null;
}

export interface SetRiskLevelProductDto {
    product?: Products;
    riskLevelProducts?: RiskLevelProductDto[] | null;
}

export interface SetRiskScoreDto {
    valueId: number;
    formula?: string | null;
    riskLevelId: number;
}

export enum SettlementTypes {
    Stock = "Stock",
    Deposit = "Deposit",
}

export interface SimpleApplicationUserDto {
    id?: number;
    email?: string | null;
    fullName?: string | null;
    branches?: SimpleBranchDto[] | null;
    mobile?: string | null;
}

export interface SimpleBranchDto {
    id?: number;
    name?: string | null;
    code?: string | null;
}

export interface SimpleCurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
}

export interface SimpleProviderLookupDto {
    id?: number;
    name?: string | null;
    integrationType?: ProviderTypes;
    settlementType?: SettlementTypes;
    supportedTransaction?: SupportedTransactions;
}

export interface SimpleWatchlistLogDto {
    syncDate?: string;
    syncSucceeded?: boolean;
    addedRows?: number;
    updatedRows?: number;
    deletedRows?: number;
    totalRows?: number;
}

export interface SourceProduct {
    product?: Products;
    referenceNumber?: string | null;
    referenceObject?: string | null;
    values?: { [key: string]: string; } | null;
    customerId?: number;
    customerName?: string | null;
    customerType?: CustomerTypes;
    customerReferenceNumber?: string | null;
    branchId?: number;
    relatedComplianceLogId?: number | null;
    recheckReference?: string | null;
}

export enum SupportedTransactions {
    Send = "Send",
    Receive = "Receive",
    Both = "Both",
}

export enum SyncSources {
    Manual = "Manual",
    URL = "URL",
    File = "File",
}

export interface TMSFCExchangeTransactionReportModel {
    date?: string;
    rule?: string | null;
    condition?: string | null;
    transactionNumber?: string | null;
    alertNumber?: string | null;
    branch?: SimpleBranchDto;
    customer?: string | null;
    transactionType?: TransactionTypeDto;
    currency?: SimpleCurrencyDto;
    fcAmount?: number;
    lcAmount?: number;
    policy?: ActionPolicies;
    status?: RuleLogStatuses;
    action?: RuleActions;
    actionDate?: string | null;
    actionBy?: string | null;
    remarks?: string | null;
    transactionStatus?: TransactionStatuses;
}

export interface TMSFCExchangeTransactionReportModelIPaginatedList {
    readonly items?: TMSFCExchangeTransactionReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface TMSReceiveTransactionReportModel {
    date?: string;
    rule?: string | null;
    condition?: string | null;
    transactionNumber?: string | null;
    alertNumber?: string | null;
    branch?: SimpleBranchDto;
    provider?: SimpleProviderLookupDto;
    country?: CountryDto;
    receiver?: string | null;
    sender?: string | null;
    payoutAmount?: number;
    currency?: SimpleCurrencyDto;
    policy?: ActionPolicies;
    status?: RuleLogStatuses;
    action?: RuleActions;
    actionDate?: string | null;
    actionBy?: string | null;
    remarks?: string | null;
    transactionStatus?: TransactionStatuses;
}

export interface TMSReceiveTransactionReportModelIPaginatedList {
    readonly items?: TMSReceiveTransactionReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface TMSSendTransactionReportModel {
    date?: string;
    rule?: string | null;
    condition?: string | null;
    transactionNumber?: string | null;
    alertNumber?: string | null;
    branch?: SimpleBranchDto;
    provider?: SimpleProviderLookupDto;
    country?: CountryDto;
    receiver?: string | null;
    sender?: string | null;
    payoutAmount?: number;
    currency?: SimpleCurrencyDto;
    policy?: ActionPolicies;
    status?: RuleLogStatuses;
    action?: RuleActions;
    actionDate?: string | null;
    actionBy?: string | null;
    remarks?: string | null;
    transactionStatus?: TransactionStatuses;
}

export interface TMSSendTransactionReportModelIPaginatedList {
    readonly items?: TMSSendTransactionReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface ThirdPartyTransactionReportModel {
    date?: string;
    number?: string | null;
    branch?: SimpleBranchDto;
    transactionType?: TransactionTypeDto;
    provider?: SimpleProviderLookupDto;
    customer?: string | null;
    payinAmount?: number;
    payinCurrency?: SimpleCurrencyDto;
    payoutAmount?: number;
    payoutCurrency?: SimpleCurrencyDto;
    status?: TransactionStatuses;
    user?: string | null;
}

export interface ThirdPartyTransactionReportModelIPaginatedList {
    readonly items?: ThirdPartyTransactionReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum TimePeriods {
    OneDay = "OneDay",
    OneWeek = "OneWeek",
    OneMonth = "OneMonth",
    MonthAndHalf = "MonthAndHalf",
    ThreeMonths = "ThreeMonths",
    HalfYear = "HalfYear",
    Year = "Year",
}

export interface TransactionSanctionScreeningReportModel {
    date?: string;
    transactionNumber?: string | null;
    alertNumber?: string | null;
    transactionType?: TransactionTypeDto;
    screeningFor?: string | null;
    nameScreened?: string | null;
    screeningResult?: number;
    status?: RuleLogStatuses;
    action?: RuleActions;
    actionDate?: string | null;
    actionBy?: string | null;
    remarks?: string | null;
}

export interface TransactionSanctionScreeningReportModelIPaginatedList {
    readonly items?: TransactionSanctionScreeningReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum TransactionStatuses {
    PendingForCompliance = "PendingForCompliance",
    Blocked = "Blocked",
    PendingForCash = "PendingForCash",
    Completed = "Completed",
    PendingForCancel = "PendingForCancel",
    Canceled = "Canceled",
    PendingForRefund = "PendingForRefund",
    Refunded = "Refunded",
    ReadyForDelivery = "ReadyForDelivery",
    Delivered = "Delivered",
    PendingForEdit = "PendingForEdit",
    BlockedForRefund = "BlockedForRefund",
    BlockedForReserve = "BlockedForReserve",
    PendingForApproval = "PendingForApproval",
    Rejected = "Rejected",
    PendingForSenderApproval = "PendingForSenderApproval",
    PendingForReceiverApproval = "PendingForReceiverApproval",
    PendingForSenderCash = "PendingForSenderCash",
    PendingForReceiverCash = "PendingForReceiverCash",
    ComplianceProcessing = "ComplianceProcessing",
}

export interface TransactionTypeDto {
    id?: number;
    name?: string | null;
}

export enum TransactionTypes {
    FC_Sale = "FC_Sale",
    FC_Purchase = "FC_Purchase",
    SendMoney = "SendMoney",
    ReceiveMoney = "ReceiveMoney",
    Income = "Income",
    Expenses = "Expenses",
    InternalTransfer = "InternalTransfer",
    ExternalTransfer = "ExternalTransfer",
    StockTransaction = "StockTransaction",
}

export interface UpdateAmlRiskDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    riskCategoryId: number;
    weight?: number;
    isOverriding?: boolean;
    riskScores: SetRiskScoreDto[];
}

export interface UpdateAmlRuleDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
    actionPolicy?: ActionPolicies;
    reviewPolicy?: ReviewPolicies;
    priority?: Priority;
    alertEvery?: number | null;
    product?: Products;
}

export interface UpdateAttachmentDto {
    id?: number;
    removedIds?: number[] | null;
    files?: string[] | null;
}

export interface UpdateBlacklistBankAccountDto {
    id?: number;
    product?: Products;
    bankCode?: string | null;
    bankName?: string | null;
    branchCode?: string | null;
    branchName?: string | null;
    accountNumber?: string | null;
    blacklistFor?: BlacklistFor;
}

export interface UpdateBranchDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
    countryId: number;
    cityId: number;
    managerId?: number;
    phone: string;
    address: string;
    landMark: string;
    email?: string | null;
}

export interface UpdateCaseCustomerDto {
    id?: number;
    name?: string | null;
    gender?: Genders;
    birthDate?: string;
    address?: string | null;
    identityNo?: string | null;
    identityExpiryDate?: string;
    phone?: string | null;
    identityTypeId?: number;
    issuePlaceId?: number;
    nationalityId?: number;
    professionId?: number;
}

export interface UpdateCaseDto {
    id?: number;
    title: string;
    description?: string | null;
    product?: Products;
    referenceNo?: string | null;
    caseStatusId?: number | null;
    reasonId: number;
    assignedToId?: number | null;
    attachment?: UpdateAttachmentDto;
    customer?: UpdateCaseCustomerDto;
    customerName?: string | null;
    entityId?: number | null;
    ruleLogId?: number | null;
}

export interface UpdateCaseReasonDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: CaseType;
    active?: boolean;
}

export interface UpdateCaseStatusDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: CaseType;
    active?: boolean;
}

export interface UpdateComplianceVariableDto {
    id: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    dataType?: DataTypes;
    value?: string | null;
}

export interface UpdateMappedFields {
    watchlistId?: number;
    mappingFields?: MappedFields[] | null;
}

export interface UpdateRiskCategoryDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    product?: Products;
    weight?: number;
}

export interface UpdateRiskFactorDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    mappingProperty?: string | null;
    isCalculated?: boolean;
    isMultiple?: boolean;
}

export interface UpdateScreeningWhitelistDto {
    id?: number;
    expiryDate?: string;
}

export interface UpdateWatchlistDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    syncFrequency?: number | null;
    url?: string | null;
    deltaScreening?: boolean;
    includeType?: WatchlistIncludeType;
}

export interface UpdateWatchlistMemberDto {
    id: number;
    fullName: string;
    fullNameLang?: string | null;
    type?: CustomerTypes;
    sourceReference?: string | null;
    nationalityId?: number | null;
    address?: string | null;
    countryId?: number | null;
    identityTypeId?: number | null;
    identityNumber?: string | null;
    issuePlaceId?: number | null;
    gender?: Genders;
    dateOfBirth?: string | null;
    mobileNumber?: string | null;
    remarks?: string | null;
    blockedFrom?: string | null;
    blockedTo?: string | null;
}

export interface VerifyBlacklistBankAccountDto {
    product?: Products;
    bankCode?: string | null;
    bankName?: string | null;
    branchCode?: string | null;
    branchName?: string | null;
    accountNumber?: string | null;
    blacklistFor?: BlacklistFor;
}

export interface VerifyBlacklistCountryDto {
    product?: Products;
    countryId?: number;
    blacklistFor?: BlacklistFor;
}

export interface VerifyBlacklistCurrencyDto {
    product?: Products;
    currencyId?: number;
    blacklistFor?: BlacklistFor;
}

export interface ViolatedRule {
    id?: number;
    name?: string | null;
    violatedCount?: number;
}

export interface WatchListMemberImportFailRecordDto {
    recordNumber?: number;
    reasons?: string[] | null;
}

export interface WatchListMemberImportResultDto {
    addedRecordsCount?: number;
    updatedRecordsCount?: number;
    failRecordsCount?: number;
    fileValidationErrors?: string[] | null;
    failRecords?: WatchListMemberImportFailRecordDto[] | null;
    modifiedIds?: number[] | null;
}

export interface WatchlistCategory {
    name?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    impact?: number;
}

export interface WatchlistDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    syncSource?: SyncSources;
    sourceType?: WatchlistFileTypes;
    syncFrequency?: number | null;
    url?: string | null;
    deltaScreening?: boolean;
    includeType?: WatchlistIncludeType;
    isSystemControlled?: boolean;
    active?: boolean;
    lastWatchlistLogs?: SimpleWatchlistLogDto;
}

export enum WatchlistFileTypes {
    XML = "XML",
    Excel = "Excel",
    CSV = "CSV",
    Json = "Json",
}

export interface WatchlistFullDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    syncSource?: SyncSources;
    sourceType?: WatchlistFileTypes;
    syncFrequency?: number | null;
    url?: string | null;
    deltaScreening?: boolean;
    includeType?: WatchlistIncludeType;
    active?: boolean;
    isSystemControlled?: boolean;
}

export enum WatchlistIncludeType {
    Optional = "Optional",
    Mandatory = "Mandatory",
}

export interface WatchlistLogDto {
    watchlistId?: number;
    name?: string | null;
    source?: string | null;
    sourceType?: string | null;
    syncDate?: string;
    syncSucceeded?: boolean;
    addedRows?: number;
    updatedRows?: number;
    deletedRows?: number;
    totalRows?: number;
}

export interface WatchlistLogDtoIPaginatedList {
    readonly items?: WatchlistLogDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface WatchlistMemberDto {
    id?: number;
    watchlist?: WatchlistSimpleDto;
    fullName?: string | null;
    fullNameLang?: string | null;
    type?: CustomerTypes;
    sourceReference?: string | null;
    nationality?: CountryDto;
    address?: string | null;
    country?: CountryDto;
    identityTypeId?: number | null;
    identityNumber?: string | null;
    issuePlace?: CountryDto;
    gender?: Genders;
    dateOfBirth?: string | null;
    mobileNumber?: string | null;
    remarks?: string | null;
    blockedFrom?: string | null;
    blockedTo?: string | null;
    active?: boolean;
}

export interface WatchlistMemberDtoIPaginatedList {
    readonly items?: WatchlistMemberDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface WatchlistMemberFullDto {
    id?: number;
    fullName?: string | null;
    fullNameLang?: string | null;
    type?: CustomerTypes;
    sourceReference?: string | null;
    nationalityId?: number | null;
    address?: string | null;
    countryId?: number | null;
    identityTypeId?: number | null;
    identityNumber?: string | null;
    issuePlaceId?: number | null;
    gender?: Genders;
    dateOfBirth?: string | null;
    mobileNumber?: string | null;
    remarks?: string | null;
    blockedFrom?: string | null;
    blockedTo?: string | null;
}

export interface WatchlistSimpleDto {
    id?: number;
    name?: string | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}