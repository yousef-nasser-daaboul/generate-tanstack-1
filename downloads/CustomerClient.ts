//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class CorporateActivityClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddFullCorporateActivityDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Customer/CorporateActivity/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateCorporateActivityDto | undefined, signal?: AbortSignal): Promise<UpdateCorporateActivityDto> {
        let url_ = this.baseUrl + "/api/Customer/CorporateActivity/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCorporateActivityDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCorporateActivityDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCorporateActivityDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Customer/CorporateActivity/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CorporateActivityDto> {
        let url_ = this.baseUrl + "/api/Customer/CorporateActivity/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CorporateActivityDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CorporateActivityDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CorporateActivityDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CorporateActivityDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Customer/CorporateActivity/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<CorporateActivityDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CorporateActivityDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CorporateActivityDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CorporateActivityDto[]> {
        let url_ = this.baseUrl + "/api/Customer/CorporateActivity/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CorporateActivityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CorporateActivityDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CorporateActivityDto[]>(null as any);
    }
}

export class CorporateDelegateClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param type (optional) 
     * @param customerId (optional) 
     * @param customerIdentityId (optional) 
     * @param delegationTypeId (optional) 
     * @param fullName (optional) 
     * @param nationalityId (optional) 
     * @param birthDate (optional) 
     * @param phone (optional) 
     * @param address (optional) 
     * @param expiryDate (optional) 
     * @param isPep (optional) 
     * @param addAttachment_Files (optional) 
     * @param customerIdentity_IdentityTypeId (optional) 
     * @param customerIdentity_IdentityNumber (optional) 
     * @param customerIdentity_NationalNo (optional) 
     * @param customerIdentity_IssuePlaceId (optional) 
     * @param customerIdentity_IssueDate (optional) 
     * @param customerIdentity_ExpiryDate (optional) 
     * @param customerIdentity_AddAttachment_Files (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, type: CustomerRegistrationType | undefined, customerId: number | undefined, customerIdentityId: number | undefined, delegationTypeId: number | undefined, fullName: string | undefined, nationalityId: number | undefined, birthDate: string | undefined, phone: string | undefined, address: string | undefined, expiryDate: string | undefined, isPep: boolean | undefined, addAttachment_Files: FileParameter[] | undefined, customerIdentity_IdentityTypeId: number | undefined, customerIdentity_IdentityNumber: string | undefined, customerIdentity_NationalNo: string | undefined, customerIdentity_IssuePlaceId: number | undefined, customerIdentity_IssueDate: string | undefined, customerIdentity_ExpiryDate: string | undefined, customerIdentity_AddAttachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Customer/CorporateDelegate/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (customerId === null || customerId === undefined)
            throw new Error("The parameter 'customerId' cannot be null.");
        else
            content_.append("CustomerId", customerId.toString());
        if (customerIdentityId === null || customerIdentityId === undefined)
            throw new Error("The parameter 'customerIdentityId' cannot be null.");
        else
            content_.append("CustomerIdentityId", customerIdentityId.toString());
        if (delegationTypeId === null || delegationTypeId === undefined)
            throw new Error("The parameter 'delegationTypeId' cannot be null.");
        else
            content_.append("DelegationTypeId", delegationTypeId.toString());
        if (fullName === null || fullName === undefined)
            throw new Error("The parameter 'fullName' cannot be null.");
        else
            content_.append("FullName", fullName.toString());
        if (nationalityId === null || nationalityId === undefined)
            throw new Error("The parameter 'nationalityId' cannot be null.");
        else
            content_.append("NationalityId", nationalityId.toString());
        if (birthDate === null || birthDate === undefined)
            throw new Error("The parameter 'birthDate' cannot be null.");
        else
            content_.append("BirthDate", birthDate.toString());
        if (phone === null || phone === undefined)
            throw new Error("The parameter 'phone' cannot be null.");
        else
            content_.append("Phone", phone.toString());
        if (address === null || address === undefined)
            throw new Error("The parameter 'address' cannot be null.");
        else
            content_.append("Address", address.toString());
        if (expiryDate === null || expiryDate === undefined)
            throw new Error("The parameter 'expiryDate' cannot be null.");
        else
            content_.append("ExpiryDate", expiryDate.toString());
        if (isPep === null || isPep === undefined)
            throw new Error("The parameter 'isPep' cannot be null.");
        else
            content_.append("IsPep", isPep.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );
        if (customerIdentity_IdentityTypeId === null || customerIdentity_IdentityTypeId === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityTypeId' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityTypeId", customerIdentity_IdentityTypeId.toString());
        if (customerIdentity_IdentityNumber === null || customerIdentity_IdentityNumber === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityNumber' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityNumber", customerIdentity_IdentityNumber.toString());
        if (customerIdentity_NationalNo === null || customerIdentity_NationalNo === undefined)
            throw new Error("The parameter 'customerIdentity_NationalNo' cannot be null.");
        else
            content_.append("CustomerIdentity.NationalNo", customerIdentity_NationalNo.toString());
        if (customerIdentity_IssuePlaceId === null || customerIdentity_IssuePlaceId === undefined)
            throw new Error("The parameter 'customerIdentity_IssuePlaceId' cannot be null.");
        else
            content_.append("CustomerIdentity.IssuePlaceId", customerIdentity_IssuePlaceId.toString());
        if (customerIdentity_IssueDate === null || customerIdentity_IssueDate === undefined)
            throw new Error("The parameter 'customerIdentity_IssueDate' cannot be null.");
        else
            content_.append("CustomerIdentity.IssueDate", customerIdentity_IssueDate.toString());
        if (customerIdentity_ExpiryDate === null || customerIdentity_ExpiryDate === undefined)
            throw new Error("The parameter 'customerIdentity_ExpiryDate' cannot be null.");
        else
            content_.append("CustomerIdentity.ExpiryDate", customerIdentity_ExpiryDate.toString());
        if (customerIdentity_AddAttachment_Files === null || customerIdentity_AddAttachment_Files === undefined)
            throw new Error("The parameter 'customerIdentity_AddAttachment_Files' cannot be null.");
        else
            customerIdentity_AddAttachment_Files.forEach(item_ => content_.append("CustomerIdentity.AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "CustomerIdentity.AddAttachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param customerId (optional) 
     * @param delegationTypeId (optional) 
     * @param fullName (optional) 
     * @param nationalityId (optional) 
     * @param birthDate (optional) 
     * @param phone (optional) 
     * @param address (optional) 
     * @param expiryDate (optional) 
     * @param isPep (optional) 
     * @param attachment_RemovedIds (optional) 
     * @param attachment_Files (optional) 
     * @param attachment_Id (optional) 
     * @param customerIdentity_IdentityTypeId (optional) 
     * @param customerIdentity_IdentityNumber (optional) 
     * @param customerIdentity_NationalNo (optional) 
     * @param customerIdentity_IssuePlaceId (optional) 
     * @param customerIdentity_IssueDate (optional) 
     * @param customerIdentity_ExpiryDate (optional) 
     * @param customerIdentity_Attachment_RemovedIds (optional) 
     * @param customerIdentity_Attachment_Files (optional) 
     * @param customerIdentity_Attachment_Id (optional) 
     * @param id (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, customerId: number | undefined, delegationTypeId: number | undefined, fullName: string | undefined, nationalityId: number | undefined, birthDate: string | undefined, phone: string | undefined, address: string | undefined, expiryDate: string | undefined, isPep: boolean | undefined, attachment_RemovedIds: number[] | undefined, attachment_Files: FileParameter[] | undefined, attachment_Id: number | undefined, customerIdentity_IdentityTypeId: number | undefined, customerIdentity_IdentityNumber: string | undefined, customerIdentity_NationalNo: string | undefined, customerIdentity_IssuePlaceId: number | undefined, customerIdentity_IssueDate: string | undefined, customerIdentity_ExpiryDate: string | undefined, customerIdentity_Attachment_RemovedIds: number[] | undefined, customerIdentity_Attachment_Files: FileParameter[] | undefined, customerIdentity_Attachment_Id: number | undefined, id: number | undefined, signal?: AbortSignal): Promise<UpdateCustomerDelegateDto> {
        let url_ = this.baseUrl + "/api/Customer/CorporateDelegate/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (customerId === null || customerId === undefined)
            throw new Error("The parameter 'customerId' cannot be null.");
        else
            content_.append("CustomerId", customerId.toString());
        if (delegationTypeId === null || delegationTypeId === undefined)
            throw new Error("The parameter 'delegationTypeId' cannot be null.");
        else
            content_.append("DelegationTypeId", delegationTypeId.toString());
        if (fullName === null || fullName === undefined)
            throw new Error("The parameter 'fullName' cannot be null.");
        else
            content_.append("FullName", fullName.toString());
        if (nationalityId === null || nationalityId === undefined)
            throw new Error("The parameter 'nationalityId' cannot be null.");
        else
            content_.append("NationalityId", nationalityId.toString());
        if (birthDate === null || birthDate === undefined)
            throw new Error("The parameter 'birthDate' cannot be null.");
        else
            content_.append("BirthDate", birthDate.toString());
        if (phone === null || phone === undefined)
            throw new Error("The parameter 'phone' cannot be null.");
        else
            content_.append("Phone", phone.toString());
        if (address === null || address === undefined)
            throw new Error("The parameter 'address' cannot be null.");
        else
            content_.append("Address", address.toString());
        if (expiryDate === null || expiryDate === undefined)
            throw new Error("The parameter 'expiryDate' cannot be null.");
        else
            content_.append("ExpiryDate", expiryDate.toString());
        if (isPep === null || isPep === undefined)
            throw new Error("The parameter 'isPep' cannot be null.");
        else
            content_.append("IsPep", isPep.toString());
        if (attachment_RemovedIds === null || attachment_RemovedIds === undefined)
            throw new Error("The parameter 'attachment_RemovedIds' cannot be null.");
        else
            attachment_RemovedIds.forEach(item_ => content_.append("Attachment.RemovedIds", item_.toString()));
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );
        if (attachment_Id === null || attachment_Id === undefined)
            throw new Error("The parameter 'attachment_Id' cannot be null.");
        else
            content_.append("Attachment.Id", attachment_Id.toString());
        if (customerIdentity_IdentityTypeId === null || customerIdentity_IdentityTypeId === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityTypeId' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityTypeId", customerIdentity_IdentityTypeId.toString());
        if (customerIdentity_IdentityNumber === null || customerIdentity_IdentityNumber === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityNumber' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityNumber", customerIdentity_IdentityNumber.toString());
        if (customerIdentity_NationalNo === null || customerIdentity_NationalNo === undefined)
            throw new Error("The parameter 'customerIdentity_NationalNo' cannot be null.");
        else
            content_.append("CustomerIdentity.NationalNo", customerIdentity_NationalNo.toString());
        if (customerIdentity_IssuePlaceId === null || customerIdentity_IssuePlaceId === undefined)
            throw new Error("The parameter 'customerIdentity_IssuePlaceId' cannot be null.");
        else
            content_.append("CustomerIdentity.IssuePlaceId", customerIdentity_IssuePlaceId.toString());
        if (customerIdentity_IssueDate === null || customerIdentity_IssueDate === undefined)
            throw new Error("The parameter 'customerIdentity_IssueDate' cannot be null.");
        else
            content_.append("CustomerIdentity.IssueDate", customerIdentity_IssueDate.toString());
        if (customerIdentity_ExpiryDate === null || customerIdentity_ExpiryDate === undefined)
            throw new Error("The parameter 'customerIdentity_ExpiryDate' cannot be null.");
        else
            content_.append("CustomerIdentity.ExpiryDate", customerIdentity_ExpiryDate.toString());
        if (customerIdentity_Attachment_RemovedIds === null || customerIdentity_Attachment_RemovedIds === undefined)
            throw new Error("The parameter 'customerIdentity_Attachment_RemovedIds' cannot be null.");
        else
            customerIdentity_Attachment_RemovedIds.forEach(item_ => content_.append("CustomerIdentity.Attachment.RemovedIds", item_.toString()));
        if (customerIdentity_Attachment_Files === null || customerIdentity_Attachment_Files === undefined)
            throw new Error("The parameter 'customerIdentity_Attachment_Files' cannot be null.");
        else
            customerIdentity_Attachment_Files.forEach(item_ => content_.append("CustomerIdentity.Attachment.Files", item_.data, item_.fileName ? item_.fileName : "CustomerIdentity.Attachment.Files") );
        if (customerIdentity_Attachment_Id === null || customerIdentity_Attachment_Id === undefined)
            throw new Error("The parameter 'customerIdentity_Attachment_Id' cannot be null.");
        else
            content_.append("CustomerIdentity.Attachment.Id", customerIdentity_Attachment_Id.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCustomerDelegateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCustomerDelegateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCustomerDelegateDto>(null as any);
    }

    /**
     * @param corporateDelegateId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(corporateDelegateId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Customer/CorporateDelegate/Delete?";
        if (corporateDelegateId === null)
            throw new Error("The parameter 'corporateDelegateId' cannot be null.");
        else if (corporateDelegateId !== undefined)
            url_ += "corporateDelegateId=" + encodeURIComponent("" + corporateDelegateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param corporateDelegateId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(corporateDelegateId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerDelegateDto> {
        let url_ = this.baseUrl + "/api/Customer/CorporateDelegate/GetById?";
        if (corporateDelegateId === null)
            throw new Error("The parameter 'corporateDelegateId' cannot be null.");
        else if (corporateDelegateId !== undefined)
            url_ += "corporateDelegateId=" + encodeURIComponent("" + corporateDelegateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CustomerDelegateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerDelegateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerDelegateDto>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(customerId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerDelegateDto[]> {
        let url_ = this.baseUrl + "/api/Customer/CorporateDelegate/GetList?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CustomerDelegateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerDelegateDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerDelegateDto[]>(null as any);
    }
}

export class CorporateManagerClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param customerId (optional) 
     * @param type (optional) 
     * @param fullName (optional) 
     * @param birthDate (optional) 
     * @param phone (optional) 
     * @param address (optional) 
     * @param nationalityId (optional) 
     * @param positionId (optional) 
     * @param isPep (optional) 
     * @param customerIdentityId (optional) 
     * @param addAttachment_Files (optional) 
     * @param customerIdentity_IdentityTypeId (optional) 
     * @param customerIdentity_IdentityNumber (optional) 
     * @param customerIdentity_NationalNo (optional) 
     * @param customerIdentity_IssuePlaceId (optional) 
     * @param customerIdentity_IssueDate (optional) 
     * @param customerIdentity_ExpiryDate (optional) 
     * @param customerIdentity_AddAttachment_Files (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, customerId: number | undefined, type: CustomerRegistrationType | undefined, fullName: string | undefined, birthDate: string | undefined, phone: string | undefined, address: string | undefined, nationalityId: number | undefined, positionId: number | undefined, isPep: boolean | undefined, customerIdentityId: number | undefined, addAttachment_Files: FileParameter[] | undefined, customerIdentity_IdentityTypeId: number | undefined, customerIdentity_IdentityNumber: string | undefined, customerIdentity_NationalNo: string | undefined, customerIdentity_IssuePlaceId: number | undefined, customerIdentity_IssueDate: string | undefined, customerIdentity_ExpiryDate: string | undefined, customerIdentity_AddAttachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Customer/CorporateManager/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (customerId === null || customerId === undefined)
            throw new Error("The parameter 'customerId' cannot be null.");
        else
            content_.append("CustomerId", customerId.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (fullName === null || fullName === undefined)
            throw new Error("The parameter 'fullName' cannot be null.");
        else
            content_.append("FullName", fullName.toString());
        if (birthDate === null || birthDate === undefined)
            throw new Error("The parameter 'birthDate' cannot be null.");
        else
            content_.append("BirthDate", birthDate.toString());
        if (phone === null || phone === undefined)
            throw new Error("The parameter 'phone' cannot be null.");
        else
            content_.append("Phone", phone.toString());
        if (address === null || address === undefined)
            throw new Error("The parameter 'address' cannot be null.");
        else
            content_.append("Address", address.toString());
        if (nationalityId === null || nationalityId === undefined)
            throw new Error("The parameter 'nationalityId' cannot be null.");
        else
            content_.append("NationalityId", nationalityId.toString());
        if (positionId === null || positionId === undefined)
            throw new Error("The parameter 'positionId' cannot be null.");
        else
            content_.append("PositionId", positionId.toString());
        if (isPep === null || isPep === undefined)
            throw new Error("The parameter 'isPep' cannot be null.");
        else
            content_.append("IsPep", isPep.toString());
        if (customerIdentityId === null || customerIdentityId === undefined)
            throw new Error("The parameter 'customerIdentityId' cannot be null.");
        else
            content_.append("CustomerIdentityId", customerIdentityId.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );
        if (customerIdentity_IdentityTypeId === null || customerIdentity_IdentityTypeId === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityTypeId' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityTypeId", customerIdentity_IdentityTypeId.toString());
        if (customerIdentity_IdentityNumber === null || customerIdentity_IdentityNumber === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityNumber' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityNumber", customerIdentity_IdentityNumber.toString());
        if (customerIdentity_NationalNo === null || customerIdentity_NationalNo === undefined)
            throw new Error("The parameter 'customerIdentity_NationalNo' cannot be null.");
        else
            content_.append("CustomerIdentity.NationalNo", customerIdentity_NationalNo.toString());
        if (customerIdentity_IssuePlaceId === null || customerIdentity_IssuePlaceId === undefined)
            throw new Error("The parameter 'customerIdentity_IssuePlaceId' cannot be null.");
        else
            content_.append("CustomerIdentity.IssuePlaceId", customerIdentity_IssuePlaceId.toString());
        if (customerIdentity_IssueDate === null || customerIdentity_IssueDate === undefined)
            throw new Error("The parameter 'customerIdentity_IssueDate' cannot be null.");
        else
            content_.append("CustomerIdentity.IssueDate", customerIdentity_IssueDate.toString());
        if (customerIdentity_ExpiryDate === null || customerIdentity_ExpiryDate === undefined)
            throw new Error("The parameter 'customerIdentity_ExpiryDate' cannot be null.");
        else
            content_.append("CustomerIdentity.ExpiryDate", customerIdentity_ExpiryDate.toString());
        if (customerIdentity_AddAttachment_Files === null || customerIdentity_AddAttachment_Files === undefined)
            throw new Error("The parameter 'customerIdentity_AddAttachment_Files' cannot be null.");
        else
            customerIdentity_AddAttachment_Files.forEach(item_ => content_.append("CustomerIdentity.AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "CustomerIdentity.AddAttachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param fullName (optional) 
     * @param birthDate (optional) 
     * @param phone (optional) 
     * @param address (optional) 
     * @param nationalityId (optional) 
     * @param positionId (optional) 
     * @param isPep (optional) 
     * @param updateAttachment_RemovedIds (optional) 
     * @param updateAttachment_Files (optional) 
     * @param updateAttachment_Id (optional) 
     * @param customerIdentity_IdentityTypeId (optional) 
     * @param customerIdentity_IdentityNumber (optional) 
     * @param customerIdentity_NationalNo (optional) 
     * @param customerIdentity_IssuePlaceId (optional) 
     * @param customerIdentity_IssueDate (optional) 
     * @param customerIdentity_ExpiryDate (optional) 
     * @param customerIdentity_Attachment_RemovedIds (optional) 
     * @param customerIdentity_Attachment_Files (optional) 
     * @param customerIdentity_Attachment_Id (optional) 
     * @param id (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, fullName: string | undefined, birthDate: string | undefined, phone: string | undefined, address: string | undefined, nationalityId: number | undefined, positionId: number | undefined, isPep: boolean | undefined, updateAttachment_RemovedIds: number[] | undefined, updateAttachment_Files: FileParameter[] | undefined, updateAttachment_Id: number | undefined, customerIdentity_IdentityTypeId: number | undefined, customerIdentity_IdentityNumber: string | undefined, customerIdentity_NationalNo: string | undefined, customerIdentity_IssuePlaceId: number | undefined, customerIdentity_IssueDate: string | undefined, customerIdentity_ExpiryDate: string | undefined, customerIdentity_Attachment_RemovedIds: number[] | undefined, customerIdentity_Attachment_Files: FileParameter[] | undefined, customerIdentity_Attachment_Id: number | undefined, id: number | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Customer/CorporateManager/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (fullName === null || fullName === undefined)
            throw new Error("The parameter 'fullName' cannot be null.");
        else
            content_.append("FullName", fullName.toString());
        if (birthDate === null || birthDate === undefined)
            throw new Error("The parameter 'birthDate' cannot be null.");
        else
            content_.append("BirthDate", birthDate.toString());
        if (phone === null || phone === undefined)
            throw new Error("The parameter 'phone' cannot be null.");
        else
            content_.append("Phone", phone.toString());
        if (address === null || address === undefined)
            throw new Error("The parameter 'address' cannot be null.");
        else
            content_.append("Address", address.toString());
        if (nationalityId === null || nationalityId === undefined)
            throw new Error("The parameter 'nationalityId' cannot be null.");
        else
            content_.append("NationalityId", nationalityId.toString());
        if (positionId === null || positionId === undefined)
            throw new Error("The parameter 'positionId' cannot be null.");
        else
            content_.append("PositionId", positionId.toString());
        if (isPep === null || isPep === undefined)
            throw new Error("The parameter 'isPep' cannot be null.");
        else
            content_.append("IsPep", isPep.toString());
        if (updateAttachment_RemovedIds === null || updateAttachment_RemovedIds === undefined)
            throw new Error("The parameter 'updateAttachment_RemovedIds' cannot be null.");
        else
            updateAttachment_RemovedIds.forEach(item_ => content_.append("UpdateAttachment.RemovedIds", item_.toString()));
        if (updateAttachment_Files === null || updateAttachment_Files === undefined)
            throw new Error("The parameter 'updateAttachment_Files' cannot be null.");
        else
            updateAttachment_Files.forEach(item_ => content_.append("UpdateAttachment.Files", item_.data, item_.fileName ? item_.fileName : "UpdateAttachment.Files") );
        if (updateAttachment_Id === null || updateAttachment_Id === undefined)
            throw new Error("The parameter 'updateAttachment_Id' cannot be null.");
        else
            content_.append("UpdateAttachment.Id", updateAttachment_Id.toString());
        if (customerIdentity_IdentityTypeId === null || customerIdentity_IdentityTypeId === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityTypeId' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityTypeId", customerIdentity_IdentityTypeId.toString());
        if (customerIdentity_IdentityNumber === null || customerIdentity_IdentityNumber === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityNumber' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityNumber", customerIdentity_IdentityNumber.toString());
        if (customerIdentity_NationalNo === null || customerIdentity_NationalNo === undefined)
            throw new Error("The parameter 'customerIdentity_NationalNo' cannot be null.");
        else
            content_.append("CustomerIdentity.NationalNo", customerIdentity_NationalNo.toString());
        if (customerIdentity_IssuePlaceId === null || customerIdentity_IssuePlaceId === undefined)
            throw new Error("The parameter 'customerIdentity_IssuePlaceId' cannot be null.");
        else
            content_.append("CustomerIdentity.IssuePlaceId", customerIdentity_IssuePlaceId.toString());
        if (customerIdentity_IssueDate === null || customerIdentity_IssueDate === undefined)
            throw new Error("The parameter 'customerIdentity_IssueDate' cannot be null.");
        else
            content_.append("CustomerIdentity.IssueDate", customerIdentity_IssueDate.toString());
        if (customerIdentity_ExpiryDate === null || customerIdentity_ExpiryDate === undefined)
            throw new Error("The parameter 'customerIdentity_ExpiryDate' cannot be null.");
        else
            content_.append("CustomerIdentity.ExpiryDate", customerIdentity_ExpiryDate.toString());
        if (customerIdentity_Attachment_RemovedIds === null || customerIdentity_Attachment_RemovedIds === undefined)
            throw new Error("The parameter 'customerIdentity_Attachment_RemovedIds' cannot be null.");
        else
            customerIdentity_Attachment_RemovedIds.forEach(item_ => content_.append("CustomerIdentity.Attachment.RemovedIds", item_.toString()));
        if (customerIdentity_Attachment_Files === null || customerIdentity_Attachment_Files === undefined)
            throw new Error("The parameter 'customerIdentity_Attachment_Files' cannot be null.");
        else
            customerIdentity_Attachment_Files.forEach(item_ => content_.append("CustomerIdentity.Attachment.Files", item_.data, item_.fileName ? item_.fileName : "CustomerIdentity.Attachment.Files") );
        if (customerIdentity_Attachment_Id === null || customerIdentity_Attachment_Id === undefined)
            throw new Error("The parameter 'customerIdentity_Attachment_Id' cannot be null.");
        else
            content_.append("CustomerIdentity.Attachment.Id", customerIdentity_Attachment_Id.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Customer/CorporateManager/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CorporateManagerDto> {
        let url_ = this.baseUrl + "/api/Customer/CorporateManager/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CorporateManagerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CorporateManagerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CorporateManagerDto>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(customerId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CorporateManagerDto[]> {
        let url_ = this.baseUrl + "/api/Customer/CorporateManager/GetList?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CorporateManagerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CorporateManagerDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CorporateManagerDto[]>(null as any);
    }
}

export class CorporatePartnerClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param customerId (optional) 
     * @param partnershipTypeId (optional) 
     * @param partnerShare (optional) 
     * @param type (optional) 
     * @param fullName (optional) 
     * @param nationalityId (optional) 
     * @param birthDate (optional) 
     * @param phone (optional) 
     * @param address (optional) 
     * @param addAttachment_Files (optional) 
     * @param customerIdentity_IdentityTypeId (optional) 
     * @param customerIdentity_IdentityNumber (optional) 
     * @param customerIdentity_NationalNo (optional) 
     * @param customerIdentity_IssuePlaceId (optional) 
     * @param customerIdentity_IssueDate (optional) 
     * @param customerIdentity_ExpiryDate (optional) 
     * @param customerIdentity_AddAttachment_Files (optional) 
     * @param customerIdentityId (optional) 
     * @param isPep (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, customerId: number | undefined, partnershipTypeId: number | undefined, partnerShare: number | undefined, type: CustomerRegistrationType | undefined, fullName: string | undefined, nationalityId: number | undefined, birthDate: string | undefined, phone: string | undefined, address: string | undefined, addAttachment_Files: FileParameter[] | undefined, customerIdentity_IdentityTypeId: number | undefined, customerIdentity_IdentityNumber: string | undefined, customerIdentity_NationalNo: string | undefined, customerIdentity_IssuePlaceId: number | undefined, customerIdentity_IssueDate: string | undefined, customerIdentity_ExpiryDate: string | undefined, customerIdentity_AddAttachment_Files: FileParameter[] | undefined, customerIdentityId: number | undefined, isPep: boolean | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Customer/CorporatePartner/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (customerId === null || customerId === undefined)
            throw new Error("The parameter 'customerId' cannot be null.");
        else
            content_.append("CustomerId", customerId.toString());
        if (partnershipTypeId === null || partnershipTypeId === undefined)
            throw new Error("The parameter 'partnershipTypeId' cannot be null.");
        else
            content_.append("PartnershipTypeId", partnershipTypeId.toString());
        if (partnerShare === null || partnerShare === undefined)
            throw new Error("The parameter 'partnerShare' cannot be null.");
        else
            content_.append("PartnerShare", partnerShare.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (fullName === null || fullName === undefined)
            throw new Error("The parameter 'fullName' cannot be null.");
        else
            content_.append("FullName", fullName.toString());
        if (nationalityId === null || nationalityId === undefined)
            throw new Error("The parameter 'nationalityId' cannot be null.");
        else
            content_.append("NationalityId", nationalityId.toString());
        if (birthDate === null || birthDate === undefined)
            throw new Error("The parameter 'birthDate' cannot be null.");
        else
            content_.append("BirthDate", birthDate.toString());
        if (phone === null || phone === undefined)
            throw new Error("The parameter 'phone' cannot be null.");
        else
            content_.append("Phone", phone.toString());
        if (address === null || address === undefined)
            throw new Error("The parameter 'address' cannot be null.");
        else
            content_.append("Address", address.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );
        if (customerIdentity_IdentityTypeId === null || customerIdentity_IdentityTypeId === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityTypeId' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityTypeId", customerIdentity_IdentityTypeId.toString());
        if (customerIdentity_IdentityNumber === null || customerIdentity_IdentityNumber === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityNumber' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityNumber", customerIdentity_IdentityNumber.toString());
        if (customerIdentity_NationalNo === null || customerIdentity_NationalNo === undefined)
            throw new Error("The parameter 'customerIdentity_NationalNo' cannot be null.");
        else
            content_.append("CustomerIdentity.NationalNo", customerIdentity_NationalNo.toString());
        if (customerIdentity_IssuePlaceId === null || customerIdentity_IssuePlaceId === undefined)
            throw new Error("The parameter 'customerIdentity_IssuePlaceId' cannot be null.");
        else
            content_.append("CustomerIdentity.IssuePlaceId", customerIdentity_IssuePlaceId.toString());
        if (customerIdentity_IssueDate === null || customerIdentity_IssueDate === undefined)
            throw new Error("The parameter 'customerIdentity_IssueDate' cannot be null.");
        else
            content_.append("CustomerIdentity.IssueDate", customerIdentity_IssueDate.toString());
        if (customerIdentity_ExpiryDate === null || customerIdentity_ExpiryDate === undefined)
            throw new Error("The parameter 'customerIdentity_ExpiryDate' cannot be null.");
        else
            content_.append("CustomerIdentity.ExpiryDate", customerIdentity_ExpiryDate.toString());
        if (customerIdentity_AddAttachment_Files === null || customerIdentity_AddAttachment_Files === undefined)
            throw new Error("The parameter 'customerIdentity_AddAttachment_Files' cannot be null.");
        else
            customerIdentity_AddAttachment_Files.forEach(item_ => content_.append("CustomerIdentity.AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "CustomerIdentity.AddAttachment.Files") );
        if (customerIdentityId === null || customerIdentityId === undefined)
            throw new Error("The parameter 'customerIdentityId' cannot be null.");
        else
            content_.append("CustomerIdentityId", customerIdentityId.toString());
        if (isPep === null || isPep === undefined)
            throw new Error("The parameter 'isPep' cannot be null.");
        else
            content_.append("IsPep", isPep.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param partnershipTypeId (optional) 
     * @param partnerShare (optional) 
     * @param fullName (optional) 
     * @param nationalityId (optional) 
     * @param birthDate (optional) 
     * @param phone (optional) 
     * @param address (optional) 
     * @param attachment_RemovedIds (optional) 
     * @param attachment_Files (optional) 
     * @param attachment_Id (optional) 
     * @param customerIdentity_IdentityTypeId (optional) 
     * @param customerIdentity_IdentityNumber (optional) 
     * @param customerIdentity_NationalNo (optional) 
     * @param customerIdentity_IssuePlaceId (optional) 
     * @param customerIdentity_IssueDate (optional) 
     * @param customerIdentity_ExpiryDate (optional) 
     * @param customerIdentity_Attachment_RemovedIds (optional) 
     * @param customerIdentity_Attachment_Files (optional) 
     * @param customerIdentity_Attachment_Id (optional) 
     * @param isPep (optional) 
     * @param id (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, partnershipTypeId: number | undefined, partnerShare: number | undefined, fullName: string | undefined, nationalityId: number | undefined, birthDate: string | undefined, phone: string | undefined, address: string | undefined, attachment_RemovedIds: number[] | undefined, attachment_Files: FileParameter[] | undefined, attachment_Id: number | undefined, customerIdentity_IdentityTypeId: number | undefined, customerIdentity_IdentityNumber: string | undefined, customerIdentity_NationalNo: string | undefined, customerIdentity_IssuePlaceId: number | undefined, customerIdentity_IssueDate: string | undefined, customerIdentity_ExpiryDate: string | undefined, customerIdentity_Attachment_RemovedIds: number[] | undefined, customerIdentity_Attachment_Files: FileParameter[] | undefined, customerIdentity_Attachment_Id: number | undefined, isPep: boolean | undefined, id: number | undefined, signal?: AbortSignal): Promise<UpdateCustomerIdentityDto> {
        let url_ = this.baseUrl + "/api/Customer/CorporatePartner/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (partnershipTypeId === null || partnershipTypeId === undefined)
            throw new Error("The parameter 'partnershipTypeId' cannot be null.");
        else
            content_.append("PartnershipTypeId", partnershipTypeId.toString());
        if (partnerShare === null || partnerShare === undefined)
            throw new Error("The parameter 'partnerShare' cannot be null.");
        else
            content_.append("PartnerShare", partnerShare.toString());
        if (fullName === null || fullName === undefined)
            throw new Error("The parameter 'fullName' cannot be null.");
        else
            content_.append("FullName", fullName.toString());
        if (nationalityId === null || nationalityId === undefined)
            throw new Error("The parameter 'nationalityId' cannot be null.");
        else
            content_.append("NationalityId", nationalityId.toString());
        if (birthDate === null || birthDate === undefined)
            throw new Error("The parameter 'birthDate' cannot be null.");
        else
            content_.append("BirthDate", birthDate.toString());
        if (phone === null || phone === undefined)
            throw new Error("The parameter 'phone' cannot be null.");
        else
            content_.append("Phone", phone.toString());
        if (address === null || address === undefined)
            throw new Error("The parameter 'address' cannot be null.");
        else
            content_.append("Address", address.toString());
        if (attachment_RemovedIds === null || attachment_RemovedIds === undefined)
            throw new Error("The parameter 'attachment_RemovedIds' cannot be null.");
        else
            attachment_RemovedIds.forEach(item_ => content_.append("Attachment.RemovedIds", item_.toString()));
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );
        if (attachment_Id === null || attachment_Id === undefined)
            throw new Error("The parameter 'attachment_Id' cannot be null.");
        else
            content_.append("Attachment.Id", attachment_Id.toString());
        if (customerIdentity_IdentityTypeId === null || customerIdentity_IdentityTypeId === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityTypeId' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityTypeId", customerIdentity_IdentityTypeId.toString());
        if (customerIdentity_IdentityNumber === null || customerIdentity_IdentityNumber === undefined)
            throw new Error("The parameter 'customerIdentity_IdentityNumber' cannot be null.");
        else
            content_.append("CustomerIdentity.IdentityNumber", customerIdentity_IdentityNumber.toString());
        if (customerIdentity_NationalNo === null || customerIdentity_NationalNo === undefined)
            throw new Error("The parameter 'customerIdentity_NationalNo' cannot be null.");
        else
            content_.append("CustomerIdentity.NationalNo", customerIdentity_NationalNo.toString());
        if (customerIdentity_IssuePlaceId === null || customerIdentity_IssuePlaceId === undefined)
            throw new Error("The parameter 'customerIdentity_IssuePlaceId' cannot be null.");
        else
            content_.append("CustomerIdentity.IssuePlaceId", customerIdentity_IssuePlaceId.toString());
        if (customerIdentity_IssueDate === null || customerIdentity_IssueDate === undefined)
            throw new Error("The parameter 'customerIdentity_IssueDate' cannot be null.");
        else
            content_.append("CustomerIdentity.IssueDate", customerIdentity_IssueDate.toString());
        if (customerIdentity_ExpiryDate === null || customerIdentity_ExpiryDate === undefined)
            throw new Error("The parameter 'customerIdentity_ExpiryDate' cannot be null.");
        else
            content_.append("CustomerIdentity.ExpiryDate", customerIdentity_ExpiryDate.toString());
        if (customerIdentity_Attachment_RemovedIds === null || customerIdentity_Attachment_RemovedIds === undefined)
            throw new Error("The parameter 'customerIdentity_Attachment_RemovedIds' cannot be null.");
        else
            customerIdentity_Attachment_RemovedIds.forEach(item_ => content_.append("CustomerIdentity.Attachment.RemovedIds", item_.toString()));
        if (customerIdentity_Attachment_Files === null || customerIdentity_Attachment_Files === undefined)
            throw new Error("The parameter 'customerIdentity_Attachment_Files' cannot be null.");
        else
            customerIdentity_Attachment_Files.forEach(item_ => content_.append("CustomerIdentity.Attachment.Files", item_.data, item_.fileName ? item_.fileName : "CustomerIdentity.Attachment.Files") );
        if (customerIdentity_Attachment_Id === null || customerIdentity_Attachment_Id === undefined)
            throw new Error("The parameter 'customerIdentity_Attachment_Id' cannot be null.");
        else
            content_.append("CustomerIdentity.Attachment.Id", customerIdentity_Attachment_Id.toString());
        if (isPep === null || isPep === undefined)
            throw new Error("The parameter 'isPep' cannot be null.");
        else
            content_.append("IsPep", isPep.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCustomerIdentityDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCustomerIdentityDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCustomerIdentityDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Customer/CorporatePartner/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CorporatePartnerDto> {
        let url_ = this.baseUrl + "/api/Customer/CorporatePartner/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CorporatePartnerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CorporatePartnerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CorporatePartnerDto>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(customerId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CorporatePartnerDto[]> {
        let url_ = this.baseUrl + "/api/Customer/CorporatePartner/GetList?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CorporatePartnerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CorporatePartnerDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CorporatePartnerDto[]>(null as any);
    }
}

export class CustomerAddressClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddFullCustomerAddressDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Customer/CustomerAddress/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateCustomerAddressDto | undefined, signal?: AbortSignal): Promise<UpdateCustomerIdentityDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerAddress/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCustomerIdentityDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCustomerIdentityDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCustomerIdentityDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Customer/CustomerAddress/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerIdentityDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerAddress/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CustomerIdentityDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerIdentityDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerIdentityDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerIdentityDto[]> {
        let url_ = this.baseUrl + "/api/Customer/CustomerAddress/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CustomerIdentityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerIdentityDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerIdentityDto[]>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerAddressDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Customer/CustomerAddress/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<CustomerAddressDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerAddressDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerAddressDtoIPaginatedList>(null as any);
    }
}

export class CustomerComplianceClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    recheck(branchIdHeader: string | undefined, body: RecheckCustomerDto | undefined, signal?: AbortSignal): Promise<CustomerScreeningResult> {
        let url_ = this.baseUrl + "/api/Customer/CustomerCompliance/RecheckAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecheck(_response);
        });
    }

    protected processRecheck(response: AxiosResponse): Promise<CustomerScreeningResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerScreeningResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerScreeningResult>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    recheckAll(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Customer/CustomerCompliance/RecheckAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecheckAll(_response);
        });
    }

    protected processRecheckAll(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getRecheckAllJobStatus(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Customer/CustomerCompliance/GetRecheckAllJobStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecheckAllJobStatus(_response);
        });
    }

    protected processGetRecheckAllJobStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class CustomerExtensionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerIdentityDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerExtension/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CustomerIdentityDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerIdentityDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerIdentityDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerIdentityDto[]> {
        let url_ = this.baseUrl + "/api/Customer/CustomerExtension/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CustomerIdentityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerIdentityDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerIdentityDto[]>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerExtensionDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Customer/CustomerExtension/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<CustomerExtensionDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerExtensionDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerExtensionDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    set(branchIdHeader: string | undefined, body: SetCustomerExtensionDto | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Customer/CustomerExtension/Set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSet(_response);
        });
    }

    protected processSet(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class CustomerIdentityClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param customerId (optional) 
     * @param identityTypeId (optional) 
     * @param identityNumber (optional) 
     * @param nationalNo (optional) 
     * @param issuePlaceId (optional) 
     * @param issueDate (optional) 
     * @param expiryDate (optional) 
     * @param isMain (optional) 
     * @param addAttachment_Files (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, customerId: number | undefined, identityTypeId: number | undefined, identityNumber: string | undefined, nationalNo: string | undefined, issuePlaceId: number | undefined, issueDate: string | undefined, expiryDate: string | undefined, isMain: boolean | undefined, addAttachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Customer/CustomerIdentity/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (customerId === null || customerId === undefined)
            throw new Error("The parameter 'customerId' cannot be null.");
        else
            content_.append("CustomerId", customerId.toString());
        if (identityTypeId === null || identityTypeId === undefined)
            throw new Error("The parameter 'identityTypeId' cannot be null.");
        else
            content_.append("IdentityTypeId", identityTypeId.toString());
        if (identityNumber === null || identityNumber === undefined)
            throw new Error("The parameter 'identityNumber' cannot be null.");
        else
            content_.append("IdentityNumber", identityNumber.toString());
        if (nationalNo === null || nationalNo === undefined)
            throw new Error("The parameter 'nationalNo' cannot be null.");
        else
            content_.append("NationalNo", nationalNo.toString());
        if (issuePlaceId === null || issuePlaceId === undefined)
            throw new Error("The parameter 'issuePlaceId' cannot be null.");
        else
            content_.append("IssuePlaceId", issuePlaceId.toString());
        if (issueDate === null || issueDate === undefined)
            throw new Error("The parameter 'issueDate' cannot be null.");
        else
            content_.append("IssueDate", issueDate.toString());
        if (expiryDate === null || expiryDate === undefined)
            throw new Error("The parameter 'expiryDate' cannot be null.");
        else
            content_.append("ExpiryDate", expiryDate.toString());
        if (isMain === null || isMain === undefined)
            throw new Error("The parameter 'isMain' cannot be null.");
        else
            content_.append("IsMain", isMain.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param identityTypeId (optional) 
     * @param identityNumber (optional) 
     * @param nationalNo (optional) 
     * @param issuePlaceId (optional) 
     * @param issueDate (optional) 
     * @param expiryDate (optional) 
     * @param isMain (optional) 
     * @param attachment_RemovedIds (optional) 
     * @param attachment_Files (optional) 
     * @param attachment_Id (optional) 
     * @param id (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, identityTypeId: number | undefined, identityNumber: string | undefined, nationalNo: string | undefined, issuePlaceId: number | undefined, issueDate: string | undefined, expiryDate: string | undefined, isMain: boolean | undefined, attachment_RemovedIds: number[] | undefined, attachment_Files: FileParameter[] | undefined, attachment_Id: number | undefined, id: number | undefined, signal?: AbortSignal): Promise<UpdateCustomerIdentityDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerIdentity/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (identityTypeId === null || identityTypeId === undefined)
            throw new Error("The parameter 'identityTypeId' cannot be null.");
        else
            content_.append("IdentityTypeId", identityTypeId.toString());
        if (identityNumber === null || identityNumber === undefined)
            throw new Error("The parameter 'identityNumber' cannot be null.");
        else
            content_.append("IdentityNumber", identityNumber.toString());
        if (nationalNo === null || nationalNo === undefined)
            throw new Error("The parameter 'nationalNo' cannot be null.");
        else
            content_.append("NationalNo", nationalNo.toString());
        if (issuePlaceId === null || issuePlaceId === undefined)
            throw new Error("The parameter 'issuePlaceId' cannot be null.");
        else
            content_.append("IssuePlaceId", issuePlaceId.toString());
        if (issueDate === null || issueDate === undefined)
            throw new Error("The parameter 'issueDate' cannot be null.");
        else
            content_.append("IssueDate", issueDate.toString());
        if (expiryDate === null || expiryDate === undefined)
            throw new Error("The parameter 'expiryDate' cannot be null.");
        else
            content_.append("ExpiryDate", expiryDate.toString());
        if (isMain === null || isMain === undefined)
            throw new Error("The parameter 'isMain' cannot be null.");
        else
            content_.append("IsMain", isMain.toString());
        if (attachment_RemovedIds === null || attachment_RemovedIds === undefined)
            throw new Error("The parameter 'attachment_RemovedIds' cannot be null.");
        else
            attachment_RemovedIds.forEach(item_ => content_.append("Attachment.RemovedIds", item_.toString()));
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );
        if (attachment_Id === null || attachment_Id === undefined)
            throw new Error("The parameter 'attachment_Id' cannot be null.");
        else
            content_.append("Attachment.Id", attachment_Id.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCustomerIdentityDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCustomerIdentityDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCustomerIdentityDto>(null as any);
    }

    /**
     * @param customerIdentityId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(customerIdentityId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerIdentityDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerIdentity/GetById?";
        if (customerIdentityId === null)
            throw new Error("The parameter 'customerIdentityId' cannot be null.");
        else if (customerIdentityId !== undefined)
            url_ += "customerIdentityId=" + encodeURIComponent("" + customerIdentityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CustomerIdentityDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerIdentityDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerIdentityDto>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(customerId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerIdentityDto[]> {
        let url_ = this.baseUrl + "/api/Customer/CustomerIdentity/GetList?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CustomerIdentityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerIdentityDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerIdentityDto[]>(null as any);
    }
}

export class CustomerLookupClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param customerLookupType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, customerLookupType: CustomerLookupTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerLookupModel> {
        let url_ = this.baseUrl + "/api/Customer/CustomerLookup/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (customerLookupType === null)
            throw new Error("The parameter 'customerLookupType' cannot be null.");
        else if (customerLookupType !== undefined)
            url_ += "customerLookupType=" + encodeURIComponent("" + customerLookupType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CustomerLookupModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerLookupModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerLookupModel>(null as any);
    }

    /**
     * @param customerLookupType (optional) 
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(customerLookupType: CustomerLookupTypes | undefined, usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerLookupModel[]> {
        let url_ = this.baseUrl + "/api/Customer/CustomerLookup/GetList?";
        if (customerLookupType === null)
            throw new Error("The parameter 'customerLookupType' cannot be null.");
        else if (customerLookupType !== undefined)
            url_ += "customerLookupType=" + encodeURIComponent("" + customerLookupType) + "&";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CustomerLookupModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerLookupModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerLookupModel[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddCustomerLookupModel | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Customer/CustomerLookup/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @param customerLookupType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, customerLookupType: CustomerLookupTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullCustomerLookupModel> {
        let url_ = this.baseUrl + "/api/Customer/CustomerLookup/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (customerLookupType === null)
            throw new Error("The parameter 'customerLookupType' cannot be null.");
        else if (customerLookupType !== undefined)
            url_ += "customerLookupType=" + encodeURIComponent("" + customerLookupType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullCustomerLookupModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullCustomerLookupModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullCustomerLookupModel>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateCustomerLookupModel | undefined, signal?: AbortSignal): Promise<UpdateCustomerLookupModel> {
        let url_ = this.baseUrl + "/api/Customer/CustomerLookup/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCustomerLookupModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCustomerLookupModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCustomerLookupModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @param customerLookupType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, customerLookupType: CustomerLookupTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Customer/CustomerLookup/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (customerLookupType === null)
            throw new Error("The parameter 'customerLookupType' cannot be null.");
        else if (customerLookupType !== undefined)
            url_ += "customerLookupType=" + encodeURIComponent("" + customerLookupType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeLookupStatusModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Customer/CustomerLookup/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CustomerReportClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param identityTypeIds (optional) 
     * @param identityNumber (optional) 
     * @param nationalNumber (optional) 
     * @param isMain (optional) 
     * @param issuePlaceIds (optional) 
     * @param issueDate_From (optional) 
     * @param issueDate_To (optional) 
     * @param expiryDate_From (optional) 
     * @param expiryDate_To (optional) 
     * @param identityStatus (optional) 
     * @param delegationStatus (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportCustomerIdentity(identityTypeIds: number[] | undefined, identityNumber: string | undefined, nationalNumber: string | undefined, isMain: boolean | undefined, issuePlaceIds: number[] | undefined, issueDate_From: string | undefined, issueDate_To: string | undefined, expiryDate_From: string | undefined, expiryDate_To: string | undefined, identityStatus: IdentityStatuses | undefined, delegationStatus: IdentityStatuses | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerReport/ExportCustomerIdentity?";
        if (identityTypeIds === null)
            throw new Error("The parameter 'identityTypeIds' cannot be null.");
        else if (identityTypeIds !== undefined)
            identityTypeIds && identityTypeIds.forEach(item => { url_ += "IdentityTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (identityNumber === null)
            throw new Error("The parameter 'identityNumber' cannot be null.");
        else if (identityNumber !== undefined)
            url_ += "IdentityNumber=" + encodeURIComponent("" + identityNumber) + "&";
        if (nationalNumber === null)
            throw new Error("The parameter 'nationalNumber' cannot be null.");
        else if (nationalNumber !== undefined)
            url_ += "NationalNumber=" + encodeURIComponent("" + nationalNumber) + "&";
        if (isMain === null)
            throw new Error("The parameter 'isMain' cannot be null.");
        else if (isMain !== undefined)
            url_ += "IsMain=" + encodeURIComponent("" + isMain) + "&";
        if (issuePlaceIds === null)
            throw new Error("The parameter 'issuePlaceIds' cannot be null.");
        else if (issuePlaceIds !== undefined)
            issuePlaceIds && issuePlaceIds.forEach(item => { url_ += "IssuePlaceIds=" + encodeURIComponent("" + item) + "&"; });
        if (issueDate_From === null)
            throw new Error("The parameter 'issueDate_From' cannot be null.");
        else if (issueDate_From !== undefined)
            url_ += "IssueDate.From=" + encodeURIComponent("" + issueDate_From) + "&";
        if (issueDate_To === null)
            throw new Error("The parameter 'issueDate_To' cannot be null.");
        else if (issueDate_To !== undefined)
            url_ += "IssueDate.To=" + encodeURIComponent("" + issueDate_To) + "&";
        if (expiryDate_From === null)
            throw new Error("The parameter 'expiryDate_From' cannot be null.");
        else if (expiryDate_From !== undefined)
            url_ += "ExpiryDate.From=" + encodeURIComponent("" + expiryDate_From) + "&";
        if (expiryDate_To === null)
            throw new Error("The parameter 'expiryDate_To' cannot be null.");
        else if (expiryDate_To !== undefined)
            url_ += "ExpiryDate.To=" + encodeURIComponent("" + expiryDate_To) + "&";
        if (identityStatus === null)
            throw new Error("The parameter 'identityStatus' cannot be null.");
        else if (identityStatus !== undefined)
            url_ += "IdentityStatus=" + encodeURIComponent("" + identityStatus) + "&";
        if (delegationStatus === null)
            throw new Error("The parameter 'delegationStatus' cannot be null.");
        else if (delegationStatus !== undefined)
            url_ += "DelegationStatus=" + encodeURIComponent("" + delegationStatus) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportCustomerIdentity(_response);
        });
    }

    protected processExportCustomerIdentity(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param name (optional) 
     * @param pWD (optional) 
     * @param isPep (optional) 
     * @param isFI (optional) 
     * @param types (optional) 
     * @param subTypes (optional) 
     * @param nationalityIds (optional) 
     * @param identityTypeIds (optional) 
     * @param identityNumber (optional) 
     * @param professionIds (optional) 
     * @param branchIds (optional) 
     * @param statuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportCustomersReport(date_From: string | undefined, date_To: string | undefined, name: string | undefined, pWD: boolean | undefined, isPep: boolean | undefined, isFI: boolean | undefined, types: CustomerTypes[] | undefined, subTypes: number[] | undefined, nationalityIds: number[] | undefined, identityTypeIds: number[] | undefined, identityNumber: string | undefined, professionIds: number[] | undefined, branchIds: number[] | undefined, statuses: CustomerStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerReport/ExportCustomersReport?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pWD === null)
            throw new Error("The parameter 'pWD' cannot be null.");
        else if (pWD !== undefined)
            url_ += "PWD=" + encodeURIComponent("" + pWD) + "&";
        if (isPep === null)
            throw new Error("The parameter 'isPep' cannot be null.");
        else if (isPep !== undefined)
            url_ += "IsPep=" + encodeURIComponent("" + isPep) + "&";
        if (isFI === null)
            throw new Error("The parameter 'isFI' cannot be null.");
        else if (isFI !== undefined)
            url_ += "IsFI=" + encodeURIComponent("" + isFI) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (subTypes === null)
            throw new Error("The parameter 'subTypes' cannot be null.");
        else if (subTypes !== undefined)
            subTypes && subTypes.forEach(item => { url_ += "SubTypes=" + encodeURIComponent("" + item) + "&"; });
        if (nationalityIds === null)
            throw new Error("The parameter 'nationalityIds' cannot be null.");
        else if (nationalityIds !== undefined)
            nationalityIds && nationalityIds.forEach(item => { url_ += "NationalityIds=" + encodeURIComponent("" + item) + "&"; });
        if (identityTypeIds === null)
            throw new Error("The parameter 'identityTypeIds' cannot be null.");
        else if (identityTypeIds !== undefined)
            identityTypeIds && identityTypeIds.forEach(item => { url_ += "IdentityTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (identityNumber === null)
            throw new Error("The parameter 'identityNumber' cannot be null.");
        else if (identityNumber !== undefined)
            url_ += "IdentityNumber=" + encodeURIComponent("" + identityNumber) + "&";
        if (professionIds === null)
            throw new Error("The parameter 'professionIds' cannot be null.");
        else if (professionIds !== undefined)
            professionIds && professionIds.forEach(item => { url_ += "ProfessionIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportCustomersReport(_response);
        });
    }

    protected processExportCustomersReport(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param name (optional) 
     * @param pWD (optional) 
     * @param isPep (optional) 
     * @param isFI (optional) 
     * @param types (optional) 
     * @param subTypes (optional) 
     * @param nationalityIds (optional) 
     * @param identityTypeIds (optional) 
     * @param identityNumber (optional) 
     * @param professionIds (optional) 
     * @param branchIds (optional) 
     * @param statuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCustomers(date_From: string | undefined, date_To: string | undefined, name: string | undefined, pWD: boolean | undefined, isPep: boolean | undefined, isFI: boolean | undefined, types: CustomerTypes[] | undefined, subTypes: number[] | undefined, nationalityIds: number[] | undefined, identityTypeIds: number[] | undefined, identityNumber: string | undefined, professionIds: number[] | undefined, branchIds: number[] | undefined, statuses: CustomerStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomersReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Customer/CustomerReport/GetCustomers?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pWD === null)
            throw new Error("The parameter 'pWD' cannot be null.");
        else if (pWD !== undefined)
            url_ += "PWD=" + encodeURIComponent("" + pWD) + "&";
        if (isPep === null)
            throw new Error("The parameter 'isPep' cannot be null.");
        else if (isPep !== undefined)
            url_ += "IsPep=" + encodeURIComponent("" + isPep) + "&";
        if (isFI === null)
            throw new Error("The parameter 'isFI' cannot be null.");
        else if (isFI !== undefined)
            url_ += "IsFI=" + encodeURIComponent("" + isFI) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (subTypes === null)
            throw new Error("The parameter 'subTypes' cannot be null.");
        else if (subTypes !== undefined)
            subTypes && subTypes.forEach(item => { url_ += "SubTypes=" + encodeURIComponent("" + item) + "&"; });
        if (nationalityIds === null)
            throw new Error("The parameter 'nationalityIds' cannot be null.");
        else if (nationalityIds !== undefined)
            nationalityIds && nationalityIds.forEach(item => { url_ += "NationalityIds=" + encodeURIComponent("" + item) + "&"; });
        if (identityTypeIds === null)
            throw new Error("The parameter 'identityTypeIds' cannot be null.");
        else if (identityTypeIds !== undefined)
            identityTypeIds && identityTypeIds.forEach(item => { url_ += "IdentityTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (identityNumber === null)
            throw new Error("The parameter 'identityNumber' cannot be null.");
        else if (identityNumber !== undefined)
            url_ += "IdentityNumber=" + encodeURIComponent("" + identityNumber) + "&";
        if (professionIds === null)
            throw new Error("The parameter 'professionIds' cannot be null.");
        else if (professionIds !== undefined)
            professionIds && professionIds.forEach(item => { url_ += "ProfessionIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCustomers(_response);
        });
    }

    protected processGetCustomers(response: AxiosResponse): Promise<CustomersReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomersReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomersReportModelIPaginatedList>(null as any);
    }

    /**
     * @param identityTypeIds (optional) 
     * @param identityNumber (optional) 
     * @param nationalNumber (optional) 
     * @param isMain (optional) 
     * @param issuePlaceIds (optional) 
     * @param issueDate_From (optional) 
     * @param issueDate_To (optional) 
     * @param expiryDate_From (optional) 
     * @param expiryDate_To (optional) 
     * @param identityStatus (optional) 
     * @param delegationStatus (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getIdentity(identityTypeIds: number[] | undefined, identityNumber: string | undefined, nationalNumber: string | undefined, isMain: boolean | undefined, issuePlaceIds: number[] | undefined, issueDate_From: string | undefined, issueDate_To: string | undefined, expiryDate_From: string | undefined, expiryDate_To: string | undefined, identityStatus: IdentityStatuses | undefined, delegationStatus: IdentityStatuses | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<IdentityReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Customer/CustomerReport/GetIdentity?";
        if (identityTypeIds === null)
            throw new Error("The parameter 'identityTypeIds' cannot be null.");
        else if (identityTypeIds !== undefined)
            identityTypeIds && identityTypeIds.forEach(item => { url_ += "IdentityTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (identityNumber === null)
            throw new Error("The parameter 'identityNumber' cannot be null.");
        else if (identityNumber !== undefined)
            url_ += "IdentityNumber=" + encodeURIComponent("" + identityNumber) + "&";
        if (nationalNumber === null)
            throw new Error("The parameter 'nationalNumber' cannot be null.");
        else if (nationalNumber !== undefined)
            url_ += "NationalNumber=" + encodeURIComponent("" + nationalNumber) + "&";
        if (isMain === null)
            throw new Error("The parameter 'isMain' cannot be null.");
        else if (isMain !== undefined)
            url_ += "IsMain=" + encodeURIComponent("" + isMain) + "&";
        if (issuePlaceIds === null)
            throw new Error("The parameter 'issuePlaceIds' cannot be null.");
        else if (issuePlaceIds !== undefined)
            issuePlaceIds && issuePlaceIds.forEach(item => { url_ += "IssuePlaceIds=" + encodeURIComponent("" + item) + "&"; });
        if (issueDate_From === null)
            throw new Error("The parameter 'issueDate_From' cannot be null.");
        else if (issueDate_From !== undefined)
            url_ += "IssueDate.From=" + encodeURIComponent("" + issueDate_From) + "&";
        if (issueDate_To === null)
            throw new Error("The parameter 'issueDate_To' cannot be null.");
        else if (issueDate_To !== undefined)
            url_ += "IssueDate.To=" + encodeURIComponent("" + issueDate_To) + "&";
        if (expiryDate_From === null)
            throw new Error("The parameter 'expiryDate_From' cannot be null.");
        else if (expiryDate_From !== undefined)
            url_ += "ExpiryDate.From=" + encodeURIComponent("" + expiryDate_From) + "&";
        if (expiryDate_To === null)
            throw new Error("The parameter 'expiryDate_To' cannot be null.");
        else if (expiryDate_To !== undefined)
            url_ += "ExpiryDate.To=" + encodeURIComponent("" + expiryDate_To) + "&";
        if (identityStatus === null)
            throw new Error("The parameter 'identityStatus' cannot be null.");
        else if (identityStatus !== undefined)
            url_ += "IdentityStatus=" + encodeURIComponent("" + identityStatus) + "&";
        if (delegationStatus === null)
            throw new Error("The parameter 'delegationStatus' cannot be null.");
        else if (delegationStatus !== undefined)
            url_ += "DelegationStatus=" + encodeURIComponent("" + delegationStatus) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIdentity(_response);
        });
    }

    protected processGetIdentity(response: AxiosResponse): Promise<IdentityReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<IdentityReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityReportModelIPaginatedList>(null as any);
    }
}

export class CustomersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param customerId (optional) 
     * @param period (optional) 
     * @param transactionTypeIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCustomerCardTransaction(customerId: number | undefined, period: TimePeriods | undefined, transactionTypeIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerCardTransactionModel> {
        let url_ = this.baseUrl + "/api/Customer/Customers/GetCustomerCardTransaction?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (transactionTypeIds === null)
            throw new Error("The parameter 'transactionTypeIds' cannot be null.");
        else if (transactionTypeIds !== undefined)
            transactionTypeIds && transactionTypeIds.forEach(item => { url_ += "TransactionTypeIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCustomerCardTransaction(_response);
        });
    }

    protected processGetCustomerCardTransaction(response: AxiosResponse): Promise<CustomerCardTransactionModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerCardTransactionModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerCardTransactionModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    printIndividualKYC(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/PrintIndividualKYC?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrintIndividualKYC(_response);
        });
    }

    protected processPrintIndividualKYC(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    printCorporateKYC(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/PrintCorporateKYC?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrintCorporateKYC(_response);
        });
    }

    protected processPrintCorporateKYC(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param exportAs (optional) 
     * @param key (optional) 
     * @param number (optional) 
     * @param name (optional) 
     * @param pWD (optional) 
     * @param isPep (optional) 
     * @param isFI (optional) 
     * @param type (optional) 
     * @param dateCreated_From (optional) 
     * @param dateCreated_To (optional) 
     * @param nationalityIds (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param identityNumber (optional) 
     * @param identityExpiryDate_From (optional) 
     * @param identityExpiryDate_To (optional) 
     * @param customerStatuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    export(exportAs: ReportTypes | undefined, key: string | undefined, number: string | undefined, name: string | undefined, pWD: boolean | undefined, isPep: boolean | undefined, isFI: boolean | undefined, type: CustomerTypes | undefined, dateCreated_From: string | undefined, dateCreated_To: string | undefined, nationalityIds: number[] | undefined, date_From: string | undefined, date_To: string | undefined, identityNumber: string | undefined, identityExpiryDate_From: string | undefined, identityExpiryDate_To: string | undefined, customerStatuses: CustomerStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/Export?";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pWD === null)
            throw new Error("The parameter 'pWD' cannot be null.");
        else if (pWD !== undefined)
            url_ += "PWD=" + encodeURIComponent("" + pWD) + "&";
        if (isPep === null)
            throw new Error("The parameter 'isPep' cannot be null.");
        else if (isPep !== undefined)
            url_ += "IsPep=" + encodeURIComponent("" + isPep) + "&";
        if (isFI === null)
            throw new Error("The parameter 'isFI' cannot be null.");
        else if (isFI !== undefined)
            url_ += "IsFI=" + encodeURIComponent("" + isFI) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (dateCreated_From === null)
            throw new Error("The parameter 'dateCreated_From' cannot be null.");
        else if (dateCreated_From !== undefined)
            url_ += "DateCreated.From=" + encodeURIComponent("" + dateCreated_From) + "&";
        if (dateCreated_To === null)
            throw new Error("The parameter 'dateCreated_To' cannot be null.");
        else if (dateCreated_To !== undefined)
            url_ += "DateCreated.To=" + encodeURIComponent("" + dateCreated_To) + "&";
        if (nationalityIds === null)
            throw new Error("The parameter 'nationalityIds' cannot be null.");
        else if (nationalityIds !== undefined)
            nationalityIds && nationalityIds.forEach(item => { url_ += "NationalityIds=" + encodeURIComponent("" + item) + "&"; });
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (identityNumber === null)
            throw new Error("The parameter 'identityNumber' cannot be null.");
        else if (identityNumber !== undefined)
            url_ += "IdentityNumber=" + encodeURIComponent("" + identityNumber) + "&";
        if (identityExpiryDate_From === null)
            throw new Error("The parameter 'identityExpiryDate_From' cannot be null.");
        else if (identityExpiryDate_From !== undefined)
            url_ += "IdentityExpiryDate.From=" + encodeURIComponent("" + identityExpiryDate_From) + "&";
        if (identityExpiryDate_To === null)
            throw new Error("The parameter 'identityExpiryDate_To' cannot be null.");
        else if (identityExpiryDate_To !== undefined)
            url_ += "IdentityExpiryDate.To=" + encodeURIComponent("" + identityExpiryDate_To) + "&";
        if (customerStatuses === null)
            throw new Error("The parameter 'customerStatuses' cannot be null.");
        else if (customerStatuses !== undefined)
            customerStatuses && customerStatuses.forEach(item => { url_ += "CustomerStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCustomerLevelsMandatory(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/Customer/Customers/GetCustomerLevelsMandatory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCustomerLevelsMandatory(_response);
        });
    }

    protected processGetCustomerLevelsMandatory(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    createPerson(branchIdHeader: string | undefined, body: AddPersonDto | undefined, signal?: AbortSignal): Promise<AddCustomerResponseDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/CreatePerson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePerson(_response);
        });
    }

    protected processCreatePerson(response: AxiosResponse): Promise<AddCustomerResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AddCustomerResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddCustomerResponseDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    createCorporate(branchIdHeader: string | undefined, body: AddCorporateDto | undefined, signal?: AbortSignal): Promise<AddCustomerResponseDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/CreateCorporate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCorporate(_response);
        });
    }

    protected processCreateCorporate(response: AxiosResponse): Promise<AddCustomerResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AddCustomerResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddCustomerResponseDto>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(customerId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/GetById?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CustomerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerDto>(null as any);
    }

    /**
     * @param referenceNumber (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getByReferenceNumber(referenceNumber: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/GetByReferenceNumber?";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "referenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByReferenceNumber(_response);
        });
    }

    protected processGetByReferenceNumber(response: AxiosResponse): Promise<CustomerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerDto>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(customerId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullCustomerDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/GetToUpdate?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullCustomerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullCustomerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullCustomerDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    updatePersonBasicInformation(branchIdHeader: string | undefined, body: UpdatePersonBasicInformationDto | undefined, signal?: AbortSignal): Promise<UpdatePersonDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/UpdatePersonBasicInformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePersonBasicInformation(_response);
        });
    }

    protected processUpdatePersonBasicInformation(response: AxiosResponse): Promise<UpdatePersonDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdatePersonDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdatePersonDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateCorporateBasicInformation(branchIdHeader: string | undefined, body: UpdateCorporateBasicInformationDto | undefined, signal?: AbortSignal): Promise<UpdateCorporateDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/UpdateCorporateBasicInformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateCorporateBasicInformation(_response);
        });
    }

    protected processUpdateCorporateBasicInformation(response: AxiosResponse): Promise<UpdateCorporateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCorporateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCorporateDto>(null as any);
    }

    /**
     * @param key (optional) 
     * @param number (optional) 
     * @param name (optional) 
     * @param pWD (optional) 
     * @param isPep (optional) 
     * @param isFI (optional) 
     * @param type (optional) 
     * @param dateCreated_From (optional) 
     * @param dateCreated_To (optional) 
     * @param nationalityIds (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param identityNumber (optional) 
     * @param identityExpiryDate_From (optional) 
     * @param identityExpiryDate_To (optional) 
     * @param customerStatuses (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(key: string | undefined, number: string | undefined, name: string | undefined, pWD: boolean | undefined, isPep: boolean | undefined, isFI: boolean | undefined, type: CustomerTypes | undefined, dateCreated_From: string | undefined, dateCreated_To: string | undefined, nationalityIds: number[] | undefined, date_From: string | undefined, date_To: string | undefined, identityNumber: string | undefined, identityExpiryDate_From: string | undefined, identityExpiryDate_To: string | undefined, customerStatuses: CustomerStatuses[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Customer/Customers/GetPaginatedList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pWD === null)
            throw new Error("The parameter 'pWD' cannot be null.");
        else if (pWD !== undefined)
            url_ += "PWD=" + encodeURIComponent("" + pWD) + "&";
        if (isPep === null)
            throw new Error("The parameter 'isPep' cannot be null.");
        else if (isPep !== undefined)
            url_ += "IsPep=" + encodeURIComponent("" + isPep) + "&";
        if (isFI === null)
            throw new Error("The parameter 'isFI' cannot be null.");
        else if (isFI !== undefined)
            url_ += "IsFI=" + encodeURIComponent("" + isFI) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (dateCreated_From === null)
            throw new Error("The parameter 'dateCreated_From' cannot be null.");
        else if (dateCreated_From !== undefined)
            url_ += "DateCreated.From=" + encodeURIComponent("" + dateCreated_From) + "&";
        if (dateCreated_To === null)
            throw new Error("The parameter 'dateCreated_To' cannot be null.");
        else if (dateCreated_To !== undefined)
            url_ += "DateCreated.To=" + encodeURIComponent("" + dateCreated_To) + "&";
        if (nationalityIds === null)
            throw new Error("The parameter 'nationalityIds' cannot be null.");
        else if (nationalityIds !== undefined)
            nationalityIds && nationalityIds.forEach(item => { url_ += "NationalityIds=" + encodeURIComponent("" + item) + "&"; });
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (identityNumber === null)
            throw new Error("The parameter 'identityNumber' cannot be null.");
        else if (identityNumber !== undefined)
            url_ += "IdentityNumber=" + encodeURIComponent("" + identityNumber) + "&";
        if (identityExpiryDate_From === null)
            throw new Error("The parameter 'identityExpiryDate_From' cannot be null.");
        else if (identityExpiryDate_From !== undefined)
            url_ += "IdentityExpiryDate.From=" + encodeURIComponent("" + identityExpiryDate_From) + "&";
        if (identityExpiryDate_To === null)
            throw new Error("The parameter 'identityExpiryDate_To' cannot be null.");
        else if (identityExpiryDate_To !== undefined)
            url_ += "IdentityExpiryDate.To=" + encodeURIComponent("" + identityExpiryDate_To) + "&";
        if (customerStatuses === null)
            throw new Error("The parameter 'customerStatuses' cannot be null.");
        else if (customerStatuses !== undefined)
            customerStatuses && customerStatuses.forEach(item => { url_ += "CustomerStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<CustomerListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerListDtoIPaginatedList>(null as any);
    }

    /**
     * @param actionDate_From (optional) 
     * @param actionDate_To (optional) 
     * @param actions (optional) 
     * @param actionById (optional) 
     * @param assignedToId (optional) 
     * @param referanceNumber (optional) 
     * @param addComplianceLogs (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getActivityLog(actionDate_From: string | undefined, actionDate_To: string | undefined, actions: ActivityLogAction[] | undefined, actionById: number[] | undefined, assignedToId: number[] | undefined, referanceNumber: string | undefined, addComplianceLogs: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ActivityLogDto[]> {
        let url_ = this.baseUrl + "/api/Customer/Customers/GetActivityLog?";
        if (actionDate_From === null)
            throw new Error("The parameter 'actionDate_From' cannot be null.");
        else if (actionDate_From !== undefined)
            url_ += "ActionDate.From=" + encodeURIComponent("" + actionDate_From) + "&";
        if (actionDate_To === null)
            throw new Error("The parameter 'actionDate_To' cannot be null.");
        else if (actionDate_To !== undefined)
            url_ += "ActionDate.To=" + encodeURIComponent("" + actionDate_To) + "&";
        if (actions === null)
            throw new Error("The parameter 'actions' cannot be null.");
        else if (actions !== undefined)
            actions && actions.forEach(item => { url_ += "Actions=" + encodeURIComponent("" + item) + "&"; });
        if (actionById === null)
            throw new Error("The parameter 'actionById' cannot be null.");
        else if (actionById !== undefined)
            actionById && actionById.forEach(item => { url_ += "ActionById=" + encodeURIComponent("" + item) + "&"; });
        if (assignedToId === null)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else if (assignedToId !== undefined)
            assignedToId && assignedToId.forEach(item => { url_ += "AssignedToId=" + encodeURIComponent("" + item) + "&"; });
        if (referanceNumber === null)
            throw new Error("The parameter 'referanceNumber' cannot be null.");
        else if (referanceNumber !== undefined)
            url_ += "ReferanceNumber=" + encodeURIComponent("" + referanceNumber) + "&";
        if (addComplianceLogs === null)
            throw new Error("The parameter 'addComplianceLogs' cannot be null.");
        else if (addComplianceLogs !== undefined)
            url_ += "AddComplianceLogs=" + encodeURIComponent("" + addComplianceLogs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActivityLog(_response);
        });
    }

    protected processGetActivityLog(response: AxiosResponse): Promise<ActivityLogDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ActivityLogDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityLogDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    releaseBlockToggle(branchIdHeader: string | undefined, body: ReleaseBlockToggleModel | undefined, signal?: AbortSignal): Promise<CustomerStatuses> {
        let url_ = this.baseUrl + "/api/Customer/Customers/ReleaseBlockToggle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReleaseBlockToggle(_response);
        });
    }

    protected processReleaseBlockToggle(response: AxiosResponse): Promise<CustomerStatuses> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerStatuses>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerStatuses>(null as any);
    }
}

export class FormClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param firstName (optional) 
     * @param secondName (optional) 
     * @param thirdName (optional) 
     * @param lastName (optional) 
     * @param firstNameLang (optional) 
     * @param secondNameLang (optional) 
     * @param thirdNameLang (optional) 
     * @param lastNameLang (optional) 
     * @param phone (optional) 
     * @param email (optional) 
     * @param birthDate (optional) 
     * @param customerSubTypeId (optional) 
     * @param birthPlaceId (optional) 
     * @param genderId (optional) 
     * @param residencyTypeId (optional) 
     * @param professionId (optional) 
     * @param nationalityId (optional) 
     * @param pWD (optional) 
     * @param isPep (optional) 
     * @param customerAddresses (optional) 
     * @param customerExtensions (optional) 
     * @param identities (optional) 
     * @param customerDelegates (optional) 
     * @return Success
     */
    createPerson(branchIdHeader: string | undefined, firstName: string | undefined, secondName: string | undefined, thirdName: string | undefined, lastName: string | undefined, firstNameLang: string | undefined, secondNameLang: string | undefined, thirdNameLang: string | undefined, lastNameLang: string | undefined, phone: string | undefined, email: string | undefined, birthDate: string | undefined, customerSubTypeId: number | undefined, birthPlaceId: number | undefined, genderId: number | undefined, residencyTypeId: number | undefined, professionId: number | undefined, nationalityId: number | undefined, pWD: boolean | undefined, isPep: boolean | undefined, customerAddresses: AddCustomerAddressDto[] | undefined, customerExtensions: AddCustomerExtensionDto[] | undefined, identities: AddCustomerIdentityDto[] | undefined, customerDelegates: AddCustomerDelegateDto[] | undefined, signal?: AbortSignal): Promise<AddCustomerResponseDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/form/CreatePerson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (firstName === null || firstName === undefined)
            throw new Error("The parameter 'firstName' cannot be null.");
        else
            content_.append("FirstName", firstName.toString());
        if (secondName === null || secondName === undefined)
            throw new Error("The parameter 'secondName' cannot be null.");
        else
            content_.append("SecondName", secondName.toString());
        if (thirdName === null || thirdName === undefined)
            throw new Error("The parameter 'thirdName' cannot be null.");
        else
            content_.append("ThirdName", thirdName.toString());
        if (lastName === null || lastName === undefined)
            throw new Error("The parameter 'lastName' cannot be null.");
        else
            content_.append("LastName", lastName.toString());
        if (firstNameLang === null || firstNameLang === undefined)
            throw new Error("The parameter 'firstNameLang' cannot be null.");
        else
            content_.append("FirstNameLang", firstNameLang.toString());
        if (secondNameLang === null || secondNameLang === undefined)
            throw new Error("The parameter 'secondNameLang' cannot be null.");
        else
            content_.append("SecondNameLang", secondNameLang.toString());
        if (thirdNameLang === null || thirdNameLang === undefined)
            throw new Error("The parameter 'thirdNameLang' cannot be null.");
        else
            content_.append("ThirdNameLang", thirdNameLang.toString());
        if (lastNameLang === null || lastNameLang === undefined)
            throw new Error("The parameter 'lastNameLang' cannot be null.");
        else
            content_.append("LastNameLang", lastNameLang.toString());
        if (phone === null || phone === undefined)
            throw new Error("The parameter 'phone' cannot be null.");
        else
            content_.append("Phone", phone.toString());
        if (email === null || email === undefined)
            throw new Error("The parameter 'email' cannot be null.");
        else
            content_.append("Email", email.toString());
        if (birthDate === null || birthDate === undefined)
            throw new Error("The parameter 'birthDate' cannot be null.");
        else
            content_.append("BirthDate", birthDate.toString());
        if (customerSubTypeId === null || customerSubTypeId === undefined)
            throw new Error("The parameter 'customerSubTypeId' cannot be null.");
        else
            content_.append("CustomerSubTypeId", customerSubTypeId.toString());
        if (birthPlaceId === null || birthPlaceId === undefined)
            throw new Error("The parameter 'birthPlaceId' cannot be null.");
        else
            content_.append("BirthPlaceId", birthPlaceId.toString());
        if (genderId === null || genderId === undefined)
            throw new Error("The parameter 'genderId' cannot be null.");
        else
            content_.append("GenderId", genderId.toString());
        if (residencyTypeId === null || residencyTypeId === undefined)
            throw new Error("The parameter 'residencyTypeId' cannot be null.");
        else
            content_.append("ResidencyTypeId", residencyTypeId.toString());
        if (professionId === null || professionId === undefined)
            throw new Error("The parameter 'professionId' cannot be null.");
        else
            content_.append("ProfessionId", professionId.toString());
        if (nationalityId === null || nationalityId === undefined)
            throw new Error("The parameter 'nationalityId' cannot be null.");
        else
            content_.append("NationalityId", nationalityId.toString());
        if (pWD === null || pWD === undefined)
            throw new Error("The parameter 'pWD' cannot be null.");
        else
            content_.append("PWD", pWD.toString());
        if (isPep === null || isPep === undefined)
            throw new Error("The parameter 'isPep' cannot be null.");
        else
            content_.append("IsPep", isPep.toString());
        if (customerAddresses === null || customerAddresses === undefined)
            throw new Error("The parameter 'customerAddresses' cannot be null.");
        else
            customerAddresses.forEach(item_ => content_.append("CustomerAddresses", item_.toString()));
        if (customerExtensions === null || customerExtensions === undefined)
            throw new Error("The parameter 'customerExtensions' cannot be null.");
        else
            customerExtensions.forEach(item_ => content_.append("CustomerExtensions", item_.toString()));
        if (identities === null || identities === undefined)
            throw new Error("The parameter 'identities' cannot be null.");
        else
            identities.forEach(item_ => content_.append("Identities", item_.toString()));
        if (customerDelegates === null || customerDelegates === undefined)
            throw new Error("The parameter 'customerDelegates' cannot be null.");
        else
            customerDelegates.forEach(item_ => content_.append("CustomerDelegates", item_.toString()));

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePerson(_response);
        });
    }

    protected processCreatePerson(response: AxiosResponse): Promise<AddCustomerResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AddCustomerResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddCustomerResponseDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param phone (optional) 
     * @param email (optional) 
     * @param fax (optional) 
     * @param website (optional) 
     * @param establishmentDate (optional) 
     * @param customerSubTypeId (optional) 
     * @param ownershipTypeId (optional) 
     * @param liabilityTypeId (optional) 
     * @param industryId (optional) 
     * @param nationalityId (optional) 
     * @param pWD (optional) 
     * @param isPep (optional) 
     * @param isFI (optional) 
     * @param corporatePartners (optional) 
     * @param customerAddresses (optional) 
     * @param customerExtensions (optional) 
     * @param identities (optional) 
     * @param corporateDelegates (optional) 
     * @param corporateManagers (optional) 
     * @param corporateActivities (optional) 
     * @param activityIds (optional) 
     * @param name (optional) 
     * @param nameLang (optional) 
     * @param description (optional) 
     * @param descriptionLang (optional) 
     * @return Success
     */
    createCorporate(branchIdHeader: string | undefined, phone: string | undefined, email: string | undefined, fax: string | undefined, website: string | undefined, establishmentDate: string | undefined, customerSubTypeId: number | undefined, ownershipTypeId: number | undefined, liabilityTypeId: number | undefined, industryId: number | undefined, nationalityId: number | undefined, pWD: boolean | undefined, isPep: boolean | undefined, isFI: boolean | undefined, corporatePartners: AddCorporatePartnerDto[] | undefined, customerAddresses: AddCustomerAddressDto[] | undefined, customerExtensions: AddCustomerExtensionDto[] | undefined, identities: AddCustomerIdentityDto[] | undefined, corporateDelegates: AddCustomerDelegateDto[] | undefined, corporateManagers: AddCorporateManagerDto[] | undefined, corporateActivities: AddCorporateActivityDto[] | undefined, activityIds: number[] | undefined, name: string | undefined, nameLang: string | undefined, description: string | undefined, descriptionLang: string | undefined, signal?: AbortSignal): Promise<AddCustomerResponseDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/form/CreateCorporate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (phone === null || phone === undefined)
            throw new Error("The parameter 'phone' cannot be null.");
        else
            content_.append("Phone", phone.toString());
        if (email === null || email === undefined)
            throw new Error("The parameter 'email' cannot be null.");
        else
            content_.append("Email", email.toString());
        if (fax === null || fax === undefined)
            throw new Error("The parameter 'fax' cannot be null.");
        else
            content_.append("Fax", fax.toString());
        if (website === null || website === undefined)
            throw new Error("The parameter 'website' cannot be null.");
        else
            content_.append("Website", website.toString());
        if (establishmentDate === null || establishmentDate === undefined)
            throw new Error("The parameter 'establishmentDate' cannot be null.");
        else
            content_.append("EstablishmentDate", establishmentDate.toString());
        if (customerSubTypeId === null || customerSubTypeId === undefined)
            throw new Error("The parameter 'customerSubTypeId' cannot be null.");
        else
            content_.append("CustomerSubTypeId", customerSubTypeId.toString());
        if (ownershipTypeId === null || ownershipTypeId === undefined)
            throw new Error("The parameter 'ownershipTypeId' cannot be null.");
        else
            content_.append("OwnershipTypeId", ownershipTypeId.toString());
        if (liabilityTypeId === null || liabilityTypeId === undefined)
            throw new Error("The parameter 'liabilityTypeId' cannot be null.");
        else
            content_.append("LiabilityTypeId", liabilityTypeId.toString());
        if (industryId === null || industryId === undefined)
            throw new Error("The parameter 'industryId' cannot be null.");
        else
            content_.append("IndustryId", industryId.toString());
        if (nationalityId === null || nationalityId === undefined)
            throw new Error("The parameter 'nationalityId' cannot be null.");
        else
            content_.append("NationalityId", nationalityId.toString());
        if (pWD === null || pWD === undefined)
            throw new Error("The parameter 'pWD' cannot be null.");
        else
            content_.append("PWD", pWD.toString());
        if (isPep === null || isPep === undefined)
            throw new Error("The parameter 'isPep' cannot be null.");
        else
            content_.append("IsPep", isPep.toString());
        if (isFI === null || isFI === undefined)
            throw new Error("The parameter 'isFI' cannot be null.");
        else
            content_.append("IsFI", isFI.toString());
        if (corporatePartners === null || corporatePartners === undefined)
            throw new Error("The parameter 'corporatePartners' cannot be null.");
        else
            corporatePartners.forEach(item_ => content_.append("CorporatePartners", item_.toString()));
        if (customerAddresses === null || customerAddresses === undefined)
            throw new Error("The parameter 'customerAddresses' cannot be null.");
        else
            customerAddresses.forEach(item_ => content_.append("CustomerAddresses", item_.toString()));
        if (customerExtensions === null || customerExtensions === undefined)
            throw new Error("The parameter 'customerExtensions' cannot be null.");
        else
            customerExtensions.forEach(item_ => content_.append("CustomerExtensions", item_.toString()));
        if (identities === null || identities === undefined)
            throw new Error("The parameter 'identities' cannot be null.");
        else
            identities.forEach(item_ => content_.append("Identities", item_.toString()));
        if (corporateDelegates === null || corporateDelegates === undefined)
            throw new Error("The parameter 'corporateDelegates' cannot be null.");
        else
            corporateDelegates.forEach(item_ => content_.append("CorporateDelegates", item_.toString()));
        if (corporateManagers === null || corporateManagers === undefined)
            throw new Error("The parameter 'corporateManagers' cannot be null.");
        else
            corporateManagers.forEach(item_ => content_.append("CorporateManagers", item_.toString()));
        if (corporateActivities === null || corporateActivities === undefined)
            throw new Error("The parameter 'corporateActivities' cannot be null.");
        else
            corporateActivities.forEach(item_ => content_.append("CorporateActivities", item_.toString()));
        if (activityIds === null || activityIds === undefined)
            throw new Error("The parameter 'activityIds' cannot be null.");
        else
            activityIds.forEach(item_ => content_.append("ActivityIds", item_.toString()));
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (nameLang === null || nameLang === undefined)
            throw new Error("The parameter 'nameLang' cannot be null.");
        else
            content_.append("NameLang", nameLang.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (descriptionLang === null || descriptionLang === undefined)
            throw new Error("The parameter 'descriptionLang' cannot be null.");
        else
            content_.append("DescriptionLang", descriptionLang.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCorporate(_response);
        });
    }

    protected processCreateCorporate(response: AxiosResponse): Promise<AddCustomerResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AddCustomerResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddCustomerResponseDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param firstName (optional) 
     * @param secondName (optional) 
     * @param thirdName (optional) 
     * @param lastName (optional) 
     * @param firstNameLang (optional) 
     * @param secondNameLang (optional) 
     * @param thirdNameLang (optional) 
     * @param lastNameLang (optional) 
     * @param phone (optional) 
     * @param email (optional) 
     * @param birthDate (optional) 
     * @param customerSubTypeId (optional) 
     * @param birthPlaceId (optional) 
     * @param genderId (optional) 
     * @param residencyTypeId (optional) 
     * @param professionId (optional) 
     * @param nationalityId (optional) 
     * @param pWD (optional) 
     * @param isPep (optional) 
     * @param id (optional) 
     * @return Success
     */
    updatePerson(branchIdHeader: string | undefined, firstName: string | undefined, secondName: string | undefined, thirdName: string | undefined, lastName: string | undefined, firstNameLang: string | undefined, secondNameLang: string | undefined, thirdNameLang: string | undefined, lastNameLang: string | undefined, phone: string | undefined, email: string | undefined, birthDate: string | undefined, customerSubTypeId: number | undefined, birthPlaceId: number | undefined, genderId: number | undefined, residencyTypeId: number | undefined, professionId: number | undefined, nationalityId: number | undefined, pWD: boolean | undefined, isPep: boolean | undefined, id: number | undefined, signal?: AbortSignal): Promise<UpdatePersonDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/form/UpdatePerson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (firstName === null || firstName === undefined)
            throw new Error("The parameter 'firstName' cannot be null.");
        else
            content_.append("FirstName", firstName.toString());
        if (secondName === null || secondName === undefined)
            throw new Error("The parameter 'secondName' cannot be null.");
        else
            content_.append("SecondName", secondName.toString());
        if (thirdName === null || thirdName === undefined)
            throw new Error("The parameter 'thirdName' cannot be null.");
        else
            content_.append("ThirdName", thirdName.toString());
        if (lastName === null || lastName === undefined)
            throw new Error("The parameter 'lastName' cannot be null.");
        else
            content_.append("LastName", lastName.toString());
        if (firstNameLang === null || firstNameLang === undefined)
            throw new Error("The parameter 'firstNameLang' cannot be null.");
        else
            content_.append("FirstNameLang", firstNameLang.toString());
        if (secondNameLang === null || secondNameLang === undefined)
            throw new Error("The parameter 'secondNameLang' cannot be null.");
        else
            content_.append("SecondNameLang", secondNameLang.toString());
        if (thirdNameLang === null || thirdNameLang === undefined)
            throw new Error("The parameter 'thirdNameLang' cannot be null.");
        else
            content_.append("ThirdNameLang", thirdNameLang.toString());
        if (lastNameLang === null || lastNameLang === undefined)
            throw new Error("The parameter 'lastNameLang' cannot be null.");
        else
            content_.append("LastNameLang", lastNameLang.toString());
        if (phone === null || phone === undefined)
            throw new Error("The parameter 'phone' cannot be null.");
        else
            content_.append("Phone", phone.toString());
        if (email === null || email === undefined)
            throw new Error("The parameter 'email' cannot be null.");
        else
            content_.append("Email", email.toString());
        if (birthDate === null || birthDate === undefined)
            throw new Error("The parameter 'birthDate' cannot be null.");
        else
            content_.append("BirthDate", birthDate.toString());
        if (customerSubTypeId === null || customerSubTypeId === undefined)
            throw new Error("The parameter 'customerSubTypeId' cannot be null.");
        else
            content_.append("CustomerSubTypeId", customerSubTypeId.toString());
        if (birthPlaceId === null || birthPlaceId === undefined)
            throw new Error("The parameter 'birthPlaceId' cannot be null.");
        else
            content_.append("BirthPlaceId", birthPlaceId.toString());
        if (genderId === null || genderId === undefined)
            throw new Error("The parameter 'genderId' cannot be null.");
        else
            content_.append("GenderId", genderId.toString());
        if (residencyTypeId === null || residencyTypeId === undefined)
            throw new Error("The parameter 'residencyTypeId' cannot be null.");
        else
            content_.append("ResidencyTypeId", residencyTypeId.toString());
        if (professionId === null || professionId === undefined)
            throw new Error("The parameter 'professionId' cannot be null.");
        else
            content_.append("ProfessionId", professionId.toString());
        if (nationalityId === null || nationalityId === undefined)
            throw new Error("The parameter 'nationalityId' cannot be null.");
        else
            content_.append("NationalityId", nationalityId.toString());
        if (pWD === null || pWD === undefined)
            throw new Error("The parameter 'pWD' cannot be null.");
        else
            content_.append("PWD", pWD.toString());
        if (isPep === null || isPep === undefined)
            throw new Error("The parameter 'isPep' cannot be null.");
        else
            content_.append("IsPep", isPep.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePerson(_response);
        });
    }

    protected processUpdatePerson(response: AxiosResponse): Promise<UpdatePersonDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdatePersonDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdatePersonDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param phone (optional) 
     * @param email (optional) 
     * @param fax (optional) 
     * @param website (optional) 
     * @param establishmentDate (optional) 
     * @param customerSubTypeId (optional) 
     * @param ownershipTypeId (optional) 
     * @param liabilityTypeId (optional) 
     * @param industryId (optional) 
     * @param nationalityId (optional) 
     * @param pWD (optional) 
     * @param isPep (optional) 
     * @param isFI (optional) 
     * @param corporateActivities (optional) 
     * @param activityIds (optional) 
     * @param name (optional) 
     * @param nameLang (optional) 
     * @param description (optional) 
     * @param descriptionLang (optional) 
     * @param id (optional) 
     * @return Success
     */
    updateCorporate(branchIdHeader: string | undefined, phone: string | undefined, email: string | undefined, fax: string | undefined, website: string | undefined, establishmentDate: string | undefined, customerSubTypeId: number | undefined, ownershipTypeId: number | undefined, liabilityTypeId: number | undefined, industryId: number | undefined, nationalityId: number | undefined, pWD: boolean | undefined, isPep: boolean | undefined, isFI: boolean | undefined, corporateActivities: UpdateCorporateActivityDto[] | undefined, activityIds: number[] | undefined, name: string | undefined, nameLang: string | undefined, description: string | undefined, descriptionLang: string | undefined, id: number | undefined, signal?: AbortSignal): Promise<UpdateCorporateDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/form/UpdateCorporate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (phone === null || phone === undefined)
            throw new Error("The parameter 'phone' cannot be null.");
        else
            content_.append("Phone", phone.toString());
        if (email === null || email === undefined)
            throw new Error("The parameter 'email' cannot be null.");
        else
            content_.append("Email", email.toString());
        if (fax === null || fax === undefined)
            throw new Error("The parameter 'fax' cannot be null.");
        else
            content_.append("Fax", fax.toString());
        if (website === null || website === undefined)
            throw new Error("The parameter 'website' cannot be null.");
        else
            content_.append("Website", website.toString());
        if (establishmentDate === null || establishmentDate === undefined)
            throw new Error("The parameter 'establishmentDate' cannot be null.");
        else
            content_.append("EstablishmentDate", establishmentDate.toString());
        if (customerSubTypeId === null || customerSubTypeId === undefined)
            throw new Error("The parameter 'customerSubTypeId' cannot be null.");
        else
            content_.append("CustomerSubTypeId", customerSubTypeId.toString());
        if (ownershipTypeId === null || ownershipTypeId === undefined)
            throw new Error("The parameter 'ownershipTypeId' cannot be null.");
        else
            content_.append("OwnershipTypeId", ownershipTypeId.toString());
        if (liabilityTypeId === null || liabilityTypeId === undefined)
            throw new Error("The parameter 'liabilityTypeId' cannot be null.");
        else
            content_.append("LiabilityTypeId", liabilityTypeId.toString());
        if (industryId === null || industryId === undefined)
            throw new Error("The parameter 'industryId' cannot be null.");
        else
            content_.append("IndustryId", industryId.toString());
        if (nationalityId === null || nationalityId === undefined)
            throw new Error("The parameter 'nationalityId' cannot be null.");
        else
            content_.append("NationalityId", nationalityId.toString());
        if (pWD === null || pWD === undefined)
            throw new Error("The parameter 'pWD' cannot be null.");
        else
            content_.append("PWD", pWD.toString());
        if (isPep === null || isPep === undefined)
            throw new Error("The parameter 'isPep' cannot be null.");
        else
            content_.append("IsPep", isPep.toString());
        if (isFI === null || isFI === undefined)
            throw new Error("The parameter 'isFI' cannot be null.");
        else
            content_.append("IsFI", isFI.toString());
        if (corporateActivities === null || corporateActivities === undefined)
            throw new Error("The parameter 'corporateActivities' cannot be null.");
        else
            corporateActivities.forEach(item_ => content_.append("CorporateActivities", item_.toString()));
        if (activityIds === null || activityIds === undefined)
            throw new Error("The parameter 'activityIds' cannot be null.");
        else
            activityIds.forEach(item_ => content_.append("ActivityIds", item_.toString()));
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (nameLang === null || nameLang === undefined)
            throw new Error("The parameter 'nameLang' cannot be null.");
        else
            content_.append("NameLang", nameLang.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (descriptionLang === null || descriptionLang === undefined)
            throw new Error("The parameter 'descriptionLang' cannot be null.");
        else
            content_.append("DescriptionLang", descriptionLang.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateCorporate(_response);
        });
    }

    protected processUpdateCorporate(response: AxiosResponse): Promise<UpdateCorporateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCorporateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCorporateDto>(null as any);
    }
}

export class CheckClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    personalInfo(branchIdHeader: string | undefined, body: CheckCustomerPersonalInfoRequestDto | undefined, signal?: AbortSignal): Promise<CheckInfoResponseDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/check/personalInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPersonalInfo(_response);
        });
    }

    protected processPersonalInfo(response: AxiosResponse): Promise<CheckInfoResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CheckInfoResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckInfoResponseDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    customerIdentity(branchIdHeader: string | undefined, body: CheckCustomerIdentityInfoRequestDto | undefined, signal?: AbortSignal): Promise<CheckInfoResponseDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/check/customerIdentity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerIdentity(_response);
        });
    }

    protected processCustomerIdentity(response: AxiosResponse): Promise<CheckInfoResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CheckInfoResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckInfoResponseDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    customerIdentities(branchIdHeader: string | undefined, body: CheckCustomerIdentityInfoListRequestDto | undefined, signal?: AbortSignal): Promise<CheckInfoResponseDto> {
        let url_ = this.baseUrl + "/api/Customer/Customers/check/customerIdentities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerIdentities(_response);
        });
    }

    protected processCustomerIdentities(response: AxiosResponse): Promise<CheckInfoResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CheckInfoResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckInfoResponseDto>(null as any);
    }
}

export class CustomersSearchClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param key (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    searchForProfile(key: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerIdentitySearchModel[]> {
        let url_ = this.baseUrl + "/api/Customer/CustomersSearch/SearchForProfile?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchForProfile(_response);
        });
    }

    protected processSearchForProfile(response: AxiosResponse): Promise<CustomerIdentitySearchModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerIdentitySearchModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerIdentitySearchModel[]>(null as any);
    }

    /**
     * @param key (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    searchForTransaction(key: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerIdentitySearchModel[]> {
        let url_ = this.baseUrl + "/api/Customer/CustomersSearch/SearchForTransaction?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchForTransaction(_response);
        });
    }

    protected processSearchForTransaction(response: AxiosResponse): Promise<CustomerIdentitySearchModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerIdentitySearchModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerIdentitySearchModel[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCustomerIdentityById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerIdentitySearchModel> {
        let url_ = this.baseUrl + "/api/Customer/CustomersSearch/GetCustomerIdentityById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCustomerIdentityById(_response);
        });
    }

    protected processGetCustomerIdentityById(response: AxiosResponse): Promise<CustomerIdentitySearchModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerIdentitySearchModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerIdentitySearchModel>(null as any);
    }
}

export class CustomerSubTypeClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerSubTypeDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerSubType/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CustomerSubTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerSubTypeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerSubTypeDto>(null as any);
    }

    /**
     * @param customerType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(customerType: CustomerTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerSubTypeDto[]> {
        let url_ = this.baseUrl + "/api/Customer/CustomerSubType/GetList?";
        if (customerType === null)
            throw new Error("The parameter 'customerType' cannot be null.");
        else if (customerType !== undefined)
            url_ += "customerType=" + encodeURIComponent("" + customerType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CustomerSubTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerSubTypeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerSubTypeDto[]>(null as any);
    }

    /**
     * @param active (optional) 
     * @param customerType (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, customerType: CustomerTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerSubTypeDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Customer/CustomerSubType/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (customerType === null)
            throw new Error("The parameter 'customerType' cannot be null.");
        else if (customerType !== undefined)
            url_ += "CustomerType=" + encodeURIComponent("" + customerType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<CustomerSubTypeDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerSubTypeDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerSubTypeDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddCustomerSubTypeDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Customer/CustomerSubType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullCustomerSubTypeDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerSubType/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullCustomerSubTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullCustomerSubTypeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullCustomerSubTypeDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateCustomerSubTypeDto | undefined, signal?: AbortSignal): Promise<UpdateCustomerLookupModel> {
        let url_ = this.baseUrl + "/api/Customer/CustomerSubType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCustomerLookupModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCustomerLookupModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCustomerLookupModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Customer/CustomerSubType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Customer/CustomerSubType/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CustomerTypeClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerTypeDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerType/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CustomerTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerTypeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerTypeDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerTypeDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Customer/CustomerType/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<CustomerTypeDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerTypeDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerTypeDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerTypeDto[]> {
        let url_ = this.baseUrl + "/api/Customer/CustomerType/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<CustomerTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerTypeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerTypeDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateCustomerTypeDto | undefined, signal?: AbortSignal): Promise<UpdateCustomerTypeDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomerType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCustomerTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCustomerTypeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCustomerTypeDto>(null as any);
    }
}

export class CustomFieldClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddCustomFieldDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Customer/CustomField/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateCustomFieldDto | undefined, signal?: AbortSignal): Promise<UpdateCustomFieldDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomField/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateCustomFieldDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateCustomFieldDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCustomFieldDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Customer/CustomField/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Customer/CustomField/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomFieldDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomField/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CustomFieldDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomFieldDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomFieldDto>(null as any);
    }

    /**
     * @param code (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getByCode(code: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomFieldDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomField/GetByCode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByCode(_response);
        });
    }

    protected processGetByCode(response: AxiosResponse): Promise<CustomFieldDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomFieldDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomFieldDto>(null as any);
    }

    /**
     * @param customerType (optional) 
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    customFieldList(customerType: CustomerTypes | undefined, usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomFieldDto[]> {
        let url_ = this.baseUrl + "/api/Customer/CustomField/CustomFieldList?";
        if (customerType === null)
            throw new Error("The parameter 'customerType' cannot be null.");
        else if (customerType !== undefined)
            url_ += "CustomerType=" + encodeURIComponent("" + customerType) + "&";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomFieldList(_response);
        });
    }

    protected processCustomFieldList(response: AxiosResponse): Promise<CustomFieldDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomFieldDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomFieldDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullCustomFieldDto> {
        let url_ = this.baseUrl + "/api/Customer/CustomField/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullCustomFieldDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullCustomFieldDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullCustomFieldDto>(null as any);
    }
}

export class GenderClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<GenderDto> {
        let url_ = this.baseUrl + "/api/Customer/Gender/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<GenderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<GenderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GenderDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<GenderDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Customer/Gender/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<GenderDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<GenderDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GenderDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<GenderDto[]> {
        let url_ = this.baseUrl + "/api/Customer/Gender/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<GenderDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<GenderDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GenderDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateGenderDto | undefined, signal?: AbortSignal): Promise<UpdateGenderDto> {
        let url_ = this.baseUrl + "/api/Customer/Gender/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateGenderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateGenderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateGenderDto>(null as any);
    }
}

export class IdentityTypeClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<IdentityTypeDto> {
        let url_ = this.baseUrl + "/api/Customer/IdentityType/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<IdentityTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<IdentityTypeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityTypeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullIdentityTypeDto> {
        let url_ = this.baseUrl + "/api/Customer/IdentityType/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullIdentityTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullIdentityTypeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullIdentityTypeDto>(null as any);
    }

    /**
     * @param customerType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(customerType: CustomerTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<IdentityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Customer/IdentityType/GetList?";
        if (customerType === null)
            throw new Error("The parameter 'customerType' cannot be null.");
        else if (customerType !== undefined)
            url_ += "customerType=" + encodeURIComponent("" + customerType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<IdentityTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<IdentityTypeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityTypeDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddIdentityTypeDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Customer/IdentityType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateIdentityTypeDto | undefined, signal?: AbortSignal): Promise<UpdateIdentityTypeDto> {
        let url_ = this.baseUrl + "/api/Customer/IdentityType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateIdentityTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateIdentityTypeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateIdentityTypeDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Customer/IdentityType/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Customer/IdentityType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export enum ActivityLogAction {
    AMLCheck = "AMLCheck",
    AMLRecheck = "AMLRecheck",
    Block = "Block",
    Release = "Release",
    Escalate = "Escalate",
    Returned = "Returned",
    Comment = "Comment",
    Reassign = "Reassign",
    Case = "Case",
    Create = "Create",
    Edit = "Edit",
    Cancel = "Cancel",
    Refund = "Refund",
    Approve = "Approve",
    Reject = "Reject",
    Cash = "Cash",
}

export interface ActivityLogDto {
    actionDate?: string;
    actionName?: string | null;
    actionBy?: string | null;
    actionById?: number | null;
    assignedTo?: string | null;
    remarks?: string | null;
    status?: string | null;
    transactionType?: string | null;
    referenceNumber?: string | null;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
    attachments?: AttachmentDto[] | null;
}

export interface AddAttachmentDto {
    files?: string[] | null;
}

export interface AddCorporateActivityDto {
    activityId: number;
}

export interface AddCorporateDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    phone: string;
    email?: string | null;
    fax?: string | null;
    website?: string | null;
    establishmentDate: string;
    customerSubTypeId: number;
    ownershipTypeId: number;
    liabilityTypeId: number;
    industryId: number;
    nationalityId: number;
    pwd?: boolean;
    isPep?: boolean;
    isFI?: boolean;
    corporatePartners: AddCorporatePartnerDto[] | null;
    customerAddresses: AddCustomerAddressDto[];
    customerExtensions?: AddCustomerExtensionDto[] | null;
    identities: AddCustomerIdentityDto[];
    corporateDelegates?: AddCustomerDelegateDto[] | null;
    corporateManagers?: AddCorporateManagerDto[] | null;
    activityIds?: number[] | null;
}

export interface AddCorporateManagerDto {
    type?: CustomerRegistrationType;
    fullName?: string | null;
    birthDate?: string | null;
    phone?: string | null;
    address?: string | null;
    nationalityId?: number | null;
    positionId?: number;
    isPep?: boolean;
    customerIdentityId?: number | null;
    addAttachment?: AddAttachmentDto;
    customerIdentity?: AddExternalCustomerIdentityDto;
}

export interface AddCorporatePartnerDto {
    partnershipTypeId: number;
    partnerShare: number;
    type?: CustomerRegistrationType;
    fullName?: string | null;
    nationalityId?: number | null;
    birthDate?: string | null;
    phone?: string | null;
    address?: string | null;
    addAttachment?: AddAttachmentDto;
    customerIdentity?: AddExternalCustomerIdentityDto;
    customerIdentityId?: number | null;
    isPep?: boolean;
}

export interface AddCustomFieldDto {
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    customerType?: CustomFieldCustomerTypes;
    dataType?: DataTypes;
    isRequired?: boolean;
    code: string;
    customFieldLookups?: AddCustomFieldLookupDto[] | null;
}

export interface AddCustomFieldLookupDto {
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    order?: number;
}

export interface AddCustomerAddressDto {
    addressTypeId: number;
    countryId: number;
    cityId: number;
    district: string;
    street: string;
    detailedAddress?: string | null;
    permanentAddress?: string | null;
    building?: string | null;
    poBox?: string | null;
    isMain: boolean;
}

export interface AddCustomerDelegateDto {
    type?: CustomerRegistrationType;
    customerId?: number | null;
    customerIdentityId?: number | null;
    delegationTypeId: number;
    fullName?: string | null;
    nationalityId?: number | null;
    birthDate?: string | null;
    phone?: string | null;
    address?: string | null;
    expiryDate: string;
    isPep?: boolean;
    addAttachment?: AddAttachmentDto;
    customerIdentity?: AddExternalCustomerIdentityDto;
}

export interface AddCustomerExtensionDto {
    customFieldId?: number;
    customFieldValue: string;
}

export interface AddCustomerIdentityDto {
    customerId?: number;
    identityTypeId: number;
    identityNumber?: string | null;
    nationalNo?: string | null;
    issuePlaceId: number;
    issueDate: string;
    expiryDate?: string | null;
    isMain?: boolean;
    addAttachment?: AddAttachmentDto;
}

export interface AddCustomerLookupModel {
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    customerLookupType?: CustomerLookupTypes;
}

export interface AddCustomerResponseDto {
    id?: number;
    status?: CustomerStatuses;
    number?: string | null;
}

export interface AddCustomerSubTypeDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    customerType?: CustomerTypes;
    aliases?: string[] | null;
}

export interface AddExternalCustomerIdentityDto {
    identityTypeId?: number;
    identityNumber?: string | null;
    nationalNo?: string | null;
    issuePlaceId?: number;
    issueDate?: string;
    expiryDate?: string | null;
    addAttachment?: AddAttachmentDto;
}

export interface AddFullCorporateActivityDto {
    activityId?: number;
    customerId?: number;
}

export interface AddFullCustomerAddressDto {
    addressTypeId: number;
    countryId: number;
    cityId: number;
    district: string;
    street: string;
    detailedAddress?: string | null;
    permanentAddress?: string | null;
    building?: string | null;
    poBox?: string | null;
    isMain?: boolean;
    customerId?: number;
}

export interface AddIdentityTypeDto {
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    customerType?: CustomerTypes;
    isThereNationalNo?: boolean;
    isThereExpiry?: boolean;
    isAttachmentRequired?: boolean;
    aliases?: string[] | null;
}

export interface AddPersonDto {
    firstName: string;
    secondName?: string | null;
    thirdName?: string | null;
    lastName: string;
    firstNameLang?: string | null;
    secondNameLang?: string | null;
    thirdNameLang?: string | null;
    lastNameLang?: string | null;
    phone?: string | null;
    email?: string | null;
    birthDate: string;
    customerSubTypeId?: number | null;
    birthPlaceId: number;
    genderId: number;
    residencyTypeId: number;
    professionId: number;
    nationalityId: number;
    pwd?: boolean;
    isPep?: boolean;
    customerAddresses: AddCustomerAddressDto[];
    customerExtensions?: AddCustomerExtensionDto[] | null;
    identities: AddCustomerIdentityDto[];
    customerDelegates?: AddCustomerDelegateDto[] | null;
}

export interface AttachmentDto {
    id?: number;
    files?: FileDto[] | null;
}

export interface BranchDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    phone?: string | null;
    address?: string | null;
    landMark?: string | null;
    email?: string | null;
    active?: boolean;
    companyName?: string | null;
    countryName?: string | null;
    cityName?: string | null;
    managerName?: string | null;
    managerMobile?: string | null;
}

export interface ChangeLookupStatusModel {
    ids?: number[] | null;
    active?: boolean;
    reason?: string | null;
    customerLookupType?: CustomerLookupTypes;
}

export interface ChangeStatusModel {
    ids: number[];
    active: boolean;
    reason?: string | null;
}

export interface CheckCustomerIdentityInfoListRequestDto {
    identities?: CheckCustomerIdentityInfoRequestDto[] | null;
}

export interface CheckCustomerIdentityInfoRequestDto {
    id?: number | null;
    customerId?: number | null;
    identityTypeId?: number;
    identityNumber?: string | null;
    issuePlaceId?: number;
    identityFor?: IdentityFor;
}

export interface CheckCustomerInfoResponseDto {
    id?: number;
    name?: string | null;
    type?: CustomerTypes;
    number?: string | null;
    nationality?: SimpleCountryDto;
    birthDate?: string | null;
    establishmentDate?: string | null;
    identityNumber?: string | null;
}

export interface CheckCustomerPersonalInfoRequestDto {
    customerId?: number | null;
    fullName?: string | null;
    fullNameLang?: string | null;
    firstName?: string | null;
    secondName?: string | null;
    thirdName?: string | null;
    lastName?: string | null;
    firstNameLang?: string | null;
    secondNameLang?: string | null;
    thirdNameLang?: string | null;
    lastNameLang?: string | null;
    nationalityId?: number;
    birthDate?: string | null;
    establishmentDate?: string | null;
}

export interface CheckInfoResponseDto {
    customers?: CheckCustomerInfoResponseDto[] | null;
}

export interface CorporateActivityDto {
    id?: number;
    corporateId?: number;
    activity?: CustomerLookupModel;
    activityId?: number;
}

export interface CorporateActivityDtoIPaginatedList {
    readonly items?: CorporateActivityDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface CorporateManagerDto {
    id?: number;
    type?: CustomerRegistrationType;
    fullName?: string | null;
    birthDate?: string | null;
    phone?: string | null;
    address?: string | null;
    personId?: number | null;
    nationality?: SimpleCountryDto;
    position?: CustomerLookupModel;
    attachment?: AttachmentDto;
    isPep?: boolean;
    customerIdentity?: CustomerIdentityDto;
}

export interface CorporatePartnerDto {
    id?: number;
    personId?: number | null;
    partnerShare?: number;
    type?: CustomerRegistrationType;
    fullName?: string | null;
    birthDate?: string | null;
    phone?: string | null;
    address?: string | null;
    corporateId?: number;
    partnershipType?: CustomerLookupModel;
    partnershipTypeId?: number;
    nationality?: CountryDto;
    nationalityId?: number | null;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
    customerIdentity?: CustomerIdentityDto;
    customerIdentityId?: number | null;
    isPep?: boolean;
}

export interface CorporatePartnerNoAttachmentDto {
    id?: number;
    partnerShare?: number;
    type?: CustomerRegistrationType;
    fullName?: string | null;
    birthDate?: string | null;
    phone?: string | null;
    address?: string | null;
    corporateId?: number;
    personId?: number | null;
    person?: FullPersonNoAttachmentDto;
    partnershipType?: CustomerLookupModel;
    partnershipTypeId?: number;
    nationality?: CountryDto;
    nationalityId?: number | null;
}

export interface CountryDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    iso3Code?: string | null;
    countryCode?: string | null;
    active?: boolean;
    aliases?: string[] | null;
    currencyId?: number;
}

export enum CustomFieldCustomerTypes {
    Person = "Person",
    Corporate = "Corporate",
    Both = "Both",
}

export interface CustomFieldDto {
    id?: number;
    name?: string | null;
    customerType?: CustomFieldCustomerTypes;
    dataType?: DataTypes;
    isRequired?: boolean;
    code?: string | null;
    isCalculated?: boolean;
    formula?: string | null;
    customFieldLookups?: CustomFieldLookupDto[] | null;
    active?: boolean;
}

export interface CustomFieldLookupDto {
    id?: number;
    name?: string | null;
    order?: number;
}

export interface CustomerAddressDto {
    id?: number;
    addressType?: CustomerLookupModel;
    addressTypeId?: number;
    country?: SimpleCountryDto;
    countryId?: number;
    city?: SimpleCityDto;
    cityId?: number;
    district?: string | null;
    street?: string | null;
    detailedAddress?: string | null;
    permanentAddress?: string | null;
    building?: string | null;
    poBox?: string | null;
    isMain?: boolean;
}

export interface CustomerAddressDtoIPaginatedList {
    readonly items?: CustomerAddressDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface CustomerCardTransactionItemModel {
    date?: string;
    number?: string | null;
    branch?: SimpleBranchDto;
    transactionType?: TransactionTypeDto;
    provider?: SimpleProviderLookupDto;
    counterpartyName?: string | null;
    payinAmount?: number;
    payinCurrency?: SimpleCurrencyDto;
    payoutAmount?: number;
    payoutCurrency?: SimpleCurrencyDto;
    transactionStatus?: TransactionStatuses;
}

export interface CustomerCardTransactionModel {
    data?: CustomerCardTransactionItemModel[] | null;
    count?: number;
    total?: number;
}

export interface CustomerDelegateDto {
    id?: number;
    customerId?: number;
    type?: CustomerRegistrationType;
    fullName?: string | null;
    birthDate?: string | null;
    phone?: string | null;
    address?: string | null;
    expiryDate?: string;
    personId?: number | null;
    delegationType?: CustomerLookupModel;
    delegationTypeId?: number;
    nationality?: CountryDto;
    nationalityId?: number | null;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
    customerIdentity?: CustomerIdentityDto;
    customerIdentityId?: number | null;
    isPep?: boolean;
}

export interface CustomerDelegateNoAttachmentDto {
    id?: number;
    corporateId?: number;
    type?: CustomerRegistrationType;
    fullName?: string | null;
    birthDate?: string | null;
    phone?: string | null;
    address?: string | null;
    expiryDate?: string;
    person?: FullPersonNoAttachmentDto;
    personId?: number | null;
    delegationType?: CustomerLookupModel;
    delegationTypeId?: number;
    nationality?: CountryDto;
    nationalityId?: number | null;
}

export interface CustomerDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    number?: string | null;
    riskScore?: number;
    lastComplianceCheck?: string | null;
    type?: CustomerTypes;
    created?: string;
    lastModified?: string | null;
    status?: CustomerStatuses;
    nationality?: CountryDto;
    nationalityId?: number;
    branch?: SimpleBranchDto;
    branchId?: number | null;
    phone?: string | null;
    email?: string | null;
    pwd?: boolean;
    isPep?: boolean;
    isFI?: boolean;
    canBeEdited?: boolean;
    printed?: boolean;
    corporate?: FullCorporateDto;
    person?: FullPersonDto;
    identities?: CustomerSimpleIdentityDto[] | null;
    customerAddresses?: CustomerAddressDto[] | null;
    customerExtensions?: CustomerExtensionDto[] | null;
}

export interface CustomerExtensionDto {
    id?: number;
    customField?: CustomFieldDto;
    customFieldValue?: string | null;
}

export interface CustomerExtensionDtoIPaginatedList {
    readonly items?: CustomerExtensionDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface CustomerIdentityDto {
    id?: number;
    identityType?: IdentityTypeDto;
    identityTypeId?: number;
    attachment?: AttachmentDto;
    attachmentId?: number;
    identityNumber?: string | null;
    nationalNo?: string | null;
    issuePlace?: SimpleCountryDto;
    issuePlaceId?: number;
    issueDate?: string;
    expiryDate?: string;
    isMain?: boolean;
}

export interface CustomerIdentityLookupDto {
    identityType?: IdentityTypeDto;
    identityNumber?: string | null;
    nationalNo?: string | null;
    expiryDate?: string;
}

export interface CustomerIdentitySearchModel {
    id?: number;
    customerId?: number;
    customerName?: string | null;
    customerNumber?: string | null;
    customerType?: CustomerTypes;
    customerAddress?: string | null;
    nationality?: CountryDto;
    date?: string;
    phone?: string | null;
    identityFor?: IdentityFor;
    identityType?: string | null;
    identityNumber?: string | null;
    isExpired?: boolean;
    expiryDate?: string | null;
    isMain?: boolean;
    viewUIRCode?: boolean;
    industry?: CustomerLookupModel;
    delegateCustomerIdentity?: DelegateCustomerIdentity;
}

export interface CustomerListDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    number?: string | null;
    riskScore?: number;
    lastComplianceCheck?: string | null;
    type?: CustomerTypes;
    created?: string;
    lastModified?: string | null;
    status?: CustomerStatuses;
    nationality?: CountryDto;
    branch?: SimpleBranchDto;
    phone?: string | null;
    email?: string | null;
    pwd?: boolean;
    isPep?: boolean;
    isFI?: boolean;
    profession?: string | null;
    birthDate?: string;
    printed?: boolean;
    mainIdentity?: CustomerIdentityLookupDto;
}

export interface CustomerListDtoIPaginatedList {
    readonly items?: CustomerListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface CustomerLookupModel {
    id?: number;
    name?: string | null;
    active?: boolean;
}

export enum CustomerLookupTypes {
    Activity = "Activity",
    AddressType = "AddressType",
    DelegationType = "DelegationType",
    Gender = "Gender",
    Industry = "Industry",
    LiabilityType = "LiabilityType",
    OwnershipType = "OwnershipType",
    PartnershipType = "PartnershipType",
    Profession = "Profession",
    ResidencyType = "ResidencyType",
    Position = "Position",
}

export enum CustomerRegistrationType {
    ExistingCustomer = "ExistingCustomer",
    NotCustomer = "NotCustomer",
}

export interface CustomerScreeningResult {
    riskScore?: number | null;
    status?: CustomerStatuses;
    isScreeningDone?: boolean;
    message?: string | null;
}

export interface CustomerSimpleIdentityDto {
    id?: number;
    identityType?: IdentityTypeDto;
    identityTypeId?: number;
    identityTypeName?: string | null;
    identityNumber?: string | null;
    nationalNo?: string | null;
    issuePlace?: SimpleCountryDto;
    issuePlaceId?: number;
    issueDate?: string;
    expiryDate?: string;
    isMain?: boolean;
}

export enum CustomerStatuses {
    PendingForCompliance = "PendingForCompliance",
    Active = "Active",
    Blocked = "Blocked",
    Disabled = "Disabled",
    PendingForEdit = "PendingForEdit",
}

export interface CustomerSubTypeDto {
    id?: number;
    name?: string | null;
    customerType?: CustomerTypes;
    active?: boolean;
    aliases?: string[] | null;
}

export interface CustomerSubTypeDtoIPaginatedList {
    readonly items?: CustomerSubTypeDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface CustomerTypeDto {
    id?: number;
    name?: string | null;
    aliases?: string[] | null;
}

export interface CustomerTypeDtoIPaginatedList {
    readonly items?: CustomerTypeDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum CustomerTypes {
    Person = "Person",
    Corporate = "Corporate",
}

export interface CustomersReportModel {
    id?: number;
    created?: string;
    name?: string | null;
    type?: CustomerTypes;
    status?: CustomerStatuses;
    nationality?: CountryDto;
    birthDate?: string;
    birthPlace?: CountryDto;
    identity?: string | null;
    residencyType?: string | null;
    address?: string | null;
    phone?: string | null;
    profession?: string | null;
    branch?: BranchDto;
    number?: string | null;
}

export interface CustomersReportModelIPaginatedList {
    readonly items?: CustomersReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum DataTypes {
    Text = "Text",
    TextArea = "TextArea",
    SecureText = "SecureText",
    Number = "Number",
    Decimal = "Decimal",
    Percentage = "Percentage",
    DateOnly = "DateOnly",
    TimeOnly = "TimeOnly",
    DateTime = "DateTime",
    ScreeningResult = "ScreeningResult",
    Boolean = "Boolean",
    CustomLookup = "CustomLookup",
    Country = "Country",
    CustomerType = "CustomerType",
    CustomerSubType = "CustomerSubType",
    Purpose = "Purpose",
    Currency = "Currency",
    Activity = "Activity",
    Nationality = "Nationality",
    IdentityType = "IdentityType",
    SourceOfFund = "SourceOfFund",
    DeliveryMethod = "DeliveryMethod",
    Relation = "Relation",
    AddressType = "AddressType",
    DelegationType = "DelegationType",
    Gender = "Gender",
    Industry = "Industry",
    LiabilityType = "LiabilityType",
    OwnershipType = "OwnershipType",
    PartnershipType = "PartnershipType",
    Profession = "Profession",
    ResidencyType = "ResidencyType",
    Product = "Product",
    CustomerStatus = "CustomerStatus",
    Channel = "Channel",
    PaymentMode = "PaymentMode",
    Account = "Account",
    AggregateAccount = "AggregateAccount",
    JournalAccount = "JournalAccount",
    DeltaScreening = "DeltaScreening",
}

export interface DelegateCustomerIdentity {
    id?: number;
    name?: string | null;
    number?: string | null;
    type?: CustomerTypes;
    address?: string | null;
    nationality?: CountryDto;
    date?: string;
    phone?: string | null;
    identityType?: string | null;
    identityNumber?: string | null;
    isExpired?: boolean;
    expiryDate?: string | null;
    isMain?: boolean;
}

export interface FileDto {
    id?: number;
    name?: string | null;
    extension?: string | null;
    link?: string | null;
    created?: string;
}

export interface FullCorporateDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    phone?: string | null;
    email?: string | null;
    fax?: string | null;
    website?: string | null;
    establishmentDate?: string;
    customerSubTypeId?: number | null;
    ownershipTypeId?: number;
    liabilityTypeId?: number;
    industryId?: number;
    nationalityId?: number;
    pwd?: boolean;
    isPep?: boolean;
    isFI?: boolean;
    activityIds?: number[] | null;
    customerSubTypeName?: string | null;
    nationalityName?: string | null;
    ownershipType?: CustomerLookupModel;
    liabilityType?: CustomerLookupModel;
    industry?: CustomerLookupModel;
    corporatePartners?: CorporatePartnerNoAttachmentDto[] | null;
    corporateDelegates?: CustomerDelegateNoAttachmentDto[] | null;
    corporateActivities?: CorporateActivityDto[] | null;
}

export interface FullCustomFieldDto {
    id?: number;
    customerType?: CustomFieldCustomerTypes;
    dataType?: DataTypes;
    name?: string | null;
    nameLang?: string | null;
    isRequired?: boolean;
    isCalculated?: boolean;
    formula?: string | null;
    code?: string | null;
    active?: boolean;
    customFieldLookups?: FullCustomFieldLookupDto[] | null;
}

export interface FullCustomFieldLookupDto {
    name?: string | null;
    nameLang?: string | null;
    order?: number;
}

export interface FullCustomerDto {
    id?: number;
    name?: string | null;
    number?: string | null;
    riskScore?: number;
    lastComplianceCheck?: string | null;
    type?: CustomerTypes;
    created?: string;
    lastModified?: string | null;
    status?: CustomerStatuses;
    nationality?: CountryDto;
    nationalityId?: number;
    branch?: SimpleBranchDto;
    branchId?: number | null;
    phone?: string | null;
    email?: string | null;
    pwd?: boolean;
    isPep?: boolean;
    isFI?: boolean;
    canBeEdited?: boolean;
    printed?: boolean;
    corporate?: FullCorporateDto;
    person?: FullPersonDto;
    identities?: CustomerSimpleIdentityDto[] | null;
    customerAddresses?: CustomerAddressDto[] | null;
    customerExtensions?: CustomerExtensionDto[] | null;
    nameLang?: string | null;
}

export interface FullCustomerLookupModel {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    active?: boolean;
}

export interface FullCustomerSubTypeDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    customerType?: CustomerTypes;
    aliases?: string[] | null;
    active?: boolean;
}

export interface FullIdentityTypeDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    customerType?: CustomerTypes;
    isThereNationalNo?: boolean;
    isThereExpiry?: boolean;
    isAttachmentRequired?: boolean;
    aliases?: string[] | null;
    active?: boolean;
}

export interface FullPersonDto {
    id?: number;
    firstName?: string | null;
    secondName?: string | null;
    thirdName?: string | null;
    lastName?: string | null;
    firstNameLang?: string | null;
    secondNameLang?: string | null;
    thirdNameLang?: string | null;
    lastNameLang?: string | null;
    phone?: string | null;
    email?: string | null;
    birthDate?: string;
    customerSubTypeId?: number | null;
    birthPlaceId?: number;
    genderId?: number;
    residencyTypeId?: number;
    professionId?: number;
    nationalityId?: number;
    pwd?: boolean;
    isPep?: boolean;
    birthPlace?: CountryDto;
    gender?: CustomerLookupModel;
    residencyType?: CustomerLookupModel;
    profession?: CustomerLookupModel;
    customerSubTypeName?: string | null;
}

export interface FullPersonNoAttachmentDto {
    id?: number;
    name?: string | null;
    firstName?: string | null;
    secondName?: string | null;
    thirdName?: string | null;
    lastName?: string | null;
    firstNameLang?: string | null;
    secondNameLang?: string | null;
    thirdNameLang?: string | null;
    lastNameLang?: string | null;
    birthDate?: string;
    birthPlaceId?: number;
    genderId?: number;
    residencyTypeId?: number;
    professionId?: number;
    professionName?: string | null;
    nationalityId?: number;
    nationalityName?: string | null;
    customerSubTypeId?: number | null;
    customerSubTypeName?: string | null;
    phone?: string | null;
    email?: string | null;
    isPep?: boolean;
    pwd?: boolean;
    addresses?: CustomerAddressDto[] | null;
    identities?: CustomerSimpleIdentityDto[] | null;
    birthPlace?: CountryDto;
    gender?: CustomerLookupModel;
    residencyType?: CustomerLookupModel;
    profession?: CustomerLookupModel;
}

export interface GenderDto {
    id?: number;
    name?: string | null;
    aliases?: string[] | null;
}

export interface GenderDtoIPaginatedList {
    readonly items?: GenderDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum IdentityFor {
    Customer = "Customer",
    Delegate = "Delegate",
    Partner = "Partner",
    Manager = "Manager",
}

export interface IdentityReportItemModel {
    identityFor?: IdentityFor;
    customer?: string | null;
    representative?: string | null;
    attachment?: AttachmentDto;
}

export interface IdentityReportModel {
    id?: number;
    customerId?: number;
    identityType?: IdentityTypeDto;
    identityNumber?: string | null;
    nationalNo?: string | null;
    isMain?: boolean;
    issuePlace?: SimpleCountryDto;
    issueDate?: string;
    expiryDate?: string | null;
    status?: IdentityStatuses;
    attachment?: AttachmentDto;
    items?: IdentityReportItemModel[] | null;
}

export interface IdentityReportModelIPaginatedList {
    readonly items?: IdentityReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum IdentityStatuses {
    Active = "Active",
    Expired = "Expired",
}

export interface IdentityTypeDto {
    id?: number;
    name?: string | null;
    active?: boolean;
    customerType?: CustomerTypes;
    isThereNationalNo?: boolean;
    isThereExpiry?: boolean;
    isAttachmentRequired?: boolean;
    aliases?: string[] | null;
}

export enum ProviderTypes {
    Online = "Online",
    Offline = "Offline",
    Manual = "Manual",
}

export interface RecheckCustomerDto {
    customerId?: number;
    ignoreInterval?: boolean;
}

export interface ReleaseBlockToggleModel {
    id?: number;
    remark?: string | null;
}

export enum ReportTypes {
    Pdf = "Pdf",
    Excel = "Excel",
}

export interface SetCustomerExtensionDto {
    customerId?: number;
    fields?: AddCustomerExtensionDto[] | null;
}

export enum SettlementTypes {
    Stock = "Stock",
    Deposit = "Deposit",
}

export interface SimpleBranchDto {
    id?: number;
    name?: string | null;
    code?: string | null;
}

export interface SimpleCityDto {
    id?: number;
    name?: string | null;
}

export interface SimpleCountryDto {
    id?: number;
    name?: string | null;
}

export interface SimpleCurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
}

export interface SimpleProviderLookupDto {
    id?: number;
    name?: string | null;
    integrationType?: ProviderTypes;
    settlementType?: SettlementTypes;
    supportedTransaction?: SupportedTransactions;
}

export enum SupportedTransactions {
    Send = "Send",
    Receive = "Receive",
    Both = "Both",
}

export enum TimePeriods {
    OneDay = "OneDay",
    OneWeek = "OneWeek",
    OneMonth = "OneMonth",
    MonthAndHalf = "MonthAndHalf",
    ThreeMonths = "ThreeMonths",
    HalfYear = "HalfYear",
    Year = "Year",
}

export enum TransactionStatuses {
    PendingForCompliance = "PendingForCompliance",
    Blocked = "Blocked",
    PendingForCash = "PendingForCash",
    Completed = "Completed",
    PendingForCancel = "PendingForCancel",
    Canceled = "Canceled",
    PendingForRefund = "PendingForRefund",
    Refunded = "Refunded",
    ReadyForDelivery = "ReadyForDelivery",
    Delivered = "Delivered",
    PendingForEdit = "PendingForEdit",
    BlockedForRefund = "BlockedForRefund",
    BlockedForReserve = "BlockedForReserve",
    PendingForApproval = "PendingForApproval",
    Rejected = "Rejected",
    PendingForSenderApproval = "PendingForSenderApproval",
    PendingForReceiverApproval = "PendingForReceiverApproval",
    PendingForSenderCash = "PendingForSenderCash",
    PendingForReceiverCash = "PendingForReceiverCash",
    ComplianceProcessing = "ComplianceProcessing",
}

export interface TransactionTypeDto {
    id?: number;
    name?: string | null;
}

export interface UpdateAttachmentDto {
    id?: number;
    removedIds?: number[] | null;
    files?: string[] | null;
}

export interface UpdateCorporateActivityDto {
    id?: number;
    activityId?: number;
}

export interface UpdateCorporateBasicInformationDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    phone?: string | null;
    email?: string | null;
    fax?: string | null;
    website?: string | null;
    establishmentDate?: string;
    customerSubTypeId?: number | null;
    ownershipTypeId?: number;
    liabilityTypeId?: number;
    industryId?: number;
    nationalityId?: number;
    pwd?: boolean;
    isPep?: boolean;
    isFI?: boolean;
    activityIds?: number[] | null;
}

export interface UpdateCorporateDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    phone: string;
    email?: string | null;
    fax?: string | null;
    website?: string | null;
    establishmentDate: string;
    customerSubTypeId: number;
    ownershipTypeId: number;
    liabilityTypeId: number;
    industryId: number;
    nationalityId: number;
    pwd?: boolean;
    isPep?: boolean;
    isFI?: boolean;
    activityIds?: number[] | null;
}

export interface UpdateCustomFieldDto {
    id: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    customerType?: CustomFieldCustomerTypes;
    dataType?: DataTypes;
    isRequired?: boolean;
    code: string;
    customFieldLookups?: AddCustomFieldLookupDto[] | null;
}

export interface UpdateCustomerAddressDto {
    id?: number;
    addressTypeId?: number;
    countryId?: number;
    cityId?: number;
    district?: string | null;
    street?: string | null;
    detailedAddress?: string | null;
    permanentAddress?: string | null;
    building?: string | null;
    poBox?: string | null;
    isMain?: boolean;
}

export interface UpdateCustomerDelegateDto {
    id?: number;
    customerId?: number | null;
    delegationTypeId: number;
    fullName?: string | null;
    nationalityId?: number | null;
    birthDate?: string | null;
    phone?: string | null;
    address?: string | null;
    expiryDate: string;
    isPep?: boolean;
    attachment?: UpdateAttachmentDto;
    customerIdentity?: UpdateExternalCustomerIdentityDto;
}

export interface UpdateCustomerIdentityDto {
    id?: number;
    identityTypeId?: number;
    identityNumber?: string | null;
    nationalNo?: string | null;
    issuePlaceId: number;
    issueDate: string;
    expiryDate?: string | null;
    isMain?: boolean;
    attachment?: UpdateAttachmentDto;
}

export interface UpdateCustomerLookupModel {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    customerLookupType?: CustomerLookupTypes;
}

export interface UpdateCustomerSubTypeDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    customerType?: CustomerTypes;
    aliases?: string[] | null;
}

export interface UpdateCustomerTypeDto {
    id?: number;
    aliases?: string[] | null;
}

export interface UpdateExternalCustomerIdentityDto {
    identityTypeId?: number;
    identityNumber?: string | null;
    nationalNo?: string | null;
    issuePlaceId?: number;
    issueDate?: string;
    expiryDate?: string | null;
    attachment?: UpdateAttachmentDto;
}

export interface UpdateGenderDto {
    id?: number;
    aliases?: string[] | null;
}

export interface UpdateIdentityTypeDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    customerType?: CustomerTypes;
    isThereNationalNo?: boolean;
    isThereExpiry?: boolean;
    isAttachmentRequired?: boolean;
    aliases?: string[] | null;
}

export interface UpdatePersonBasicInformationDto {
    id?: number;
    firstName?: string | null;
    secondName?: string | null;
    thirdName?: string | null;
    lastName?: string | null;
    firstNameLang?: string | null;
    secondNameLang?: string | null;
    thirdNameLang?: string | null;
    lastNameLang?: string | null;
    phone?: string | null;
    email?: string | null;
    birthDate?: string;
    customerSubTypeId?: number | null;
    birthPlaceId?: number;
    genderId?: number;
    residencyTypeId?: number;
    professionId?: number;
    nationalityId?: number;
    pwd?: boolean;
    isPep?: boolean;
}

export interface UpdatePersonDto {
    id: number;
    firstName: string;
    secondName?: string | null;
    thirdName?: string | null;
    lastName: string;
    firstNameLang?: string | null;
    secondNameLang?: string | null;
    thirdNameLang?: string | null;
    lastNameLang?: string | null;
    phone: string;
    email?: string | null;
    birthDate: string;
    customerSubTypeId?: number | null;
    birthPlaceId: number;
    genderId: number;
    residencyTypeId: number;
    professionId: number;
    nationalityId: number;
    pwd?: boolean;
    isPep?: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}