//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class CurrencyExchangeClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeCurrencyDto> {
        let url_ = this.baseUrl + "/api/FCExchange/CurrencyExchange/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ExchangeCurrencyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeCurrencyDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeCurrencyDto>(null as any);
    }

    /**
     * @param name (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(name: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/FCExchange/CurrencyExchange/GetList?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<ExchangeCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeCurrencyDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateExchange(branchIdHeader: string | undefined, body: number[] | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/FCExchange/CurrencyExchange/UpdateExchange";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateExchange(_response);
        });
    }

    protected processUpdateExchange(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param name (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookups(name: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/FCExchange/CurrencyExchange/GetLookups?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookups(_response);
        });
    }

    protected processGetLookups(response: AxiosResponse): Promise<SimpleCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleCurrencyDto[]>(null as any);
    }
}

export class CurrencySwapClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SwapCurrencyDto> {
        let url_ = this.baseUrl + "/api/FCExchange/CurrencySwap/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<SwapCurrencyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SwapCurrencyDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwapCurrencyDto>(null as any);
    }

    /**
     * @param name (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(name: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SwapCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/FCExchange/CurrencySwap/GetList?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<SwapCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SwapCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwapCurrencyDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateExchange(branchIdHeader: string | undefined, body: number[] | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/FCExchange/CurrencySwap/UpdateExchange";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateExchange(_response);
        });
    }

    protected processUpdateExchange(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getAvaliableCurrenciesLookups(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/FCExchange/CurrencySwap/GetAvaliableCurrenciesLookups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAvaliableCurrenciesLookups(_response);
        });
    }

    protected processGetAvaliableCurrenciesLookups(response: AxiosResponse): Promise<SimpleCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleCurrencyDto[]>(null as any);
    }
}

export class ExchangeRatesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeRateDto> {
        let url_ = this.baseUrl + "/api/FCExchange/ExchangeRates/GetToUpdate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<ExchangeRateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeRateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeRateDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getApproved(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeRateDto> {
        let url_ = this.baseUrl + "/api/FCExchange/ExchangeRates/GetApproved";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetApproved(_response);
        });
    }

    protected processGetApproved(response: AxiosResponse): Promise<ExchangeRateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeRateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeRateDto>(null as any);
    }

    /**
     * @param versionId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getArchived(versionId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeRateDto> {
        let url_ = this.baseUrl + "/api/FCExchange/ExchangeRates/GetArchived?";
        if (versionId === null)
            throw new Error("The parameter 'versionId' cannot be null.");
        else if (versionId !== undefined)
            url_ += "versionId=" + encodeURIComponent("" + versionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetArchived(_response);
        });
    }

    protected processGetArchived(response: AxiosResponse): Promise<ExchangeRateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeRateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeRateDto>(null as any);
    }

    /**
     * @param branchesIds (optional) 
     * @param created (optional) 
     * @param statuses (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getVersionsList(branchesIds: number[] | undefined, created: string | undefined, statuses: ExchangeRateStatuses[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<BranchExchangeRateVersionsDto[]> {
        let url_ = this.baseUrl + "/api/FCExchange/ExchangeRates/GetVersionsList?";
        if (branchesIds === null)
            throw new Error("The parameter 'branchesIds' cannot be null.");
        else if (branchesIds !== undefined)
            branchesIds && branchesIds.forEach(item => { url_ += "BranchesIds=" + encodeURIComponent("" + item) + "&"; });
        if (created === null)
            throw new Error("The parameter 'created' cannot be null.");
        else if (created !== undefined)
            url_ += "Created=" + encodeURIComponent("" + created) + "&";
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVersionsList(_response);
        });
    }

    protected processGetVersionsList(response: AxiosResponse): Promise<BranchExchangeRateVersionsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BranchExchangeRateVersionsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BranchExchangeRateVersionsDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateExchangeRateDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/FCExchange/ExchangeRates/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeRateDto> {
        let url_ = this.baseUrl + "/api/FCExchange/ExchangeRates/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ExchangeRateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeRateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeRateDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    copyToDraft(branchIdHeader: string | undefined, body: number | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/FCExchange/ExchangeRates/CopyToDraft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCopyToDraft(_response);
        });
    }

    protected processCopyToDraft(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    saveDraftToArchive(branchIdHeader: string | undefined, body: number[] | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/FCExchange/ExchangeRates/SaveDraftToArchive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveDraftToArchive(_response);
        });
    }

    protected processSaveDraftToArchive(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    approve(branchIdHeader: string | undefined, body: number[] | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/FCExchange/ExchangeRates/Approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApprove(_response);
        });
    }

    protected processApprove(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getExchangeRateBranches(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeRateApprovedBranchDto[]> {
        let url_ = this.baseUrl + "/api/FCExchange/ExchangeRates/GetExchangeRateBranches?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExchangeRateBranches(_response);
        });
    }

    protected processGetExchangeRateBranches(response: AxiosResponse): Promise<ExchangeRateApprovedBranchDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeRateApprovedBranchDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeRateApprovedBranchDto[]>(null as any);
    }
}

export class ReportClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param userIds (optional) 
     * @param sellCurrencyIds (optional) 
     * @param sellAmount_From (optional) 
     * @param sellAmount_To (optional) 
     * @param buyCurrencyIds (optional) 
     * @param buyAmount_From (optional) 
     * @param buyAmount_To (optional) 
     * @param statuses (optional) 
     * @param customerName (optional) 
     * @param pWD (optional) 
     * @param isPep (optional) 
     * @param isFI (optional) 
     * @param customerType (optional) 
     * @param customerSubTypeIds (optional) 
     * @param branchIds (optional) 
     * @param industryIds (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    saleAndPurchaseReport(date_From: string | undefined, date_To: string | undefined, userIds: number[] | undefined, sellCurrencyIds: number[] | undefined, sellAmount_From: number | undefined, sellAmount_To: number | undefined, buyCurrencyIds: number[] | undefined, buyAmount_From: number | undefined, buyAmount_To: number | undefined, statuses: TransactionStatuses[] | undefined, customerName: string | undefined, pWD: boolean | undefined, isPep: boolean | undefined, isFI: boolean | undefined, customerType: CustomerTypes | undefined, customerSubTypeIds: number[] | undefined, branchIds: number[] | undefined, industryIds: number[] | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SaleAndPurchaseReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/FCExchange/Report/SaleAndPurchaseReport?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "UserIds=" + encodeURIComponent("" + item) + "&"; });
        if (sellCurrencyIds === null)
            throw new Error("The parameter 'sellCurrencyIds' cannot be null.");
        else if (sellCurrencyIds !== undefined)
            sellCurrencyIds && sellCurrencyIds.forEach(item => { url_ += "SellCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (sellAmount_From === null)
            throw new Error("The parameter 'sellAmount_From' cannot be null.");
        else if (sellAmount_From !== undefined)
            url_ += "SellAmount.From=" + encodeURIComponent("" + sellAmount_From) + "&";
        if (sellAmount_To === null)
            throw new Error("The parameter 'sellAmount_To' cannot be null.");
        else if (sellAmount_To !== undefined)
            url_ += "SellAmount.To=" + encodeURIComponent("" + sellAmount_To) + "&";
        if (buyCurrencyIds === null)
            throw new Error("The parameter 'buyCurrencyIds' cannot be null.");
        else if (buyCurrencyIds !== undefined)
            buyCurrencyIds && buyCurrencyIds.forEach(item => { url_ += "BuyCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (buyAmount_From === null)
            throw new Error("The parameter 'buyAmount_From' cannot be null.");
        else if (buyAmount_From !== undefined)
            url_ += "BuyAmount.From=" + encodeURIComponent("" + buyAmount_From) + "&";
        if (buyAmount_To === null)
            throw new Error("The parameter 'buyAmount_To' cannot be null.");
        else if (buyAmount_To !== undefined)
            url_ += "BuyAmount.To=" + encodeURIComponent("" + buyAmount_To) + "&";
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (pWD === null)
            throw new Error("The parameter 'pWD' cannot be null.");
        else if (pWD !== undefined)
            url_ += "PWD=" + encodeURIComponent("" + pWD) + "&";
        if (isPep === null)
            throw new Error("The parameter 'isPep' cannot be null.");
        else if (isPep !== undefined)
            url_ += "IsPep=" + encodeURIComponent("" + isPep) + "&";
        if (isFI === null)
            throw new Error("The parameter 'isFI' cannot be null.");
        else if (isFI !== undefined)
            url_ += "IsFI=" + encodeURIComponent("" + isFI) + "&";
        if (customerType === null)
            throw new Error("The parameter 'customerType' cannot be null.");
        else if (customerType !== undefined)
            url_ += "CustomerType=" + encodeURIComponent("" + customerType) + "&";
        if (customerSubTypeIds === null)
            throw new Error("The parameter 'customerSubTypeIds' cannot be null.");
        else if (customerSubTypeIds !== undefined)
            customerSubTypeIds && customerSubTypeIds.forEach(item => { url_ += "CustomerSubTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (industryIds === null)
            throw new Error("The parameter 'industryIds' cannot be null.");
        else if (industryIds !== undefined)
            industryIds && industryIds.forEach(item => { url_ += "IndustryIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaleAndPurchaseReport(_response);
        });
    }

    protected processSaleAndPurchaseReport(response: AxiosResponse): Promise<SaleAndPurchaseReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SaleAndPurchaseReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaleAndPurchaseReportModelIPaginatedList>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param userIds (optional) 
     * @param sellCurrencyIds (optional) 
     * @param sellAmount_From (optional) 
     * @param sellAmount_To (optional) 
     * @param buyCurrencyIds (optional) 
     * @param buyAmount_From (optional) 
     * @param buyAmount_To (optional) 
     * @param statuses (optional) 
     * @param customerName (optional) 
     * @param pWD (optional) 
     * @param isPep (optional) 
     * @param isFI (optional) 
     * @param customerType (optional) 
     * @param customerSubTypeIds (optional) 
     * @param branchIds (optional) 
     * @param industryIds (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportSaleAndPurchaseReport(date_From: string | undefined, date_To: string | undefined, userIds: number[] | undefined, sellCurrencyIds: number[] | undefined, sellAmount_From: number | undefined, sellAmount_To: number | undefined, buyCurrencyIds: number[] | undefined, buyAmount_From: number | undefined, buyAmount_To: number | undefined, statuses: TransactionStatuses[] | undefined, customerName: string | undefined, pWD: boolean | undefined, isPep: boolean | undefined, isFI: boolean | undefined, customerType: CustomerTypes | undefined, customerSubTypeIds: number[] | undefined, branchIds: number[] | undefined, industryIds: number[] | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/FCExchange/Report/ExportSaleAndPurchaseReport?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "UserIds=" + encodeURIComponent("" + item) + "&"; });
        if (sellCurrencyIds === null)
            throw new Error("The parameter 'sellCurrencyIds' cannot be null.");
        else if (sellCurrencyIds !== undefined)
            sellCurrencyIds && sellCurrencyIds.forEach(item => { url_ += "SellCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (sellAmount_From === null)
            throw new Error("The parameter 'sellAmount_From' cannot be null.");
        else if (sellAmount_From !== undefined)
            url_ += "SellAmount.From=" + encodeURIComponent("" + sellAmount_From) + "&";
        if (sellAmount_To === null)
            throw new Error("The parameter 'sellAmount_To' cannot be null.");
        else if (sellAmount_To !== undefined)
            url_ += "SellAmount.To=" + encodeURIComponent("" + sellAmount_To) + "&";
        if (buyCurrencyIds === null)
            throw new Error("The parameter 'buyCurrencyIds' cannot be null.");
        else if (buyCurrencyIds !== undefined)
            buyCurrencyIds && buyCurrencyIds.forEach(item => { url_ += "BuyCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (buyAmount_From === null)
            throw new Error("The parameter 'buyAmount_From' cannot be null.");
        else if (buyAmount_From !== undefined)
            url_ += "BuyAmount.From=" + encodeURIComponent("" + buyAmount_From) + "&";
        if (buyAmount_To === null)
            throw new Error("The parameter 'buyAmount_To' cannot be null.");
        else if (buyAmount_To !== undefined)
            url_ += "BuyAmount.To=" + encodeURIComponent("" + buyAmount_To) + "&";
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (pWD === null)
            throw new Error("The parameter 'pWD' cannot be null.");
        else if (pWD !== undefined)
            url_ += "PWD=" + encodeURIComponent("" + pWD) + "&";
        if (isPep === null)
            throw new Error("The parameter 'isPep' cannot be null.");
        else if (isPep !== undefined)
            url_ += "IsPep=" + encodeURIComponent("" + isPep) + "&";
        if (isFI === null)
            throw new Error("The parameter 'isFI' cannot be null.");
        else if (isFI !== undefined)
            url_ += "IsFI=" + encodeURIComponent("" + isFI) + "&";
        if (customerType === null)
            throw new Error("The parameter 'customerType' cannot be null.");
        else if (customerType !== undefined)
            url_ += "CustomerType=" + encodeURIComponent("" + customerType) + "&";
        if (customerSubTypeIds === null)
            throw new Error("The parameter 'customerSubTypeIds' cannot be null.");
        else if (customerSubTypeIds !== undefined)
            customerSubTypeIds && customerSubTypeIds.forEach(item => { url_ += "CustomerSubTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (industryIds === null)
            throw new Error("The parameter 'industryIds' cannot be null.");
        else if (industryIds !== undefined)
            industryIds && industryIds.forEach(item => { url_ += "IndustryIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportSaleAndPurchaseReport(_response);
        });
    }

    protected processExportSaleAndPurchaseReport(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class TransactionsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param searchKey (optional) 
     * @param number (optional) 
     * @param customerName (optional) 
     * @param note (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param statuses (optional) 
     * @param types (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(searchKey: string | undefined, number: string | undefined, customerName: string | undefined, note: string | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, statuses: TransactionStatuses[] | undefined, types: TransactionTypes[] | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeTransactionListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/GetPaginatedList?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (note === null)
            throw new Error("The parameter 'note' cannot be null.");
        else if (note !== undefined)
            url_ += "Note=" + encodeURIComponent("" + note) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<ExchangeTransactionListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeTransactionListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeTransactionListDtoIPaginatedList>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeTransactionDto> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ExchangeTransactionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeTransactionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeTransactionDto>(null as any);
    }

    /**
     * @param referenceNumber (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getByReferenceNumber(referenceNumber: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeTransactionDto> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/GetByReferenceNumber?";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "referenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByReferenceNumber(_response);
        });
    }

    protected processGetByReferenceNumber(response: AxiosResponse): Promise<ExchangeTransactionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeTransactionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeTransactionDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCommission(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/GetCommission";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCommission(_response);
        });
    }

    protected processGetCommission(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getVat(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/GetVat";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVat(_response);
        });
    }

    protected processGetVat(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param transactionTypeId (optional) 
     * @param currencyId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getRate(transactionTypeId: number | undefined, currencyId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeRateModel> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/GetRate?";
        if (transactionTypeId === null)
            throw new Error("The parameter 'transactionTypeId' cannot be null.");
        else if (transactionTypeId !== undefined)
            url_ += "transactionTypeId=" + encodeURIComponent("" + transactionTypeId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRate(_response);
        });
    }

    protected processGetRate(response: AxiosResponse): Promise<ExchangeRateModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeRateModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeRateModel>(null as any);
    }

    /**
     * @param transactionTypeId (optional) 
     * @param sellCurrencyId (optional) 
     * @param buyCurrenyId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getSwapRate(transactionTypeId: number | undefined, sellCurrencyId: number | undefined, buyCurrenyId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeRateModel> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/GetSwapRate?";
        if (transactionTypeId === null)
            throw new Error("The parameter 'transactionTypeId' cannot be null.");
        else if (transactionTypeId !== undefined)
            url_ += "transactionTypeId=" + encodeURIComponent("" + transactionTypeId) + "&";
        if (sellCurrencyId === null)
            throw new Error("The parameter 'sellCurrencyId' cannot be null.");
        else if (sellCurrencyId !== undefined)
            url_ += "sellCurrencyId=" + encodeURIComponent("" + sellCurrencyId) + "&";
        if (buyCurrenyId === null)
            throw new Error("The parameter 'buyCurrenyId' cannot be null.");
        else if (buyCurrenyId !== undefined)
            url_ += "buyCurrenyId=" + encodeURIComponent("" + buyCurrenyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSwapRate(_response);
        });
    }

    protected processGetSwapRate(response: AxiosResponse): Promise<ExchangeRateModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeRateModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeRateModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTranasctionSummary(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FcExchangeSummaryItemDto[]> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/GetTranasctionSummary?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTranasctionSummary(_response);
        });
    }

    protected processGetTranasctionSummary(response: AxiosResponse): Promise<FcExchangeSummaryItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FcExchangeSummaryItemDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FcExchangeSummaryItemDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param customerIdentityId (optional) 
     * @param delegateIdentityId (optional) 
     * @param purposeId (optional) 
     * @param sourceOfFundId (optional) 
     * @param commission (optional) 
     * @param remarks (optional) 
     * @param uIRCode (optional) 
     * @param attachment_Files (optional) 
     * @param details (optional) 
     * @param exchangeRateId (optional) 
     * @param riskScore (optional) 
     * @param totalLCAmount (optional) 
     * @param tax (optional) 
     * @param branchId (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, customerIdentityId: number | undefined, delegateIdentityId: number | undefined, purposeId: number | undefined, sourceOfFundId: number | undefined, commission: number | undefined, remarks: string | undefined, uIRCode: string | undefined, attachment_Files: FileParameter[] | undefined, details: AddExchangeTransactionDetailDto[] | undefined, exchangeRateId: number | undefined, riskScore: number | undefined, totalLCAmount: number | undefined, tax: number | undefined, branchId: number | undefined, signal?: AbortSignal): Promise<AddExchangeResultDto> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (customerIdentityId === null || customerIdentityId === undefined)
            throw new Error("The parameter 'customerIdentityId' cannot be null.");
        else
            content_.append("CustomerIdentityId", customerIdentityId.toString());
        if (delegateIdentityId === null || delegateIdentityId === undefined)
            throw new Error("The parameter 'delegateIdentityId' cannot be null.");
        else
            content_.append("DelegateIdentityId", delegateIdentityId.toString());
        if (purposeId === null || purposeId === undefined)
            throw new Error("The parameter 'purposeId' cannot be null.");
        else
            content_.append("PurposeId", purposeId.toString());
        if (sourceOfFundId === null || sourceOfFundId === undefined)
            throw new Error("The parameter 'sourceOfFundId' cannot be null.");
        else
            content_.append("SourceOfFundId", sourceOfFundId.toString());
        if (commission === null || commission === undefined)
            throw new Error("The parameter 'commission' cannot be null.");
        else
            content_.append("Commission", commission.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (uIRCode === null || uIRCode === undefined)
            throw new Error("The parameter 'uIRCode' cannot be null.");
        else
            content_.append("UIRCode", uIRCode.toString());
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );
        if (details === null || details === undefined)
            throw new Error("The parameter 'details' cannot be null.");
        else
            details.forEach(item_ => content_.append("Details", item_.toString()));
        if (exchangeRateId === null || exchangeRateId === undefined)
            throw new Error("The parameter 'exchangeRateId' cannot be null.");
        else
            content_.append("ExchangeRateId", exchangeRateId.toString());
        if (riskScore === null || riskScore === undefined)
            throw new Error("The parameter 'riskScore' cannot be null.");
        else
            content_.append("RiskScore", riskScore.toString());
        if (totalLCAmount === null || totalLCAmount === undefined)
            throw new Error("The parameter 'totalLCAmount' cannot be null.");
        else
            content_.append("TotalLCAmount", totalLCAmount.toString());
        if (tax === null || tax === undefined)
            throw new Error("The parameter 'tax' cannot be null.");
        else
            content_.append("Tax", tax.toString());
        if (branchId === null || branchId === undefined)
            throw new Error("The parameter 'branchId' cannot be null.");
        else
            content_.append("BranchId", branchId.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<AddExchangeResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AddExchangeResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddExchangeResultDto>(null as any);
    }

    /**
     * @param actionDate_From (optional) 
     * @param actionDate_To (optional) 
     * @param actions (optional) 
     * @param actionById (optional) 
     * @param assignedToId (optional) 
     * @param referanceNumber (optional) 
     * @param addComplianceLogs (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getActivityLog(actionDate_From: string | undefined, actionDate_To: string | undefined, actions: ActivityLogAction[] | undefined, actionById: number[] | undefined, assignedToId: number[] | undefined, referanceNumber: string | undefined, addComplianceLogs: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ActivityLogDto[]> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/GetActivityLog?";
        if (actionDate_From === null)
            throw new Error("The parameter 'actionDate_From' cannot be null.");
        else if (actionDate_From !== undefined)
            url_ += "ActionDate.From=" + encodeURIComponent("" + actionDate_From) + "&";
        if (actionDate_To === null)
            throw new Error("The parameter 'actionDate_To' cannot be null.");
        else if (actionDate_To !== undefined)
            url_ += "ActionDate.To=" + encodeURIComponent("" + actionDate_To) + "&";
        if (actions === null)
            throw new Error("The parameter 'actions' cannot be null.");
        else if (actions !== undefined)
            actions && actions.forEach(item => { url_ += "Actions=" + encodeURIComponent("" + item) + "&"; });
        if (actionById === null)
            throw new Error("The parameter 'actionById' cannot be null.");
        else if (actionById !== undefined)
            actionById && actionById.forEach(item => { url_ += "ActionById=" + encodeURIComponent("" + item) + "&"; });
        if (assignedToId === null)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else if (assignedToId !== undefined)
            assignedToId && assignedToId.forEach(item => { url_ += "AssignedToId=" + encodeURIComponent("" + item) + "&"; });
        if (referanceNumber === null)
            throw new Error("The parameter 'referanceNumber' cannot be null.");
        else if (referanceNumber !== undefined)
            url_ += "ReferanceNumber=" + encodeURIComponent("" + referanceNumber) + "&";
        if (addComplianceLogs === null)
            throw new Error("The parameter 'addComplianceLogs' cannot be null.");
        else if (addComplianceLogs !== undefined)
            url_ += "AddComplianceLogs=" + encodeURIComponent("" + addComplianceLogs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActivityLog(_response);
        });
    }

    protected processGetActivityLog(response: AxiosResponse): Promise<ActivityLogDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ActivityLogDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityLogDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    print(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/Print?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrint(_response);
        });
    }

    protected processPrint(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param searchKey (optional) 
     * @param number (optional) 
     * @param customerName (optional) 
     * @param note (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param statuses (optional) 
     * @param types (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    export(searchKey: string | undefined, number: string | undefined, customerName: string | undefined, note: string | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, statuses: TransactionStatuses[] | undefined, types: TransactionTypes[] | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/FCExchange/Transactions/Export?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "SearchKey=" + encodeURIComponent("" + searchKey) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (note === null)
            throw new Error("The parameter 'note' cannot be null.");
        else if (note !== undefined)
            url_ += "Note=" + encodeURIComponent("" + note) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class TransactionsModificationClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param key (optional) 
     * @param number (optional) 
     * @param exchangeTransactionId (optional) 
     * @param types (optional) 
     * @param modificationDate_From (optional) 
     * @param modificationDate_To (optional) 
     * @param modificationById (optional) 
     * @param branchIds (optional) 
     * @param statuses (optional) 
     * @param customerId (optional) 
     * @param customerName (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(key: string | undefined, number: string | undefined, exchangeTransactionId: number | undefined, types: ModificationTypes[] | undefined, modificationDate_From: string | undefined, modificationDate_To: string | undefined, modificationById: number | undefined, branchIds: number[] | undefined, statuses: ModificationStatuses[] | undefined, customerId: number | undefined, customerName: string | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeModificationListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/FCExchange/TransactionsModification/GetPaginatedList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (exchangeTransactionId === null)
            throw new Error("The parameter 'exchangeTransactionId' cannot be null.");
        else if (exchangeTransactionId !== undefined)
            url_ += "ExchangeTransactionId=" + encodeURIComponent("" + exchangeTransactionId) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (modificationDate_From === null)
            throw new Error("The parameter 'modificationDate_From' cannot be null.");
        else if (modificationDate_From !== undefined)
            url_ += "ModificationDate.From=" + encodeURIComponent("" + modificationDate_From) + "&";
        if (modificationDate_To === null)
            throw new Error("The parameter 'modificationDate_To' cannot be null.");
        else if (modificationDate_To !== undefined)
            url_ += "ModificationDate.To=" + encodeURIComponent("" + modificationDate_To) + "&";
        if (modificationById === null)
            throw new Error("The parameter 'modificationById' cannot be null.");
        else if (modificationById !== undefined)
            url_ += "ModificationById=" + encodeURIComponent("" + modificationById) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<ExchangeModificationListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeModificationListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeModificationListDtoIPaginatedList>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExchangeModificationDto> {
        let url_ = this.baseUrl + "/api/FCExchange/TransactionsModification/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ExchangeModificationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExchangeModificationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExchangeModificationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getValidTransactionAction(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TransactionActions[]> {
        let url_ = this.baseUrl + "/api/FCExchange/TransactionsModification/GetValidTransactionAction?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidTransactionAction(_response);
        });
    }

    protected processGetValidTransactionAction(response: AxiosResponse): Promise<TransactionActions[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionActions[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionActions[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param transactionId (optional) 
     * @param action (optional) 
     * @param remarks (optional) 
     * @param addAttachment_Files (optional) 
     * @return Success
     */
    setTransactionAction(branchIdHeader: string | undefined, transactionId: number | undefined, action: TransactionActions | undefined, remarks: string | undefined, addAttachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<TransactionStatuses> {
        let url_ = this.baseUrl + "/api/FCExchange/TransactionsModification/SetTransactionAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (transactionId === null || transactionId === undefined)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else
            content_.append("TransactionId", transactionId.toString());
        if (action === null || action === undefined)
            throw new Error("The parameter 'action' cannot be null.");
        else
            content_.append("Action", action.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetTransactionAction(_response);
        });
    }

    protected processSetTransactionAction(response: AxiosResponse): Promise<TransactionStatuses> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionStatuses>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionStatuses>(null as any);
    }

    /**
     * @param key (optional) 
     * @param number (optional) 
     * @param exchangeTransactionId (optional) 
     * @param types (optional) 
     * @param modificationDate_From (optional) 
     * @param modificationDate_To (optional) 
     * @param modificationById (optional) 
     * @param branchIds (optional) 
     * @param statuses (optional) 
     * @param customerId (optional) 
     * @param customerName (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    export(key: string | undefined, number: string | undefined, exchangeTransactionId: number | undefined, types: ModificationTypes[] | undefined, modificationDate_From: string | undefined, modificationDate_To: string | undefined, modificationById: number | undefined, branchIds: number[] | undefined, statuses: ModificationStatuses[] | undefined, customerId: number | undefined, customerName: string | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/FCExchange/TransactionsModification/Export?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (exchangeTransactionId === null)
            throw new Error("The parameter 'exchangeTransactionId' cannot be null.");
        else if (exchangeTransactionId !== undefined)
            url_ += "ExchangeTransactionId=" + encodeURIComponent("" + exchangeTransactionId) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (modificationDate_From === null)
            throw new Error("The parameter 'modificationDate_From' cannot be null.");
        else if (modificationDate_From !== undefined)
            url_ += "ModificationDate.From=" + encodeURIComponent("" + modificationDate_From) + "&";
        if (modificationDate_To === null)
            throw new Error("The parameter 'modificationDate_To' cannot be null.");
        else if (modificationDate_To !== undefined)
            url_ += "ModificationDate.To=" + encodeURIComponent("" + modificationDate_To) + "&";
        if (modificationById === null)
            throw new Error("The parameter 'modificationById' cannot be null.");
        else if (modificationById !== undefined)
            url_ += "ModificationById=" + encodeURIComponent("" + modificationById) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export enum ActivityLogAction {
    AMLCheck = "AMLCheck",
    AMLRecheck = "AMLRecheck",
    Block = "Block",
    Release = "Release",
    Escalate = "Escalate",
    Returned = "Returned",
    Comment = "Comment",
    Reassign = "Reassign",
    Case = "Case",
    Create = "Create",
    Edit = "Edit",
    Cancel = "Cancel",
    Refund = "Refund",
    Approve = "Approve",
    Reject = "Reject",
    Cash = "Cash",
}

export interface ActivityLogDto {
    actionDate?: string;
    actionName?: string | null;
    actionBy?: string | null;
    actionById?: number | null;
    assignedTo?: string | null;
    remarks?: string | null;
    status?: string | null;
    transactionType?: string | null;
    referenceNumber?: string | null;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
    attachments?: AttachmentDto[] | null;
}

export interface AddExchangeResultDto {
    id?: number;
    status?: TransactionStatuses;
}

export interface AddExchangeTransactionDetailDto {
    transactionTypeId?: number;
    sellCurrencyId: number;
    sellAmount?: number;
    buyCurrencyId: number;
    buyAmount?: number;
    rate: number;
}

export interface AttachmentDto {
    id?: number;
    files?: FileDto[] | null;
}

export interface BranchExchangeRateVersionsDto {
    id?: number;
    name?: string | null;
    branch?: SimpleBranchDto;
    created?: string;
    exchangeRateStatus?: ExchangeRateStatuses;
}

export enum Channels {
    FaceToFace = "FaceToFace",
    NonFaceToFace = "NonFaceToFace",
}

export interface CountryDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    iso3Code?: string | null;
    countryCode?: string | null;
    active?: boolean;
    aliases?: string[] | null;
    currencyId?: number;
}

export interface CustomerAddressDto {
    id?: number;
    addressType?: CustomerLookupModel;
    addressTypeId?: number;
    country?: SimpleCountryDto;
    countryId?: number;
    city?: SimpleCityDto;
    cityId?: number;
    district?: string | null;
    street?: string | null;
    detailedAddress?: string | null;
    permanentAddress?: string | null;
    building?: string | null;
    poBox?: string | null;
    isMain?: boolean;
}

export interface CustomerIdentityTransactionDto {
    id?: number;
    name?: string | null;
    type?: CustomerTypes;
    nationality?: CountryDto;
    date?: string;
    identity?: CustomerSimpleIdentityDto;
    address?: CustomerAddressDto;
    phone?: string | null;
}

export interface CustomerLookupModel {
    id?: number;
    name?: string | null;
    active?: boolean;
}

export interface CustomerSimpleIdentityDto {
    id?: number;
    identityType?: IdentityTypeDto;
    identityTypeId?: number;
    identityTypeName?: string | null;
    identityNumber?: string | null;
    nationalNo?: string | null;
    issuePlace?: SimpleCountryDto;
    issuePlaceId?: number;
    issueDate?: string;
    expiryDate?: string;
    isMain?: boolean;
}

export enum CustomerTypes {
    Person = "Person",
    Corporate = "Corporate",
}

export interface ExchangeCurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
    isBase?: boolean;
    isExchange?: boolean;
}

export interface ExchangeModificationDto {
    id?: number;
    number?: string | null;
    exchangeTransactionId?: number;
    type?: ModificationTypes;
    modificationDate?: string;
    modificationBy?: string | null;
    modificationById?: number;
    branch?: SimpleBranchDto;
    branchId?: number;
    status?: ModificationStatuses;
}

export interface ExchangeModificationListDto {
    id?: number;
    created?: string;
    number?: string | null;
    exchangeTransactionNumber?: string | null;
    exchangeTransactionId?: number;
    type?: ModificationTypes;
    modificationDate?: string;
    modificationBy?: string | null;
    modificationById?: number;
    branch?: SimpleBranchDto;
    branchId?: number;
    status?: ModificationStatuses;
}

export interface ExchangeModificationListDtoIPaginatedList {
    readonly items?: ExchangeModificationListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface ExchangeRateApprovedBranchDto {
    id?: number;
    branch?: SimpleBranchDto;
    approved?: boolean;
}

export interface ExchangeRateDetailDto {
    id?: number;
    currency?: SimpleCurrencyDto;
    currencyId?: number;
    buyMinRate?: number;
    buyMaxRate?: number;
    sellMinRate?: number;
    sellMaxRate?: number;
    active?: boolean;
    created?: string;
}

export interface ExchangeRateDto {
    id?: number;
    name?: string | null;
    currency?: SimpleCurrencyDto;
    currencyId?: number;
    isDraft?: boolean;
    created?: string;
    details?: ExchangeRateDetailDto[] | null;
}

export interface ExchangeRateModel {
    rate?: number;
    minRate?: number;
    maxRate?: number;
}

export enum ExchangeRateStatuses {
    Approved = "Approved",
    Archived = "Archived",
}

export interface ExchangeTransactionDetailDto {
    transactionType?: TransactionTypeDto;
    transactionTypeId?: number;
    sellCurrency?: SimpleCurrencyDto;
    sellCurrencyId?: number;
    sellAmount?: number;
    buyCurrency?: SimpleCurrencyDto;
    buyCurrencyId?: number;
    buyAmount?: number;
    rate?: number;
    readonly inverseRate?: number;
    minRate?: number;
    maxRate?: number;
    sellToBaseRate?: number;
    sellLCAmount?: number;
    buyToBaseRate?: number;
    buyLCAmount?: number;
    exchangeDifference?: number;
}

export interface ExchangeTransactionDto {
    id?: number;
    created?: string;
    createdBy?: string | null;
    number?: string | null;
    customerIdentity?: CustomerIdentityTransactionDto;
    delegateIdentityId?: number | null;
    delegateIdentity?: CustomerIdentityTransactionDto;
    purpose?: PurposeDto;
    sourceOfFund?: SourceOfFundDto;
    status?: TransactionStatuses;
    branch?: SimpleBranchDto;
    commission?: number;
    tax?: number;
    remarks?: string | null;
    riskScore?: number;
    hasSellTransaction?: boolean;
    hasBuyTransaction?: boolean;
    uirCode?: string | null;
    details?: ExchangeTransactionDetailDto[] | null;
    summary?: FcExchangeSummaryItemDto[] | null;
    lastModificationType?: ModificationTypes;
    lastModificationStatus?: ModificationStatuses;
    lastModificationAttachment?: AttachmentDto;
    lastModificationRemarks?: string | null;
    channel?: Channels;
    paymentMode?: PaymentModes;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
}

export interface ExchangeTransactionListDto {
    id?: number;
    created?: string;
    number?: string | null;
    status?: TransactionStatuses;
    customerName?: string | null;
    customerId?: number;
    branch?: SimpleBranchDto;
    branchId?: number;
    commission?: number;
    tax?: number;
    remarks?: string | null;
    hasSellTransaction?: boolean;
    hasBuyTransaction?: boolean;
    uirCode?: string | null;
    type?: string | null;
    channel?: Channels;
    paymentMode?: PaymentModes;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
}

export interface ExchangeTransactionListDtoIPaginatedList {
    readonly items?: ExchangeTransactionListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface FcExchangeSummaryItemDto {
    isBaseCurrency?: boolean;
    currency?: SimpleCurrencyDto;
    currencyId?: number;
    rounding?: number;
    totalSellAmount?: number;
    totalBuyAmount?: number;
    totalPaidAmount?: number;
    commission?: number | null;
    tax?: number | null;
}

export interface FileDto {
    id?: number;
    name?: string | null;
    extension?: string | null;
    link?: string | null;
    created?: string;
}

export interface IdentityTypeDto {
    id?: number;
    name?: string | null;
    active?: boolean;
    customerType?: CustomerTypes;
    isThereNationalNo?: boolean;
    isThereExpiry?: boolean;
    isAttachmentRequired?: boolean;
    aliases?: string[] | null;
}

export enum ModificationStatuses {
    PendingForApproval = "PendingForApproval",
    Approved = "Approved",
    Rejected = "Rejected",
    PendingForCash = "PendingForCash",
    PendingForCompliance = "PendingForCompliance",
    Blocked = "Blocked",
}

export enum ModificationTypes {
    Cancel = "Cancel",
    Refund = "Refund",
    Edit = "Edit",
}

export enum PaymentModes {
    Cash = "Cash",
    NonCash = "NonCash",
}

export interface PurposeDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
}

export enum ReportTypes {
    Pdf = "Pdf",
    Excel = "Excel",
}

export interface SaleAndPurchaseReportModel {
    created?: string;
    number?: string | null;
    sellCurrency?: SimpleCurrencyDto;
    sellAmount?: number;
    buyCurrency?: SimpleCurrencyDto;
    buyAmount?: number;
    transactionType?: TransactionTypeDto;
    transactionTypeId?: number;
    customer?: string | null;
    rate?: number;
    status?: TransactionStatuses;
    user?: string | null;
    uirCode?: string | null;
    branch?: SimpleBranchDto;
    customerType?: CustomerTypes;
}

export interface SaleAndPurchaseReportModelIPaginatedList {
    readonly items?: SaleAndPurchaseReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface SimpleBranchDto {
    id?: number;
    name?: string | null;
    code?: string | null;
}

export interface SimpleCityDto {
    id?: number;
    name?: string | null;
}

export interface SimpleCountryDto {
    id?: number;
    name?: string | null;
}

export interface SimpleCurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
}

export interface SourceOfFundDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
}

export interface SwapCurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
    isSystemControlled?: boolean;
}

export enum TransactionActions {
    Create = "Create",
    Cancel = "Cancel",
    Refund = "Refund",
    Cash = "Cash",
    Approve = "Approve",
    Reject = "Reject",
    Edit = "Edit",
}

export enum TransactionStatuses {
    PendingForCompliance = "PendingForCompliance",
    Blocked = "Blocked",
    PendingForCash = "PendingForCash",
    Completed = "Completed",
    PendingForCancel = "PendingForCancel",
    Canceled = "Canceled",
    PendingForRefund = "PendingForRefund",
    Refunded = "Refunded",
    ReadyForDelivery = "ReadyForDelivery",
    Delivered = "Delivered",
    PendingForEdit = "PendingForEdit",
    BlockedForRefund = "BlockedForRefund",
    BlockedForReserve = "BlockedForReserve",
    PendingForApproval = "PendingForApproval",
    Rejected = "Rejected",
    PendingForSenderApproval = "PendingForSenderApproval",
    PendingForReceiverApproval = "PendingForReceiverApproval",
    PendingForSenderCash = "PendingForSenderCash",
    PendingForReceiverCash = "PendingForReceiverCash",
    ComplianceProcessing = "ComplianceProcessing",
}

export interface TransactionTypeDto {
    id?: number;
    name?: string | null;
}

export enum TransactionTypes {
    FC_Sale = "FC_Sale",
    FC_Purchase = "FC_Purchase",
    SendMoney = "SendMoney",
    ReceiveMoney = "ReceiveMoney",
    Income = "Income",
    Expenses = "Expenses",
    InternalTransfer = "InternalTransfer",
    ExternalTransfer = "ExternalTransfer",
    StockTransaction = "StockTransaction",
}

export interface UpdateExchangeRateDetailDto {
    currencyId: number;
    buyMinRate: number;
    buyMaxRate: number;
    sellMinRate: number;
    sellMaxRate: number;
}

export interface UpdateExchangeRateDto {
    details: UpdateExchangeRateDetailDto[] | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}