//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ExpenseTransactionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTreasuries(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TreasuryDto[]> {
        let url_ = this.baseUrl + "/api/Finance/ExpenseTransaction/GetTreasuries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTreasuries(_response);
        });
    }

    protected processGetTreasuries(response: AxiosResponse): Promise<TreasuryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TreasuryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreasuryDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param financialAccountId (optional) 
     * @param reference (optional) 
     * @param notes (optional) 
     * @param attachment_Files (optional) 
     * @param supplierId (optional) 
     * @param dueDate (optional) 
     * @param financeTransactionDetails (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, financialAccountId: number | undefined, reference: string | undefined, notes: string | undefined, attachment_Files: FileParameter[] | undefined, supplierId: number | undefined, dueDate: string | undefined, financeTransactionDetails: AddFinanceTransactionDetailWithVatDto[] | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Finance/ExpenseTransaction/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (financialAccountId === null || financialAccountId === undefined)
            throw new Error("The parameter 'financialAccountId' cannot be null.");
        else
            content_.append("FinancialAccountId", financialAccountId.toString());
        if (reference === null || reference === undefined)
            throw new Error("The parameter 'reference' cannot be null.");
        else
            content_.append("Reference", reference.toString());
        if (notes === null || notes === undefined)
            throw new Error("The parameter 'notes' cannot be null.");
        else
            content_.append("Notes", notes.toString());
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );
        if (supplierId === null || supplierId === undefined)
            throw new Error("The parameter 'supplierId' cannot be null.");
        else
            content_.append("SupplierId", supplierId.toString());
        if (dueDate === null || dueDate === undefined)
            throw new Error("The parameter 'dueDate' cannot be null.");
        else
            content_.append("DueDate", dueDate.toString());
        if (financeTransactionDetails === null || financeTransactionDetails === undefined)
            throw new Error("The parameter 'financeTransactionDetails' cannot be null.");
        else
            financeTransactionDetails.forEach(item_ => content_.append("FinanceTransactionDetails", item_.toString()));

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getValidTransactionAction(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TransactionActions[]> {
        let url_ = this.baseUrl + "/api/Finance/ExpenseTransaction/GetValidTransactionAction?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidTransactionAction(_response);
        });
    }

    protected processGetValidTransactionAction(response: AxiosResponse): Promise<TransactionActions[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionActions[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionActions[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param transactionId (optional) 
     * @param action (optional) 
     * @param remarks (optional) 
     * @param addAttachment_Files (optional) 
     * @return Success
     */
    setTransactionAction(branchIdHeader: string | undefined, transactionId: number | undefined, action: TransactionActions | undefined, remarks: string | undefined, addAttachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<TransactionStatuses> {
        let url_ = this.baseUrl + "/api/Finance/ExpenseTransaction/SetTransactionAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (transactionId === null || transactionId === undefined)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else
            content_.append("TransactionId", transactionId.toString());
        if (action === null || action === undefined)
            throw new Error("The parameter 'action' cannot be null.");
        else
            content_.append("Action", action.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetTransactionAction(_response);
        });
    }

    protected processSetTransactionAction(response: AxiosResponse): Promise<TransactionStatuses> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionStatuses>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionStatuses>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    print(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Finance/ExpenseTransaction/Print?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrint(_response);
        });
    }

    protected processPrint(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class ExternalTransferTransactionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTreasuries(branchId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TreasuryDto[]> {
        let url_ = this.baseUrl + "/api/Finance/ExternalTransferTransaction/GetTreasuries?";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTreasuries(_response);
        });
    }

    protected processGetTreasuries(response: AxiosResponse): Promise<TreasuryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TreasuryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreasuryDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param treasuryId (optional) 
     * @param destinationBranchId (optional) 
     * @param reference (optional) 
     * @param notes (optional) 
     * @param attachment_Files (optional) 
     * @param financeTransactionDetails (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, treasuryId: number | undefined, destinationBranchId: number | undefined, reference: string | undefined, notes: string | undefined, attachment_Files: FileParameter[] | undefined, financeTransactionDetails: AddFinanceTransactionDetailWithRateDto[] | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Finance/ExternalTransferTransaction/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (treasuryId === null || treasuryId === undefined)
            throw new Error("The parameter 'treasuryId' cannot be null.");
        else
            content_.append("TreasuryId", treasuryId.toString());
        if (destinationBranchId === null || destinationBranchId === undefined)
            throw new Error("The parameter 'destinationBranchId' cannot be null.");
        else
            content_.append("DestinationBranchId", destinationBranchId.toString());
        if (reference === null || reference === undefined)
            throw new Error("The parameter 'reference' cannot be null.");
        else
            content_.append("Reference", reference.toString());
        if (notes === null || notes === undefined)
            throw new Error("The parameter 'notes' cannot be null.");
        else
            content_.append("Notes", notes.toString());
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );
        if (financeTransactionDetails === null || financeTransactionDetails === undefined)
            throw new Error("The parameter 'financeTransactionDetails' cannot be null.");
        else
            financeTransactionDetails.forEach(item_ => content_.append("FinanceTransactionDetails", item_.toString()));

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getValidTransactionAction(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TransactionActions[]> {
        let url_ = this.baseUrl + "/api/Finance/ExternalTransferTransaction/GetValidTransactionAction?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidTransactionAction(_response);
        });
    }

    protected processGetValidTransactionAction(response: AxiosResponse): Promise<TransactionActions[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionActions[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionActions[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param transactionId (optional) 
     * @param action (optional) 
     * @param remarks (optional) 
     * @param addAttachment_Files (optional) 
     * @return Success
     */
    setTransactionAction(branchIdHeader: string | undefined, transactionId: number | undefined, action: TransactionActions | undefined, remarks: string | undefined, addAttachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<TransactionStatuses> {
        let url_ = this.baseUrl + "/api/Finance/ExternalTransferTransaction/SetTransactionAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (transactionId === null || transactionId === undefined)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else
            content_.append("TransactionId", transactionId.toString());
        if (action === null || action === undefined)
            throw new Error("The parameter 'action' cannot be null.");
        else
            content_.append("Action", action.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetTransactionAction(_response);
        });
    }

    protected processSetTransactionAction(response: AxiosResponse): Promise<TransactionStatuses> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionStatuses>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionStatuses>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    print(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Finance/ExternalTransferTransaction/Print?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrint(_response);
        });
    }

    protected processPrint(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class FinanceTransactionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FinanceTransactionDto> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransaction/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<FinanceTransactionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FinanceTransactionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FinanceTransactionDto>(null as any);
    }

    /**
     * @param type (optional) 
     * @param treasuryId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCurrencies(type: FinanceTransactionTypes | undefined, treasuryId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransaction/GetCurrencies?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (treasuryId === null)
            throw new Error("The parameter 'treasuryId' cannot be null.");
        else if (treasuryId !== undefined)
            url_ += "treasuryId=" + encodeURIComponent("" + treasuryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrencies(_response);
        });
    }

    protected processGetCurrencies(response: AxiosResponse): Promise<SimpleCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleCurrencyDto[]>(null as any);
    }

    /**
     * @param referenceNumber (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getByReferenceNumber(referenceNumber: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FinanceTransactionDto> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransaction/GetByReferenceNumber?";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "referenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByReferenceNumber(_response);
        });
    }

    protected processGetByReferenceNumber(response: AxiosResponse): Promise<FinanceTransactionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FinanceTransactionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FinanceTransactionDto>(null as any);
    }

    /**
     * @param financialAccountIds (optional) 
     * @param supplierIds (optional) 
     * @param dueDate_From (optional) 
     * @param dueDate_To (optional) 
     * @param key (optional) 
     * @param number (optional) 
     * @param reference (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param types (optional) 
     * @param treasuryIds (optional) 
     * @param statuses (optional) 
     * @param amount_From (optional) 
     * @param amount_To (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(financialAccountIds: number[] | undefined, supplierIds: number[] | undefined, dueDate_From: string | undefined, dueDate_To: string | undefined, key: string | undefined, number: string | undefined, reference: string | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, types: FinanceTransactionTypes[] | undefined, treasuryIds: number[] | undefined, statuses: TransactionStatuses[] | undefined, amount_From: number | undefined, amount_To: number | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FinanceTransactionListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransaction/GetPaginatedList?";
        if (financialAccountIds === null)
            throw new Error("The parameter 'financialAccountIds' cannot be null.");
        else if (financialAccountIds !== undefined)
            financialAccountIds && financialAccountIds.forEach(item => { url_ += "FinancialAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (supplierIds === null)
            throw new Error("The parameter 'supplierIds' cannot be null.");
        else if (supplierIds !== undefined)
            supplierIds && supplierIds.forEach(item => { url_ += "SupplierIds=" + encodeURIComponent("" + item) + "&"; });
        if (dueDate_From === null)
            throw new Error("The parameter 'dueDate_From' cannot be null.");
        else if (dueDate_From !== undefined)
            url_ += "DueDate.From=" + encodeURIComponent("" + dueDate_From) + "&";
        if (dueDate_To === null)
            throw new Error("The parameter 'dueDate_To' cannot be null.");
        else if (dueDate_To !== undefined)
            url_ += "DueDate.To=" + encodeURIComponent("" + dueDate_To) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (reference === null)
            throw new Error("The parameter 'reference' cannot be null.");
        else if (reference !== undefined)
            url_ += "Reference=" + encodeURIComponent("" + reference) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (treasuryIds === null)
            throw new Error("The parameter 'treasuryIds' cannot be null.");
        else if (treasuryIds !== undefined)
            treasuryIds && treasuryIds.forEach(item => { url_ += "TreasuryIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (amount_From === null)
            throw new Error("The parameter 'amount_From' cannot be null.");
        else if (amount_From !== undefined)
            url_ += "Amount.From=" + encodeURIComponent("" + amount_From) + "&";
        if (amount_To === null)
            throw new Error("The parameter 'amount_To' cannot be null.");
        else if (amount_To !== undefined)
            url_ += "Amount.To=" + encodeURIComponent("" + amount_To) + "&";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<FinanceTransactionListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FinanceTransactionListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FinanceTransactionListDtoIPaginatedList>(null as any);
    }

    /**
     * @param toBranchIds (optional) 
     * @param branchIdsOperator (optional) 
     * @param toTreasuryIds (optional) 
     * @param treasuryIdsOperator (optional) 
     * @param key (optional) 
     * @param number (optional) 
     * @param reference (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param types (optional) 
     * @param treasuryIds (optional) 
     * @param statuses (optional) 
     * @param amount_From (optional) 
     * @param amount_To (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTransfersPaginatedList(toBranchIds: number[] | undefined, branchIdsOperator: TransfersOperators | undefined, toTreasuryIds: number[] | undefined, treasuryIdsOperator: TransfersOperators | undefined, key: string | undefined, number: string | undefined, reference: string | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, types: FinanceTransactionTypes[] | undefined, treasuryIds: number[] | undefined, statuses: TransactionStatuses[] | undefined, amount_From: number | undefined, amount_To: number | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FinanceTransactionTransferListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransaction/GetTransfersPaginatedList?";
        if (toBranchIds === null)
            throw new Error("The parameter 'toBranchIds' cannot be null.");
        else if (toBranchIds !== undefined)
            toBranchIds && toBranchIds.forEach(item => { url_ += "ToBranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIdsOperator === null)
            throw new Error("The parameter 'branchIdsOperator' cannot be null.");
        else if (branchIdsOperator !== undefined)
            url_ += "BranchIdsOperator=" + encodeURIComponent("" + branchIdsOperator) + "&";
        if (toTreasuryIds === null)
            throw new Error("The parameter 'toTreasuryIds' cannot be null.");
        else if (toTreasuryIds !== undefined)
            toTreasuryIds && toTreasuryIds.forEach(item => { url_ += "ToTreasuryIds=" + encodeURIComponent("" + item) + "&"; });
        if (treasuryIdsOperator === null)
            throw new Error("The parameter 'treasuryIdsOperator' cannot be null.");
        else if (treasuryIdsOperator !== undefined)
            url_ += "TreasuryIdsOperator=" + encodeURIComponent("" + treasuryIdsOperator) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (reference === null)
            throw new Error("The parameter 'reference' cannot be null.");
        else if (reference !== undefined)
            url_ += "Reference=" + encodeURIComponent("" + reference) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (treasuryIds === null)
            throw new Error("The parameter 'treasuryIds' cannot be null.");
        else if (treasuryIds !== undefined)
            treasuryIds && treasuryIds.forEach(item => { url_ += "TreasuryIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (amount_From === null)
            throw new Error("The parameter 'amount_From' cannot be null.");
        else if (amount_From !== undefined)
            url_ += "Amount.From=" + encodeURIComponent("" + amount_From) + "&";
        if (amount_To === null)
            throw new Error("The parameter 'amount_To' cannot be null.");
        else if (amount_To !== undefined)
            url_ += "Amount.To=" + encodeURIComponent("" + amount_To) + "&";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTransfersPaginatedList(_response);
        });
    }

    protected processGetTransfersPaginatedList(response: AxiosResponse): Promise<FinanceTransactionTransferListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FinanceTransactionTransferListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FinanceTransactionTransferListDtoIPaginatedList>(null as any);
    }

    /**
     * @param actionDate_From (optional) 
     * @param actionDate_To (optional) 
     * @param actions (optional) 
     * @param actionById (optional) 
     * @param assignedToId (optional) 
     * @param referanceNumber (optional) 
     * @param addComplianceLogs (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getActivityLog(actionDate_From: string | undefined, actionDate_To: string | undefined, actions: ActivityLogAction[] | undefined, actionById: number[] | undefined, assignedToId: number[] | undefined, referanceNumber: string | undefined, addComplianceLogs: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ActivityLogDto[]> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransaction/GetActivityLog?";
        if (actionDate_From === null)
            throw new Error("The parameter 'actionDate_From' cannot be null.");
        else if (actionDate_From !== undefined)
            url_ += "ActionDate.From=" + encodeURIComponent("" + actionDate_From) + "&";
        if (actionDate_To === null)
            throw new Error("The parameter 'actionDate_To' cannot be null.");
        else if (actionDate_To !== undefined)
            url_ += "ActionDate.To=" + encodeURIComponent("" + actionDate_To) + "&";
        if (actions === null)
            throw new Error("The parameter 'actions' cannot be null.");
        else if (actions !== undefined)
            actions && actions.forEach(item => { url_ += "Actions=" + encodeURIComponent("" + item) + "&"; });
        if (actionById === null)
            throw new Error("The parameter 'actionById' cannot be null.");
        else if (actionById !== undefined)
            actionById && actionById.forEach(item => { url_ += "ActionById=" + encodeURIComponent("" + item) + "&"; });
        if (assignedToId === null)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else if (assignedToId !== undefined)
            assignedToId && assignedToId.forEach(item => { url_ += "AssignedToId=" + encodeURIComponent("" + item) + "&"; });
        if (referanceNumber === null)
            throw new Error("The parameter 'referanceNumber' cannot be null.");
        else if (referanceNumber !== undefined)
            url_ += "ReferanceNumber=" + encodeURIComponent("" + referanceNumber) + "&";
        if (addComplianceLogs === null)
            throw new Error("The parameter 'addComplianceLogs' cannot be null.");
        else if (addComplianceLogs !== undefined)
            url_ += "AddComplianceLogs=" + encodeURIComponent("" + addComplianceLogs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActivityLog(_response);
        });
    }

    protected processGetActivityLog(response: AxiosResponse): Promise<ActivityLogDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ActivityLogDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityLogDto[]>(null as any);
    }

    /**
     * @param financialAccountIds (optional) 
     * @param supplierIds (optional) 
     * @param dueDate_From (optional) 
     * @param dueDate_To (optional) 
     * @param key (optional) 
     * @param number (optional) 
     * @param reference (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param types (optional) 
     * @param treasuryIds (optional) 
     * @param statuses (optional) 
     * @param amount_From (optional) 
     * @param amount_To (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    export(financialAccountIds: number[] | undefined, supplierIds: number[] | undefined, dueDate_From: string | undefined, dueDate_To: string | undefined, key: string | undefined, number: string | undefined, reference: string | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, types: FinanceTransactionTypes[] | undefined, treasuryIds: number[] | undefined, statuses: TransactionStatuses[] | undefined, amount_From: number | undefined, amount_To: number | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransaction/Export?";
        if (financialAccountIds === null)
            throw new Error("The parameter 'financialAccountIds' cannot be null.");
        else if (financialAccountIds !== undefined)
            financialAccountIds && financialAccountIds.forEach(item => { url_ += "FinancialAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (supplierIds === null)
            throw new Error("The parameter 'supplierIds' cannot be null.");
        else if (supplierIds !== undefined)
            supplierIds && supplierIds.forEach(item => { url_ += "SupplierIds=" + encodeURIComponent("" + item) + "&"; });
        if (dueDate_From === null)
            throw new Error("The parameter 'dueDate_From' cannot be null.");
        else if (dueDate_From !== undefined)
            url_ += "DueDate.From=" + encodeURIComponent("" + dueDate_From) + "&";
        if (dueDate_To === null)
            throw new Error("The parameter 'dueDate_To' cannot be null.");
        else if (dueDate_To !== undefined)
            url_ += "DueDate.To=" + encodeURIComponent("" + dueDate_To) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (reference === null)
            throw new Error("The parameter 'reference' cannot be null.");
        else if (reference !== undefined)
            url_ += "Reference=" + encodeURIComponent("" + reference) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (treasuryIds === null)
            throw new Error("The parameter 'treasuryIds' cannot be null.");
        else if (treasuryIds !== undefined)
            treasuryIds && treasuryIds.forEach(item => { url_ += "TreasuryIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (amount_From === null)
            throw new Error("The parameter 'amount_From' cannot be null.");
        else if (amount_From !== undefined)
            url_ += "Amount.From=" + encodeURIComponent("" + amount_From) + "&";
        if (amount_To === null)
            throw new Error("The parameter 'amount_To' cannot be null.");
        else if (amount_To !== undefined)
            url_ += "Amount.To=" + encodeURIComponent("" + amount_To) + "&";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param toBranchIds (optional) 
     * @param branchIdsOperator (optional) 
     * @param toTreasuryIds (optional) 
     * @param treasuryIdsOperator (optional) 
     * @param key (optional) 
     * @param number (optional) 
     * @param reference (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param types (optional) 
     * @param treasuryIds (optional) 
     * @param statuses (optional) 
     * @param amount_From (optional) 
     * @param amount_To (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportTransactionTransfers(toBranchIds: number[] | undefined, branchIdsOperator: TransfersOperators | undefined, toTreasuryIds: number[] | undefined, treasuryIdsOperator: TransfersOperators | undefined, key: string | undefined, number: string | undefined, reference: string | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, types: FinanceTransactionTypes[] | undefined, treasuryIds: number[] | undefined, statuses: TransactionStatuses[] | undefined, amount_From: number | undefined, amount_To: number | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransaction/ExportTransactionTransfers?";
        if (toBranchIds === null)
            throw new Error("The parameter 'toBranchIds' cannot be null.");
        else if (toBranchIds !== undefined)
            toBranchIds && toBranchIds.forEach(item => { url_ += "ToBranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIdsOperator === null)
            throw new Error("The parameter 'branchIdsOperator' cannot be null.");
        else if (branchIdsOperator !== undefined)
            url_ += "BranchIdsOperator=" + encodeURIComponent("" + branchIdsOperator) + "&";
        if (toTreasuryIds === null)
            throw new Error("The parameter 'toTreasuryIds' cannot be null.");
        else if (toTreasuryIds !== undefined)
            toTreasuryIds && toTreasuryIds.forEach(item => { url_ += "ToTreasuryIds=" + encodeURIComponent("" + item) + "&"; });
        if (treasuryIdsOperator === null)
            throw new Error("The parameter 'treasuryIdsOperator' cannot be null.");
        else if (treasuryIdsOperator !== undefined)
            url_ += "TreasuryIdsOperator=" + encodeURIComponent("" + treasuryIdsOperator) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (reference === null)
            throw new Error("The parameter 'reference' cannot be null.");
        else if (reference !== undefined)
            url_ += "Reference=" + encodeURIComponent("" + reference) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (treasuryIds === null)
            throw new Error("The parameter 'treasuryIds' cannot be null.");
        else if (treasuryIds !== undefined)
            treasuryIds && treasuryIds.forEach(item => { url_ += "TreasuryIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (amount_From === null)
            throw new Error("The parameter 'amount_From' cannot be null.");
        else if (amount_From !== undefined)
            url_ += "Amount.From=" + encodeURIComponent("" + amount_From) + "&";
        if (amount_To === null)
            throw new Error("The parameter 'amount_To' cannot be null.");
        else if (amount_To !== undefined)
            url_ += "Amount.To=" + encodeURIComponent("" + amount_To) + "&";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportTransactionTransfers(_response);
        });
    }

    protected processExportTransactionTransfers(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class FinanceTransactionReportClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param createdDate_From (optional) 
     * @param createdDate_To (optional) 
     * @param paymentDate_From (optional) 
     * @param paymentDate_To (optional) 
     * @param transactionTypeIds (optional) 
     * @param branchIds (optional) 
     * @param resultType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getVatRegister(createdDate_From: string | undefined, createdDate_To: string | undefined, paymentDate_From: string | undefined, paymentDate_To: string | undefined, transactionTypeIds: TransactionTypes[] | undefined, branchIds: number[] | undefined, resultType: VatRegisterResultTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<VatRegisterSummaryModel[]> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransactionReport/GetVatRegister?";
        if (createdDate_From === null)
            throw new Error("The parameter 'createdDate_From' cannot be null.");
        else if (createdDate_From !== undefined)
            url_ += "CreatedDate.From=" + encodeURIComponent("" + createdDate_From) + "&";
        if (createdDate_To === null)
            throw new Error("The parameter 'createdDate_To' cannot be null.");
        else if (createdDate_To !== undefined)
            url_ += "CreatedDate.To=" + encodeURIComponent("" + createdDate_To) + "&";
        if (paymentDate_From === null)
            throw new Error("The parameter 'paymentDate_From' cannot be null.");
        else if (paymentDate_From !== undefined)
            url_ += "PaymentDate.From=" + encodeURIComponent("" + paymentDate_From) + "&";
        if (paymentDate_To === null)
            throw new Error("The parameter 'paymentDate_To' cannot be null.");
        else if (paymentDate_To !== undefined)
            url_ += "PaymentDate.To=" + encodeURIComponent("" + paymentDate_To) + "&";
        if (transactionTypeIds === null)
            throw new Error("The parameter 'transactionTypeIds' cannot be null.");
        else if (transactionTypeIds !== undefined)
            transactionTypeIds && transactionTypeIds.forEach(item => { url_ += "TransactionTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (resultType === null)
            throw new Error("The parameter 'resultType' cannot be null.");
        else if (resultType !== undefined)
            url_ += "ResultType=" + encodeURIComponent("" + resultType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVatRegister(_response);
        });
    }

    protected processGetVatRegister(response: AxiosResponse): Promise<VatRegisterSummaryModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<VatRegisterSummaryModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VatRegisterSummaryModel[]>(null as any);
    }

    /**
     * @param createdDate_From (optional) 
     * @param createdDate_To (optional) 
     * @param paymentDate_From (optional) 
     * @param paymentDate_To (optional) 
     * @param transactionTypeIds (optional) 
     * @param branchIds (optional) 
     * @param resultType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportVatRegister(createdDate_From: string | undefined, createdDate_To: string | undefined, paymentDate_From: string | undefined, paymentDate_To: string | undefined, transactionTypeIds: TransactionTypes[] | undefined, branchIds: number[] | undefined, resultType: VatRegisterResultTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransactionReport/ExportVatRegister?";
        if (createdDate_From === null)
            throw new Error("The parameter 'createdDate_From' cannot be null.");
        else if (createdDate_From !== undefined)
            url_ += "CreatedDate.From=" + encodeURIComponent("" + createdDate_From) + "&";
        if (createdDate_To === null)
            throw new Error("The parameter 'createdDate_To' cannot be null.");
        else if (createdDate_To !== undefined)
            url_ += "CreatedDate.To=" + encodeURIComponent("" + createdDate_To) + "&";
        if (paymentDate_From === null)
            throw new Error("The parameter 'paymentDate_From' cannot be null.");
        else if (paymentDate_From !== undefined)
            url_ += "PaymentDate.From=" + encodeURIComponent("" + paymentDate_From) + "&";
        if (paymentDate_To === null)
            throw new Error("The parameter 'paymentDate_To' cannot be null.");
        else if (paymentDate_To !== undefined)
            url_ += "PaymentDate.To=" + encodeURIComponent("" + paymentDate_To) + "&";
        if (transactionTypeIds === null)
            throw new Error("The parameter 'transactionTypeIds' cannot be null.");
        else if (transactionTypeIds !== undefined)
            transactionTypeIds && transactionTypeIds.forEach(item => { url_ += "TransactionTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (resultType === null)
            throw new Error("The parameter 'resultType' cannot be null.");
        else if (resultType !== undefined)
            url_ += "ResultType=" + encodeURIComponent("" + resultType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportVatRegister(_response);
        });
    }

    protected processExportVatRegister(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date (optional) 
     * @param currencyIds (optional) 
     * @param branchFilter_Ids (optional) 
     * @param branchFilter_ResultType (optional) 
     * @param treasuryFilter_Ids (optional) 
     * @param treasuryFilter_ResultType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCurrencyStock(date: string | undefined, currencyIds: number[] | undefined, branchFilter_Ids: number[] | undefined, branchFilter_ResultType: CurrencyStockResultTypes | undefined, treasuryFilter_Ids: number[] | undefined, treasuryFilter_ResultType: CurrencyStockResultTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CurrencyStockReportModel[]> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransactionReport/GetCurrencyStock?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent("" + date) + "&";
        if (currencyIds === null)
            throw new Error("The parameter 'currencyIds' cannot be null.");
        else if (currencyIds !== undefined)
            currencyIds && currencyIds.forEach(item => { url_ += "CurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchFilter_Ids === null)
            throw new Error("The parameter 'branchFilter_Ids' cannot be null.");
        else if (branchFilter_Ids !== undefined)
            branchFilter_Ids && branchFilter_Ids.forEach(item => { url_ += "BranchFilter.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (branchFilter_ResultType === null)
            throw new Error("The parameter 'branchFilter_ResultType' cannot be null.");
        else if (branchFilter_ResultType !== undefined)
            url_ += "BranchFilter.ResultType=" + encodeURIComponent("" + branchFilter_ResultType) + "&";
        if (treasuryFilter_Ids === null)
            throw new Error("The parameter 'treasuryFilter_Ids' cannot be null.");
        else if (treasuryFilter_Ids !== undefined)
            treasuryFilter_Ids && treasuryFilter_Ids.forEach(item => { url_ += "TreasuryFilter.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (treasuryFilter_ResultType === null)
            throw new Error("The parameter 'treasuryFilter_ResultType' cannot be null.");
        else if (treasuryFilter_ResultType !== undefined)
            url_ += "TreasuryFilter.ResultType=" + encodeURIComponent("" + treasuryFilter_ResultType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrencyStock(_response);
        });
    }

    protected processGetCurrencyStock(response: AxiosResponse): Promise<CurrencyStockReportModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CurrencyStockReportModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyStockReportModel[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @param currencyIds (optional) 
     * @param branchFilter_Ids (optional) 
     * @param branchFilter_ResultType (optional) 
     * @param treasuryFilter_Ids (optional) 
     * @param treasuryFilter_ResultType (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportCurrencyStock(date: string | undefined, currencyIds: number[] | undefined, branchFilter_Ids: number[] | undefined, branchFilter_ResultType: CurrencyStockResultTypes | undefined, treasuryFilter_Ids: number[] | undefined, treasuryFilter_ResultType: CurrencyStockResultTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransactionReport/ExportCurrencyStock?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent("" + date) + "&";
        if (currencyIds === null)
            throw new Error("The parameter 'currencyIds' cannot be null.");
        else if (currencyIds !== undefined)
            currencyIds && currencyIds.forEach(item => { url_ += "CurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchFilter_Ids === null)
            throw new Error("The parameter 'branchFilter_Ids' cannot be null.");
        else if (branchFilter_Ids !== undefined)
            branchFilter_Ids && branchFilter_Ids.forEach(item => { url_ += "BranchFilter.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (branchFilter_ResultType === null)
            throw new Error("The parameter 'branchFilter_ResultType' cannot be null.");
        else if (branchFilter_ResultType !== undefined)
            url_ += "BranchFilter.ResultType=" + encodeURIComponent("" + branchFilter_ResultType) + "&";
        if (treasuryFilter_Ids === null)
            throw new Error("The parameter 'treasuryFilter_Ids' cannot be null.");
        else if (treasuryFilter_Ids !== undefined)
            treasuryFilter_Ids && treasuryFilter_Ids.forEach(item => { url_ += "TreasuryFilter.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (treasuryFilter_ResultType === null)
            throw new Error("The parameter 'treasuryFilter_ResultType' cannot be null.");
        else if (treasuryFilter_ResultType !== undefined)
            url_ += "TreasuryFilter.ResultType=" + encodeURIComponent("" + treasuryFilter_ResultType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportCurrencyStock(_response);
        });
    }

    protected processExportCurrencyStock(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param branchIds (optional) 
     * @param treasuriesId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getAccountBalanceCurrencies(branchIds: number[] | undefined, treasuriesId: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransactionReport/GetAccountBalanceCurrencies?";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (treasuriesId === null)
            throw new Error("The parameter 'treasuriesId' cannot be null.");
        else if (treasuriesId !== undefined)
            treasuriesId && treasuriesId.forEach(item => { url_ += "TreasuriesId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccountBalanceCurrencies(_response);
        });
    }

    protected processGetAccountBalanceCurrencies(response: AxiosResponse): Promise<SimpleCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleCurrencyDto[]>(null as any);
    }

    /**
     * @param branchIds (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTreasuriesByBranchIds(branchIds: number[] | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleTreasuryDto[]> {
        let url_ = this.baseUrl + "/api/Finance/FinanceTransactionReport/GetTreasuriesByBranchIds?";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "branchIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTreasuriesByBranchIds(_response);
        });
    }

    protected processGetTreasuriesByBranchIds(response: AxiosResponse): Promise<SimpleTreasuryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleTreasuryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleTreasuryDto[]>(null as any);
    }
}

export class FinancialAccountClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param type (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getFinancialAccountLookups(type: FinancialAccountTypes | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FinancialAccountDto[]> {
        let url_ = this.baseUrl + "/api/Finance/FinancialAccount/GetFinancialAccountLookups?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFinancialAccountLookups(_response);
        });
    }

    protected processGetFinancialAccountLookups(response: AxiosResponse): Promise<FinancialAccountDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FinancialAccountDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FinancialAccountDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullFinancialAccountDto> {
        let url_ = this.baseUrl + "/api/Finance/FinancialAccount/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullFinancialAccountDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullFinancialAccountDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullFinancialAccountDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FinancialAccountDto> {
        let url_ = this.baseUrl + "/api/Finance/FinancialAccount/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<FinancialAccountDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FinancialAccountDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FinancialAccountDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FinancialAccountDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Finance/FinancialAccount/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<FinancialAccountDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FinancialAccountDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FinancialAccountDtoIPaginatedList>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FinancialAccountDto[]> {
        let url_ = this.baseUrl + "/api/Finance/FinancialAccount/GetList?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<FinancialAccountDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FinancialAccountDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FinancialAccountDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddFinancialAccountDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Finance/FinancialAccount/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateFinancialAccountDto | undefined, signal?: AbortSignal): Promise<UpdateFinancialAccountDto> {
        let url_ = this.baseUrl + "/api/Finance/FinancialAccount/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateFinancialAccountDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateFinancialAccountDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateFinancialAccountDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Finance/FinancialAccount/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Finance/FinancialAccount/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class FinancialCurrencyClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param type (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(type: SupportFinancialTransactions | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FinancialCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Finance/FinancialCurrency/GetList?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<FinancialCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FinancialCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FinancialCurrencyDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    set(branchIdHeader: string | undefined, body: SetFinancialCurrencyDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Finance/FinancialCurrency/Set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSet(_response);
        });
    }

    protected processSet(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Finance/FinancialCurrency/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export class IncomeTransactionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTreasuries(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TreasuryDto[]> {
        let url_ = this.baseUrl + "/api/Finance/IncomeTransaction/GetTreasuries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTreasuries(_response);
        });
    }

    protected processGetTreasuries(response: AxiosResponse): Promise<TreasuryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TreasuryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreasuryDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param financialAccountId (optional) 
     * @param reference (optional) 
     * @param notes (optional) 
     * @param attachment_Files (optional) 
     * @param dueDate (optional) 
     * @param financeTransactionDetails (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, financialAccountId: number | undefined, reference: string | undefined, notes: string | undefined, attachment_Files: FileParameter[] | undefined, dueDate: string | undefined, financeTransactionDetails: AddFinanceTransactionDetailWithVatDto[] | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Finance/IncomeTransaction/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (financialAccountId === null || financialAccountId === undefined)
            throw new Error("The parameter 'financialAccountId' cannot be null.");
        else
            content_.append("FinancialAccountId", financialAccountId.toString());
        if (reference === null || reference === undefined)
            throw new Error("The parameter 'reference' cannot be null.");
        else
            content_.append("Reference", reference.toString());
        if (notes === null || notes === undefined)
            throw new Error("The parameter 'notes' cannot be null.");
        else
            content_.append("Notes", notes.toString());
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );
        if (dueDate === null || dueDate === undefined)
            throw new Error("The parameter 'dueDate' cannot be null.");
        else
            content_.append("DueDate", dueDate.toString());
        if (financeTransactionDetails === null || financeTransactionDetails === undefined)
            throw new Error("The parameter 'financeTransactionDetails' cannot be null.");
        else
            financeTransactionDetails.forEach(item_ => content_.append("FinanceTransactionDetails", item_.toString()));

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    addTest(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Finance/IncomeTransaction/AddTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddTest(_response);
        });
    }

    protected processAddTest(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getValidTransactionAction(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TransactionActions[]> {
        let url_ = this.baseUrl + "/api/Finance/IncomeTransaction/GetValidTransactionAction?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidTransactionAction(_response);
        });
    }

    protected processGetValidTransactionAction(response: AxiosResponse): Promise<TransactionActions[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionActions[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionActions[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param transactionId (optional) 
     * @param action (optional) 
     * @param remarks (optional) 
     * @param addAttachment_Files (optional) 
     * @return Success
     */
    setTransactionAction(branchIdHeader: string | undefined, transactionId: number | undefined, action: TransactionActions | undefined, remarks: string | undefined, addAttachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<TransactionStatuses> {
        let url_ = this.baseUrl + "/api/Finance/IncomeTransaction/SetTransactionAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (transactionId === null || transactionId === undefined)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else
            content_.append("TransactionId", transactionId.toString());
        if (action === null || action === undefined)
            throw new Error("The parameter 'action' cannot be null.");
        else
            content_.append("Action", action.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetTransactionAction(_response);
        });
    }

    protected processSetTransactionAction(response: AxiosResponse): Promise<TransactionStatuses> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionStatuses>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionStatuses>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    print(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Finance/IncomeTransaction/Print?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrint(_response);
        });
    }

    protected processPrint(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class InternalTransferTransactionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param isResponsible (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getTreasuries(isResponsible: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TreasuryDto[]> {
        let url_ = this.baseUrl + "/api/Finance/InternalTransferTransaction/GetTreasuries?";
        if (isResponsible === null)
            throw new Error("The parameter 'isResponsible' cannot be null.");
        else if (isResponsible !== undefined)
            url_ += "isResponsible=" + encodeURIComponent("" + isResponsible) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTreasuries(_response);
        });
    }

    protected processGetTreasuries(response: AxiosResponse): Promise<TreasuryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TreasuryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreasuryDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param treasuryId (optional) 
     * @param destinationTreasuryId (optional) 
     * @param reference (optional) 
     * @param notes (optional) 
     * @param attachment_Files (optional) 
     * @param financeTransactionDetails (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, treasuryId: number | undefined, destinationTreasuryId: number | undefined, reference: string | undefined, notes: string | undefined, attachment_Files: FileParameter[] | undefined, financeTransactionDetails: AddFinanceTransactionDetailDto[] | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Finance/InternalTransferTransaction/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (treasuryId === null || treasuryId === undefined)
            throw new Error("The parameter 'treasuryId' cannot be null.");
        else
            content_.append("TreasuryId", treasuryId.toString());
        if (destinationTreasuryId === null || destinationTreasuryId === undefined)
            throw new Error("The parameter 'destinationTreasuryId' cannot be null.");
        else
            content_.append("DestinationTreasuryId", destinationTreasuryId.toString());
        if (reference === null || reference === undefined)
            throw new Error("The parameter 'reference' cannot be null.");
        else
            content_.append("Reference", reference.toString());
        if (notes === null || notes === undefined)
            throw new Error("The parameter 'notes' cannot be null.");
        else
            content_.append("Notes", notes.toString());
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );
        if (financeTransactionDetails === null || financeTransactionDetails === undefined)
            throw new Error("The parameter 'financeTransactionDetails' cannot be null.");
        else
            financeTransactionDetails.forEach(item_ => content_.append("FinanceTransactionDetails", item_.toString()));

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getValidTransactionAction(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TransactionActions[]> {
        let url_ = this.baseUrl + "/api/Finance/InternalTransferTransaction/GetValidTransactionAction?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidTransactionAction(_response);
        });
    }

    protected processGetValidTransactionAction(response: AxiosResponse): Promise<TransactionActions[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionActions[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionActions[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param transactionId (optional) 
     * @param action (optional) 
     * @param remarks (optional) 
     * @param addAttachment_Files (optional) 
     * @return Success
     */
    setTransactionAction(branchIdHeader: string | undefined, transactionId: number | undefined, action: TransactionActions | undefined, remarks: string | undefined, addAttachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<TransactionStatuses> {
        let url_ = this.baseUrl + "/api/Finance/InternalTransferTransaction/SetTransactionAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (transactionId === null || transactionId === undefined)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else
            content_.append("TransactionId", transactionId.toString());
        if (action === null || action === undefined)
            throw new Error("The parameter 'action' cannot be null.");
        else
            content_.append("Action", action.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetTransactionAction(_response);
        });
    }

    protected processSetTransactionAction(response: AxiosResponse): Promise<TransactionStatuses> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionStatuses>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionStatuses>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    print(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Finance/InternalTransferTransaction/Print?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrint(_response);
        });
    }

    protected processPrint(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class SupplierClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddSupplierDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Finance/Supplier/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateSupplierDto | undefined, signal?: AbortSignal): Promise<UpdateSupplierDto> {
        let url_ = this.baseUrl + "/api/Finance/Supplier/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateSupplierDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateSupplierDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateSupplierDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Finance/Supplier/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Finance/Supplier/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/Finance/Supplier/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<SupplierDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SupplierDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SupplierDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Finance/Supplier/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<SupplierDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SupplierDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SupplierDto[]> {
        let url_ = this.baseUrl + "/api/Finance/Supplier/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<SupplierDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SupplierDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDto[]>(null as any);
    }
}

export class TreasuryClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getUsersOfCurrentBranch(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<LookupApplicationUserDto[]> {
        let url_ = this.baseUrl + "/api/Finance/Treasury/GetUsersOfCurrentBranch";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsersOfCurrentBranch(_response);
        });
    }

    protected processGetUsersOfCurrentBranch(response: AxiosResponse): Promise<LookupApplicationUserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LookupApplicationUserDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LookupApplicationUserDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, body: AddTreasuryDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Finance/Treasury/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateTreasuryDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Finance/Treasury/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Finance/Treasury/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Finance/Treasury/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TreasuryDto> {
        let url_ = this.baseUrl + "/api/Finance/Treasury/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<TreasuryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TreasuryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreasuryDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullTreasuryDto> {
        let url_ = this.baseUrl + "/api/Finance/Treasury/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullTreasuryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullTreasuryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullTreasuryDto>(null as any);
    }

    /**
     * @param key (optional) 
     * @param name (optional) 
     * @param branchIds (optional) 
     * @param type (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(key: string | undefined, name: string | undefined, branchIds: number[] | undefined, type: TreasuryTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TreasuryListDto[]> {
        let url_ = this.baseUrl + "/api/Finance/Treasury/GetList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<TreasuryListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TreasuryListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreasuryListDto[]>(null as any);
    }

    /**
     * @param key (optional) 
     * @param name (optional) 
     * @param branchIds (optional) 
     * @param type (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(key: string | undefined, name: string | undefined, branchIds: number[] | undefined, type: TreasuryTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TreasuryListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Finance/Treasury/GetPaginatedList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<TreasuryListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TreasuryListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreasuryListDtoIPaginatedList>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookups(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TreasuryLookupDto[]> {
        let url_ = this.baseUrl + "/api/Finance/Treasury/GetLookups?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookups(_response);
        });
    }

    protected processGetLookups(response: AxiosResponse): Promise<TreasuryLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TreasuryLookupDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreasuryLookupDto[]>(null as any);
    }
}

export interface AccountLookupDto {
    id?: number;
    name?: string | null;
    fullCode?: string | null;
    active?: boolean;
}

export enum ActivityLogAction {
    AMLCheck = "AMLCheck",
    AMLRecheck = "AMLRecheck",
    Block = "Block",
    Release = "Release",
    Escalate = "Escalate",
    Returned = "Returned",
    Comment = "Comment",
    Reassign = "Reassign",
    Case = "Case",
    Create = "Create",
    Edit = "Edit",
    Cancel = "Cancel",
    Refund = "Refund",
    Approve = "Approve",
    Reject = "Reject",
    Cash = "Cash",
}

export interface ActivityLogDto {
    actionDate?: string;
    actionName?: string | null;
    actionBy?: string | null;
    actionById?: number | null;
    assignedTo?: string | null;
    remarks?: string | null;
    status?: string | null;
    transactionType?: string | null;
    referenceNumber?: string | null;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
    attachments?: AttachmentDto[] | null;
}

export interface AddFinanceTransactionDetailDto {
    currencyId: number;
    fcAmount: number;
    financialAccountId?: number | null;
    description?: string | null;
}

export interface AddFinanceTransactionDetailWithRateDto {
    currencyId: number;
    fcAmount: number;
    rate?: number | null;
    financialAccountId?: number | null;
    description?: string | null;
}

export interface AddFinanceTransactionDetailWithVatDto {
    currencyId: number;
    fcAmount: number;
    financialAccountId?: number | null;
    vatPercent?: number;
    reference?: string | null;
    description?: string | null;
}

export interface AddFinancialAccountDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: FinancialAccountTypes;
    accountId: number;
}

export interface AddSupplierDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
    vatTRN?: string | null;
}

export interface AddTreasuryDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: TreasuryTypes;
    responsibleUserId: number;
}

export interface AttachmentDto {
    id?: number;
    files?: FileDto[] | null;
}

export interface ChangeStatusModel {
    ids: number[];
    active: boolean;
    reason?: string | null;
}

export interface CurrencyStockReportItemModel {
    currency?: SimpleCurrencyDto;
    balance?: number;
}

export interface CurrencyStockReportModel {
    date?: string;
    branch?: string | null;
    treasury?: string | null;
    items?: CurrencyStockReportItemModel[] | null;
}

export enum CurrencyStockResultTypes {
    Separated = "Separated",
    Consolidated = "Consolidated",
}

export interface FileDto {
    id?: number;
    name?: string | null;
    extension?: string | null;
    link?: string | null;
    created?: string;
}

export interface FinanceTransactionDetailDto {
    currency?: SimpleCurrencyDto;
    financialAccount?: FinancialAccountDto;
    fcAmount?: number;
    rate?: number;
    lcAmount?: number;
    vatPercent?: number;
    vatAmount?: number;
    netVatAmount?: number;
    totalLCAmount?: number;
    reference?: string | null;
    description?: string | null;
}

export interface FinanceTransactionDto {
    id?: number;
    created?: string;
    createdBy?: string | null;
    number?: string | null;
    type?: FinanceTransactionTypes;
    reference?: string | null;
    totalLCAmount?: number;
    status?: TransactionStatuses;
    treasury?: SimpleTreasuryDto;
    toTreasury?: SimpleTreasuryDto;
    branch?: SimpleBranchDto;
    toBranch?: SimpleBranchDto;
    financialAccount?: FinancialAccountDto;
    notes?: string | null;
    processId?: string | null;
    supplier?: SupplierDto;
    dueDate?: string | null;
    cashDate?: string | null;
    attachment?: AttachmentDto;
    financeTransactionDetails?: FinanceTransactionDetailDto[] | null;
}

export interface FinanceTransactionListDto {
    id?: number;
    created?: string;
    dueDate?: string | null;
    number?: string | null;
    type?: FinanceTransactionTypes;
    branch?: SimpleBranchDto;
    supplier?: SupplierDto;
    treasury?: SimpleTreasuryDto;
    financialAccount?: FinancialAccountDto;
    reference?: string | null;
    totalLCAmount?: number;
    status?: TransactionStatuses;
}

export interface FinanceTransactionListDtoIPaginatedList {
    readonly items?: FinanceTransactionListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface FinanceTransactionTransferListDto {
    id?: number;
    created?: string;
    number?: string | null;
    type?: FinanceTransactionTypes;
    fromTreasury?: SimpleTreasuryDto;
    toTreasury?: SimpleTreasuryDto;
    fromBranch?: SimpleBranchDto;
    toBranch?: SimpleBranchDto;
    reference?: string | null;
    totalLCAmount?: number;
    status?: TransactionStatuses;
}

export interface FinanceTransactionTransferListDtoIPaginatedList {
    readonly items?: FinanceTransactionTransferListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum FinanceTransactionTypes {
    Income = "Income",
    Expense = "Expense",
    InternalTransfer = "InternalTransfer",
    ExternalTransfer = "ExternalTransfer",
}

export interface FinancialAccountDto {
    id?: number;
    name?: string | null;
    account?: AccountLookupDto;
    type?: FinancialAccountTypes;
    active?: boolean;
}

export interface FinancialAccountDtoIPaginatedList {
    readonly items?: FinancialAccountDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum FinancialAccountTypes {
    Income = "Income",
    Expense = "Expense",
    Both = "Both",
}

export interface FinancialCurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
    supportFinancialTransaction?: SupportFinancialTransactions;
    isBaseCurrency?: boolean;
}

export interface FullFinancialAccountDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: FinancialAccountTypes;
    accountId?: number;
    active?: boolean;
    accountName?: string | null;
}

export interface FullTreasuryDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    number?: string | null;
    companyId?: number;
    branch?: SimpleBranchDto;
    branchId?: number;
    active?: boolean;
    type?: TreasuryTypes;
    responsibleUser?: LookupApplicationUserDto;
    responsibleUserId?: number;
}

export interface LookupApplicationUserDto {
    id?: number;
    email?: string | null;
    fullName?: string | null;
    mobile?: string | null;
}

export enum ReportTypes {
    Pdf = "Pdf",
    Excel = "Excel",
}

export interface SetFinancialCurrencyDto {
    id?: number;
    supportFinancialTransaction?: SupportFinancialTransactions;
}

export interface SimpleBranchDto {
    id?: number;
    name?: string | null;
    code?: string | null;
}

export interface SimpleCurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
}

export interface SimpleTreasuryDto {
    id?: number;
    name?: string | null;
}

export interface SupplierDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    vatTRN?: string | null;
    active?: boolean;
}

export interface SupplierDtoIPaginatedList {
    readonly items?: SupplierDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum SupportFinancialTransactions {
    Income = "Income",
    Expense = "Expense",
    Both = "Both",
}

export enum TransactionActions {
    Create = "Create",
    Cancel = "Cancel",
    Refund = "Refund",
    Cash = "Cash",
    Approve = "Approve",
    Reject = "Reject",
    Edit = "Edit",
}

export enum TransactionStatuses {
    PendingForCompliance = "PendingForCompliance",
    Blocked = "Blocked",
    PendingForCash = "PendingForCash",
    Completed = "Completed",
    PendingForCancel = "PendingForCancel",
    Canceled = "Canceled",
    PendingForRefund = "PendingForRefund",
    Refunded = "Refunded",
    ReadyForDelivery = "ReadyForDelivery",
    Delivered = "Delivered",
    PendingForEdit = "PendingForEdit",
    BlockedForRefund = "BlockedForRefund",
    BlockedForReserve = "BlockedForReserve",
    PendingForApproval = "PendingForApproval",
    Rejected = "Rejected",
    PendingForSenderApproval = "PendingForSenderApproval",
    PendingForReceiverApproval = "PendingForReceiverApproval",
    PendingForSenderCash = "PendingForSenderCash",
    PendingForReceiverCash = "PendingForReceiverCash",
    ComplianceProcessing = "ComplianceProcessing",
}

export enum TransactionTypes {
    FC_Sale = "FC_Sale",
    FC_Purchase = "FC_Purchase",
    SendMoney = "SendMoney",
    ReceiveMoney = "ReceiveMoney",
    Income = "Income",
    Expenses = "Expenses",
    InternalTransfer = "InternalTransfer",
    ExternalTransfer = "ExternalTransfer",
    StockTransaction = "StockTransaction",
}

export enum TransfersOperators {
    OR = "OR",
    AND = "AND",
}

export interface TreasuryBalanceDto {
    balance?: number;
    currency?: SimpleCurrencyDto;
}

export interface TreasuryDto {
    id?: number;
    name?: string | null;
    number?: string | null;
    branch?: SimpleBranchDto;
    type?: TreasuryTypes;
    active?: boolean;
    responsibleUser?: LookupApplicationUserDto;
    balances?: TreasuryBalanceDto[] | null;
}

export interface TreasuryListDto {
    id?: number;
    name?: string | null;
    number?: string | null;
    branch?: SimpleBranchDto;
    type?: TreasuryTypes;
    active?: boolean;
    responsibleUser?: LookupApplicationUserDto;
}

export interface TreasuryListDtoIPaginatedList {
    readonly items?: TreasuryListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface TreasuryLookupDto {
    id?: number;
    name?: string | null;
    number?: string | null;
}

export enum TreasuryTypes {
    Cash = "Cash",
    Bank = "Bank",
}

export interface UpdateFinancialAccountDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    type?: FinancialAccountTypes;
    accountId: number;
}

export interface UpdateSupplierDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
    vatTRN?: string | null;
}

export interface UpdateTreasuryDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    responsibleUserId: number;
}

export interface VatRegisterDetailedModel {
    transactionNumber?: string | null;
    createdDate?: string;
    paymentDate?: string;
    supplierName?: string | null;
    supplierTRN?: string | null;
    description?: string | null;
}

export enum VatRegisterResultTypes {
    Detailed = "Detailed",
    Summary = "Summary",
}

export interface VatRegisterSummaryModel {
    transactionType?: TransactionTypes;
    taxableAmount?: number;
    vatAmount?: number;
    detailes?: VatRegisterDetailedModel;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}