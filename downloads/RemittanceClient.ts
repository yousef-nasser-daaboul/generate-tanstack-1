//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class CounterPartyClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CounterPartyDto> {
        let url_ = this.baseUrl + "/api/Remittance/CounterParty/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CounterPartyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CounterPartyDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CounterPartyDto>(null as any);
    }

    /**
     * @param name (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(name: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CounterPartyDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/CounterParty/GetPaginatedList?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<CounterPartyDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CounterPartyDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CounterPartyDtoIPaginatedList>(null as any);
    }
}

export class DeliveryMethodClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullDeliveryMethodDto> {
        let url_ = this.baseUrl + "/api/Remittance/DeliveryMethod/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullDeliveryMethodDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullDeliveryMethodDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullDeliveryMethodDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<DeliveryMethodDto> {
        let url_ = this.baseUrl + "/api/Remittance/DeliveryMethod/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<DeliveryMethodDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<DeliveryMethodDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeliveryMethodDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param name (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, name: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<DeliveryMethodDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/DeliveryMethod/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<DeliveryMethodDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<DeliveryMethodDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeliveryMethodDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<DeliveryMethodDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/DeliveryMethod/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<DeliveryMethodDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<DeliveryMethodDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeliveryMethodDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateDeliveryMethodDto | undefined, signal?: AbortSignal): Promise<UpdateDeliveryMethodDto> {
        let url_ = this.baseUrl + "/api/Remittance/DeliveryMethod/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateDeliveryMethodDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateDeliveryMethodDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateDeliveryMethodDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/DeliveryMethod/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ExportLogClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportLogDto> {
        let url_ = this.baseUrl + "/api/Remittance/ExportLog/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ExportLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportLogDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportLogDto>(null as any);
    }

    /**
     * @param name (optional) 
     * @param fileName (optional) 
     * @param templateName (optional) 
     * @param userIds (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param successRecordsRange_From (optional) 
     * @param successRecordsRange_To (optional) 
     * @param failRecordsRange_From (optional) 
     * @param failRecordsRange_To (optional) 
     * @param templateId (optional) 
     * @param providerIds (optional) 
     * @param createdBy (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(name: string | undefined, fileName: string | undefined, templateName: string | undefined, userIds: number[] | undefined, date_From: string | undefined, date_To: string | undefined, successRecordsRange_From: number | undefined, successRecordsRange_To: number | undefined, failRecordsRange_From: number | undefined, failRecordsRange_To: number | undefined, templateId: number | undefined, providerIds: number[] | undefined, createdBy: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportLogDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/ExportLog/GetPaginatedList?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (templateName === null)
            throw new Error("The parameter 'templateName' cannot be null.");
        else if (templateName !== undefined)
            url_ += "TemplateName=" + encodeURIComponent("" + templateName) + "&";
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "UserIds=" + encodeURIComponent("" + item) + "&"; });
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (successRecordsRange_From === null)
            throw new Error("The parameter 'successRecordsRange_From' cannot be null.");
        else if (successRecordsRange_From !== undefined)
            url_ += "SuccessRecordsRange.From=" + encodeURIComponent("" + successRecordsRange_From) + "&";
        if (successRecordsRange_To === null)
            throw new Error("The parameter 'successRecordsRange_To' cannot be null.");
        else if (successRecordsRange_To !== undefined)
            url_ += "SuccessRecordsRange.To=" + encodeURIComponent("" + successRecordsRange_To) + "&";
        if (failRecordsRange_From === null)
            throw new Error("The parameter 'failRecordsRange_From' cannot be null.");
        else if (failRecordsRange_From !== undefined)
            url_ += "FailRecordsRange.From=" + encodeURIComponent("" + failRecordsRange_From) + "&";
        if (failRecordsRange_To === null)
            throw new Error("The parameter 'failRecordsRange_To' cannot be null.");
        else if (failRecordsRange_To !== undefined)
            url_ += "FailRecordsRange.To=" + encodeURIComponent("" + failRecordsRange_To) + "&";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "TemplateId=" + encodeURIComponent("" + templateId) + "&";
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (createdBy === null)
            throw new Error("The parameter 'createdBy' cannot be null.");
        else if (createdBy !== undefined)
            url_ += "CreatedBy=" + encodeURIComponent("" + createdBy) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<ExportLogDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportLogDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportLogDtoIPaginatedList>(null as any);
    }
}

export class ExportRecordClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportRecordDto> {
        let url_ = this.baseUrl + "/api/Remittance/ExportRecord/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<ExportRecordDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportRecordDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportRecordDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportRecordDto> {
        let url_ = this.baseUrl + "/api/Remittance/ExportRecord/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ExportRecordDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportRecordDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportRecordDto>(null as any);
    }

    /**
     * @param exportLogId (optional) 
     * @param sendTransactionId (optional) 
     * @param status (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(exportLogId: number | undefined, sendTransactionId: number | undefined, status: ExportRecordStatus[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportRecordDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/ExportRecord/GetPaginatedList?";
        if (exportLogId === null)
            throw new Error("The parameter 'exportLogId' cannot be null.");
        else if (exportLogId !== undefined)
            url_ += "ExportLogId=" + encodeURIComponent("" + exportLogId) + "&";
        if (sendTransactionId === null)
            throw new Error("The parameter 'sendTransactionId' cannot be null.");
        else if (sendTransactionId !== undefined)
            url_ += "SendTransactionId=" + encodeURIComponent("" + sendTransactionId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<ExportRecordDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportRecordDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportRecordDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeResultStatus(branchIdHeader: string | undefined, body: ChangeExportRecordResultStatusDto | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/ExportRecord/ChangeResultStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeResultStatus(_response);
        });
    }

    protected processChangeResultStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ExportTemplateClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportTemplateDto> {
        let url_ = this.baseUrl + "/api/Remittance/ExportTemplate/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<ExportTemplateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportTemplateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportTemplateDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportTemplateDto> {
        let url_ = this.baseUrl + "/api/Remittance/ExportTemplate/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ExportTemplateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportTemplateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportTemplateDto>(null as any);
    }

    /**
     * @param templateName (optional) 
     * @param providerId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(templateName: string | undefined, providerId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportTemplateDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/ExportTemplate/GetPaginatedList?";
        if (templateName === null)
            throw new Error("The parameter 'templateName' cannot be null.");
        else if (templateName !== undefined)
            url_ += "TemplateName=" + encodeURIComponent("" + templateName) + "&";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "ProviderId=" + encodeURIComponent("" + providerId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<ExportTemplateDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportTemplateDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportTemplateDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param providerId (optional) 
     * @param templateName (optional) 
     * @param templateFile (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, providerId: number | undefined, templateName: string | undefined, templateFile: FileParameter | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/ExportTemplate/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (providerId === null || providerId === undefined)
            throw new Error("The parameter 'providerId' cannot be null.");
        else
            content_.append("ProviderId", providerId.toString());
        if (templateName === null || templateName === undefined)
            throw new Error("The parameter 'templateName' cannot be null.");
        else
            content_.append("TemplateName", templateName.toString());
        if (templateFile === null || templateFile === undefined)
            throw new Error("The parameter 'templateFile' cannot be null.");
        else
            content_.append("TemplateFile", templateFile.data, templateFile.fileName ? templateFile.fileName : "TemplateFile");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param templateName (optional) 
     * @param templateFile (optional) 
     * @param id (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, templateName: string | undefined, templateFile: FileParameter | undefined, id: number | undefined, signal?: AbortSignal): Promise<UpdateExportTemplateDto> {
        let url_ = this.baseUrl + "/api/Remittance/ExportTemplate/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (templateName === null || templateName === undefined)
            throw new Error("The parameter 'templateName' cannot be null.");
        else
            content_.append("TemplateName", templateName.toString());
        if (templateFile === null || templateFile === undefined)
            throw new Error("The parameter 'templateFile' cannot be null.");
        else
            content_.append("TemplateFile", templateFile.data, templateFile.fileName ? templateFile.fileName : "TemplateFile");
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateExportTemplateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateExportTemplateDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateExportTemplateDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Remittance/ExportTemplate/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class FeeProfileClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullFeeProfileDto> {
        let url_ = this.baseUrl + "/api/Remittance/FeeProfile/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullFeeProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullFeeProfileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullFeeProfileDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateFeeProfileDto | undefined, signal?: AbortSignal): Promise<UpdateFeeProfileDto> {
        let url_ = this.baseUrl + "/api/Remittance/FeeProfile/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateFeeProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateFeeProfileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateFeeProfileDto>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookupList(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FeeProfileLookupDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/FeeProfile/GetLookupList?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookupList(_response);
        });
    }

    protected processGetLookupList(response: AxiosResponse): Promise<FeeProfileLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FeeProfileLookupDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FeeProfileLookupDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddFeeProfileDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/FeeProfile/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/FeeProfile/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/FeeProfile/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FeeProfileDto> {
        let url_ = this.baseUrl + "/api/Remittance/FeeProfile/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<FeeProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FeeProfileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FeeProfileDto>(null as any);
    }

    /**
     * @param active (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(active: boolean | undefined, pageIndex: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FeeProfileDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/FeeProfile/GetPaginatedList?";
        if (active === null)
            throw new Error("The parameter 'active' cannot be null.");
        else if (active !== undefined)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<FeeProfileDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FeeProfileDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FeeProfileDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FeeProfileDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/FeeProfile/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<FeeProfileDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FeeProfileDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FeeProfileDto[]>(null as any);
    }
}

export class IFSCClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param code (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getBankInformationByCode(code: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<IFSCDto> {
        let url_ = this.baseUrl + "/api/Remittance/IFSC/GetBankInformationByCode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBankInformationByCode(_response);
        });
    }

    protected processGetBankInformationByCode(response: AxiosResponse): Promise<IFSCDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<IFSCDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IFSCDto>(null as any);
    }
}

export class MarginClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullMarginDto> {
        let url_ = this.baseUrl + "/api/Remittance/Margin/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullMarginDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullMarginDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullMarginDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<MarginDto> {
        let url_ = this.baseUrl + "/api/Remittance/Margin/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<MarginDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<MarginDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MarginDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<MarginListDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/Margin/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<MarginListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<MarginListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MarginListDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateMarginDto | undefined, signal?: AbortSignal): Promise<UpdateMarginDto> {
        let url_ = this.baseUrl + "/api/Remittance/Margin/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateMarginDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateMarginDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateMarginDto>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookupList(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<MarginLookupDto> {
        let url_ = this.baseUrl + "/api/Remittance/Margin/GetLookupList?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookupList(_response);
        });
    }

    protected processGetLookupList(response: AxiosResponse): Promise<MarginLookupDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<MarginLookupDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MarginLookupDto>(null as any);
    }

    /**
     * @param amount (optional) 
     * @param providerId (optional) 
     * @param sendCurrencyId (optional) 
     * @param receiveCurrencyId (optional) 
     * @param countryId (optional) 
     * @param deliveryMethodId (optional) 
     * @param branchId (optional) 
     * @param isSend (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getMargins(amount: number | undefined, providerId: number | undefined, sendCurrencyId: number | undefined, receiveCurrencyId: number | undefined, countryId: number | undefined, deliveryMethodId: number | undefined, branchId: number | undefined, isSend: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<MarginDetailDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/Margin/GetMargins?";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "ProviderId=" + encodeURIComponent("" + providerId) + "&";
        if (sendCurrencyId === null)
            throw new Error("The parameter 'sendCurrencyId' cannot be null.");
        else if (sendCurrencyId !== undefined)
            url_ += "SendCurrencyId=" + encodeURIComponent("" + sendCurrencyId) + "&";
        if (receiveCurrencyId === null)
            throw new Error("The parameter 'receiveCurrencyId' cannot be null.");
        else if (receiveCurrencyId !== undefined)
            url_ += "ReceiveCurrencyId=" + encodeURIComponent("" + receiveCurrencyId) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (deliveryMethodId === null)
            throw new Error("The parameter 'deliveryMethodId' cannot be null.");
        else if (deliveryMethodId !== undefined)
            url_ += "DeliveryMethodId=" + encodeURIComponent("" + deliveryMethodId) + "&";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "BranchId=" + encodeURIComponent("" + branchId) + "&";
        if (isSend === null)
            throw new Error("The parameter 'isSend' cannot be null.");
        else if (isSend !== undefined)
            url_ += "IsSend=" + encodeURIComponent("" + isSend) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMargins(_response);
        });
    }

    protected processGetMargins(response: AxiosResponse): Promise<MarginDetailDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<MarginDetailDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MarginDetailDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddMarginDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/Margin/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/Margin/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/Margin/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ProviderClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ProviderDto> {
        let url_ = this.baseUrl + "/api/Remittance/Provider/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ProviderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ProviderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProviderDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getToUpdate(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FullProviderDto> {
        let url_ = this.baseUrl + "/api/Remittance/Provider/GetToUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetToUpdate(_response);
        });
    }

    protected processGetToUpdate(response: AxiosResponse): Promise<FullProviderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FullProviderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FullProviderDto>(null as any);
    }

    /**
     * @param name (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(name: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleProviderDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/Provider/GetList?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<SimpleProviderDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleProviderDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleProviderDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param name (optional) 
     * @param nameLang (optional) 
     * @param description (optional) 
     * @param descriptionLang (optional) 
     * @param integrationType (optional) 
     * @param settlementType (optional) 
     * @param supportedTransaction (optional) 
     * @param logo (optional) 
     * @param countryId (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, name: string | undefined, nameLang: string | undefined, description: string | undefined, descriptionLang: string | undefined, integrationType: ProviderTypes | undefined, settlementType: SettlementTypes | undefined, supportedTransaction: SupportedTransactions | undefined, logo: FileParameter | undefined, countryId: number | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/Provider/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (nameLang === null || nameLang === undefined)
            throw new Error("The parameter 'nameLang' cannot be null.");
        else
            content_.append("NameLang", nameLang.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (descriptionLang === null || descriptionLang === undefined)
            throw new Error("The parameter 'descriptionLang' cannot be null.");
        else
            content_.append("DescriptionLang", descriptionLang.toString());
        if (integrationType === null || integrationType === undefined)
            throw new Error("The parameter 'integrationType' cannot be null.");
        else
            content_.append("IntegrationType", integrationType.toString());
        if (settlementType === null || settlementType === undefined)
            throw new Error("The parameter 'settlementType' cannot be null.");
        else
            content_.append("SettlementType", settlementType.toString());
        if (supportedTransaction === null || supportedTransaction === undefined)
            throw new Error("The parameter 'supportedTransaction' cannot be null.");
        else
            content_.append("SupportedTransaction", supportedTransaction.toString());
        if (logo === null || logo === undefined)
            throw new Error("The parameter 'logo' cannot be null.");
        else
            content_.append("Logo", logo.data, logo.fileName ? logo.fileName : "Logo");
        if (countryId === null || countryId === undefined)
            throw new Error("The parameter 'countryId' cannot be null.");
        else
            content_.append("CountryId", countryId.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param name (optional) 
     * @param nameLang (optional) 
     * @param description (optional) 
     * @param descriptionLang (optional) 
     * @param integrationType (optional) 
     * @param settlementType (optional) 
     * @param supportedTransaction (optional) 
     * @param logo (optional) 
     * @param countryId (optional) 
     * @param ourSendFeeProfileId (optional) 
     * @param providerSendFeeProfileId (optional) 
     * @param ourReceiveFeeProfileId (optional) 
     * @param providerReceiveFeeProfileId (optional) 
     * @param id (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, name: string | undefined, nameLang: string | undefined, description: string | undefined, descriptionLang: string | undefined, integrationType: ProviderTypes | undefined, settlementType: SettlementTypes | undefined, supportedTransaction: SupportedTransactions | undefined, logo: FileParameter | undefined, countryId: number | undefined, ourSendFeeProfileId: number | undefined, providerSendFeeProfileId: number | undefined, ourReceiveFeeProfileId: number | undefined, providerReceiveFeeProfileId: number | undefined, id: number | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/Provider/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (nameLang === null || nameLang === undefined)
            throw new Error("The parameter 'nameLang' cannot be null.");
        else
            content_.append("NameLang", nameLang.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (descriptionLang === null || descriptionLang === undefined)
            throw new Error("The parameter 'descriptionLang' cannot be null.");
        else
            content_.append("DescriptionLang", descriptionLang.toString());
        if (integrationType === null || integrationType === undefined)
            throw new Error("The parameter 'integrationType' cannot be null.");
        else
            content_.append("IntegrationType", integrationType.toString());
        if (settlementType === null || settlementType === undefined)
            throw new Error("The parameter 'settlementType' cannot be null.");
        else
            content_.append("SettlementType", settlementType.toString());
        if (supportedTransaction === null || supportedTransaction === undefined)
            throw new Error("The parameter 'supportedTransaction' cannot be null.");
        else
            content_.append("SupportedTransaction", supportedTransaction.toString());
        if (logo === null || logo === undefined)
            throw new Error("The parameter 'logo' cannot be null.");
        else
            content_.append("Logo", logo.data, logo.fileName ? logo.fileName : "Logo");
        if (countryId === null || countryId === undefined)
            throw new Error("The parameter 'countryId' cannot be null.");
        else
            content_.append("CountryId", countryId.toString());
        if (ourSendFeeProfileId === null || ourSendFeeProfileId === undefined)
            throw new Error("The parameter 'ourSendFeeProfileId' cannot be null.");
        else
            content_.append("OurSendFeeProfileId", ourSendFeeProfileId.toString());
        if (providerSendFeeProfileId === null || providerSendFeeProfileId === undefined)
            throw new Error("The parameter 'providerSendFeeProfileId' cannot be null.");
        else
            content_.append("ProviderSendFeeProfileId", providerSendFeeProfileId.toString());
        if (ourReceiveFeeProfileId === null || ourReceiveFeeProfileId === undefined)
            throw new Error("The parameter 'ourReceiveFeeProfileId' cannot be null.");
        else
            content_.append("OurReceiveFeeProfileId", ourReceiveFeeProfileId.toString());
        if (providerReceiveFeeProfileId === null || providerReceiveFeeProfileId === undefined)
            throw new Error("The parameter 'providerReceiveFeeProfileId' cannot be null.");
        else
            content_.append("ProviderReceiveFeeProfileId", providerReceiveFeeProfileId.toString());
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Remittance/Provider/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/Provider/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param usingInFilter (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getLookups(usingInFilter: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleProviderLookupDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/Provider/GetLookups?";
        if (usingInFilter === null)
            throw new Error("The parameter 'usingInFilter' cannot be null.");
        else if (usingInFilter !== undefined)
            url_ += "usingInFilter=" + encodeURIComponent("" + usingInFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLookups(_response);
        });
    }

    protected processGetLookups(response: AxiosResponse): Promise<SimpleProviderLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleProviderLookupDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleProviderLookupDto[]>(null as any);
    }
}

export class ProviderSettlementCurrenciesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param providerId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(providerId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ProviderSettlementCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/ProviderSettlementCurrencies/GetList?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<ProviderSettlementCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ProviderSettlementCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProviderSettlementCurrencyDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param providerId (optional) 
     * @param settlementCurrencyId (optional) 
     * @param settlementRate (optional) 
     * @param creditLimit (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, providerId: number | undefined, settlementCurrencyId: number | undefined, settlementRate: number | undefined, creditLimit: number | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/ProviderSettlementCurrencies/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (providerId === null || providerId === undefined)
            throw new Error("The parameter 'providerId' cannot be null.");
        else
            content_.append("ProviderId", providerId.toString());
        if (settlementCurrencyId === null || settlementCurrencyId === undefined)
            throw new Error("The parameter 'settlementCurrencyId' cannot be null.");
        else
            content_.append("SettlementCurrencyId", settlementCurrencyId.toString());
        if (settlementRate === null || settlementRate === undefined)
            throw new Error("The parameter 'settlementRate' cannot be null.");
        else
            content_.append("SettlementRate", settlementRate.toString());
        if (creditLimit === null || creditLimit === undefined)
            throw new Error("The parameter 'creditLimit' cannot be null.");
        else
            content_.append("CreditLimit", creditLimit.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateProviderSettlementCurrencyDto | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/ProviderSettlementCurrencies/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/ProviderSettlementCurrencies/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/ProviderSettlementCurrencies/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ProviderStockCurrenciesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param providerId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(providerId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ProviderStockCurrencyListDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/ProviderStockCurrencies/GetList?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<ProviderStockCurrencyListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ProviderStockCurrencyListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProviderStockCurrencyListDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateProviderStockCurrencyDto | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/ProviderStockCurrencies/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/ProviderStockCurrencies/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ReceiveProfileClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param providerId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getReceiveCurrencies(providerId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveProfile/GetReceiveCurrencies?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceiveCurrencies(_response);
        });
    }

    protected processGetReceiveCurrencies(response: AxiosResponse): Promise<SimpleCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleCurrencyDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ReceiveProfileDto> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveProfile/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ReceiveProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ReceiveProfileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiveProfileDto>(null as any);
    }

    /**
     * @param providerId (optional) 
     * @param sourceCountryIds (optional) 
     * @param receiveCurrencyIds (optional) 
     * @param deliveryMethodIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(providerId: number | undefined, sourceCountryIds: number[] | undefined, receiveCurrencyIds: number[] | undefined, deliveryMethodIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ReceiveProfileDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveProfile/GetList?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "ProviderId=" + encodeURIComponent("" + providerId) + "&";
        if (sourceCountryIds === null)
            throw new Error("The parameter 'sourceCountryIds' cannot be null.");
        else if (sourceCountryIds !== undefined)
            sourceCountryIds && sourceCountryIds.forEach(item => { url_ += "SourceCountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (receiveCurrencyIds === null)
            throw new Error("The parameter 'receiveCurrencyIds' cannot be null.");
        else if (receiveCurrencyIds !== undefined)
            receiveCurrencyIds && receiveCurrencyIds.forEach(item => { url_ += "ReceiveCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (deliveryMethodIds === null)
            throw new Error("The parameter 'deliveryMethodIds' cannot be null.");
        else if (deliveryMethodIds !== undefined)
            deliveryMethodIds && deliveryMethodIds.forEach(item => { url_ += "DeliveryMethodIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<ReceiveProfileDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ReceiveProfileDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiveProfileDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddReceiveProfileDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveProfile/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateReceiveProfileDto | undefined, signal?: AbortSignal): Promise<UpdateReceiveProfileDto> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveProfile/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UpdateReceiveProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UpdateReceiveProfileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateReceiveProfileDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveProfile/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveProfile/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ReceiveTransactionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param countryId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getReceiveProviders(countryId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleProviderDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/GetReceiveProviders?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceiveProviders(_response);
        });
    }

    protected processGetReceiveProviders(response: AxiosResponse): Promise<SimpleProviderDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleProviderDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleProviderDto[]>(null as any);
    }

    /**
     * @param providerId (optional) 
     * @param countryId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPayoutCurrencies(providerId: number | undefined, countryId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/GetPayoutCurrencies?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPayoutCurrencies(_response);
        });
    }

    protected processGetPayoutCurrencies(response: AxiosResponse): Promise<SimpleCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleCurrencyDto[]>(null as any);
    }

    /**
     * @param providerId (optional) 
     * @param countryId (optional) 
     * @param currencyId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getDeliveryMethods(providerId: number | undefined, countryId: number | undefined, currencyId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<DeliveryMethodDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/GetDeliveryMethods?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeliveryMethods(_response);
        });
    }

    protected processGetDeliveryMethods(response: AxiosResponse): Promise<DeliveryMethodDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<DeliveryMethodDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeliveryMethodDto[]>(null as any);
    }

    /**
     * @param name (optional) 
     * @param customerIdentityId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    senderSearch(name: string | undefined, customerIdentityId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CounterPartyDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/SenderSearch?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (customerIdentityId === null)
            throw new Error("The parameter 'customerIdentityId' cannot be null.");
        else if (customerIdentityId !== undefined)
            url_ += "customerIdentityId=" + encodeURIComponent("" + customerIdentityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSenderSearch(_response);
        });
    }

    protected processSenderSearch(response: AxiosResponse): Promise<CounterPartyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CounterPartyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CounterPartyDto[]>(null as any);
    }

    /**
     * @param providerId (optional) 
     * @param countryId (optional) 
     * @param currencyId (optional) 
     * @param deliveryMethodId (optional) 
     * @param amount (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getFees(providerId: number | undefined, countryId: number | undefined, currencyId: number | undefined, deliveryMethodId: number | undefined, amount: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FeeModel> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/GetFees?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (deliveryMethodId === null)
            throw new Error("The parameter 'deliveryMethodId' cannot be null.");
        else if (deliveryMethodId !== undefined)
            url_ += "deliveryMethodId=" + encodeURIComponent("" + deliveryMethodId) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFees(_response);
        });
    }

    protected processGetFees(response: AxiosResponse): Promise<FeeModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FeeModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FeeModel>(null as any);
    }

    /**
     * @param countryId (optional) 
     * @param providerId (optional) 
     * @param referenceNumber (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getReceivePermissions(countryId: number | undefined, providerId: number | undefined, referenceNumber: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ReceiveTransactionPermissions> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/GetReceivePermissions?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "ProviderId=" + encodeURIComponent("" + providerId) + "&";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "ReferenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceivePermissions(_response);
        });
    }

    protected processGetReceivePermissions(response: AxiosResponse): Promise<ReceiveTransactionPermissions> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ReceiveTransactionPermissions>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiveTransactionPermissions>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param reference (optional) 
     * @param providerId (optional) 
     * @param deliveryMethodId (optional) 
     * @param customerIdentityId (optional) 
     * @param delegateIdentityId (optional) 
     * @param branchId (optional) 
     * @param countryId (optional) 
     * @param payoutCurrencyId (optional) 
     * @param payoutFCAmount (optional) 
     * @param ourFees (optional) 
     * @param providerFees (optional) 
     * @param ourMarginDetailId (optional) 
     * @param purposeId (optional) 
     * @param sourceOfFundId (optional) 
     * @param message (optional) 
     * @param counterParty_Name (optional) 
     * @param counterParty_NameLang (optional) 
     * @param counterParty_Type (optional) 
     * @param counterParty_NationalityId (optional) 
     * @param counterParty_Address (optional) 
     * @param counterParty_Phone (optional) 
     * @param counterParty_RelationId (optional) 
     * @param counterParty_EmirateCode (optional) 
     * @param counterParty_NearestAirport (optional) 
     * @param counterParty_CounterPartyBank_BankCode (optional) 
     * @param counterParty_CounterPartyBank_BankName (optional) 
     * @param counterParty_CounterPartyBank_BranchCode (optional) 
     * @param counterParty_CounterPartyBank_BranchName (optional) 
     * @param counterParty_CounterPartyBank_BankAddress (optional) 
     * @param counterParty_CounterPartyBank_AccountNumber (optional) 
     * @param counterParty_CounterPartyBank_TransferMode (optional) 
     * @param attachment_Files (optional) 
     * @return Success
     */
    receive(branchIdHeader: string | undefined, reference: string | undefined, providerId: number | undefined, deliveryMethodId: number | undefined, customerIdentityId: number | undefined, delegateIdentityId: number | undefined, branchId: number | undefined, countryId: number | undefined, payoutCurrencyId: number | undefined, payoutFCAmount: number | undefined, ourFees: number | undefined, providerFees: number | undefined, ourMarginDetailId: number | undefined, purposeId: number | undefined, sourceOfFundId: number | undefined, message: string | undefined, counterParty_Name: string | undefined, counterParty_NameLang: string | undefined, counterParty_Type: CustomerTypes | undefined, counterParty_NationalityId: number | undefined, counterParty_Address: string | undefined, counterParty_Phone: string | undefined, counterParty_RelationId: number | undefined, counterParty_EmirateCode: string | undefined, counterParty_NearestAirport: string | undefined, counterParty_CounterPartyBank_BankCode: string | undefined, counterParty_CounterPartyBank_BankName: string | undefined, counterParty_CounterPartyBank_BranchCode: string | undefined, counterParty_CounterPartyBank_BranchName: string | undefined, counterParty_CounterPartyBank_BankAddress: string | undefined, counterParty_CounterPartyBank_AccountNumber: string | undefined, counterParty_CounterPartyBank_TransferMode: string | undefined, attachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<AddReceiveTransactionResultDto> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/Receive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (reference === null || reference === undefined)
            throw new Error("The parameter 'reference' cannot be null.");
        else
            content_.append("Reference", reference.toString());
        if (providerId === null || providerId === undefined)
            throw new Error("The parameter 'providerId' cannot be null.");
        else
            content_.append("ProviderId", providerId.toString());
        if (deliveryMethodId === null || deliveryMethodId === undefined)
            throw new Error("The parameter 'deliveryMethodId' cannot be null.");
        else
            content_.append("DeliveryMethodId", deliveryMethodId.toString());
        if (customerIdentityId === null || customerIdentityId === undefined)
            throw new Error("The parameter 'customerIdentityId' cannot be null.");
        else
            content_.append("CustomerIdentityId", customerIdentityId.toString());
        if (delegateIdentityId === null || delegateIdentityId === undefined)
            throw new Error("The parameter 'delegateIdentityId' cannot be null.");
        else
            content_.append("DelegateIdentityId", delegateIdentityId.toString());
        if (branchId === null || branchId === undefined)
            throw new Error("The parameter 'branchId' cannot be null.");
        else
            content_.append("BranchId", branchId.toString());
        if (countryId === null || countryId === undefined)
            throw new Error("The parameter 'countryId' cannot be null.");
        else
            content_.append("CountryId", countryId.toString());
        if (payoutCurrencyId === null || payoutCurrencyId === undefined)
            throw new Error("The parameter 'payoutCurrencyId' cannot be null.");
        else
            content_.append("PayoutCurrencyId", payoutCurrencyId.toString());
        if (payoutFCAmount === null || payoutFCAmount === undefined)
            throw new Error("The parameter 'payoutFCAmount' cannot be null.");
        else
            content_.append("PayoutFCAmount", payoutFCAmount.toString());
        if (ourFees === null || ourFees === undefined)
            throw new Error("The parameter 'ourFees' cannot be null.");
        else
            content_.append("OurFees", ourFees.toString());
        if (providerFees === null || providerFees === undefined)
            throw new Error("The parameter 'providerFees' cannot be null.");
        else
            content_.append("ProviderFees", providerFees.toString());
        if (ourMarginDetailId === null || ourMarginDetailId === undefined)
            throw new Error("The parameter 'ourMarginDetailId' cannot be null.");
        else
            content_.append("OurMarginDetailId", ourMarginDetailId.toString());
        if (purposeId === null || purposeId === undefined)
            throw new Error("The parameter 'purposeId' cannot be null.");
        else
            content_.append("PurposeId", purposeId.toString());
        if (sourceOfFundId === null || sourceOfFundId === undefined)
            throw new Error("The parameter 'sourceOfFundId' cannot be null.");
        else
            content_.append("SourceOfFundId", sourceOfFundId.toString());
        if (message === null || message === undefined)
            throw new Error("The parameter 'message' cannot be null.");
        else
            content_.append("Message", message.toString());
        if (counterParty_Name === null || counterParty_Name === undefined)
            throw new Error("The parameter 'counterParty_Name' cannot be null.");
        else
            content_.append("CounterParty.Name", counterParty_Name.toString());
        if (counterParty_NameLang === null || counterParty_NameLang === undefined)
            throw new Error("The parameter 'counterParty_NameLang' cannot be null.");
        else
            content_.append("CounterParty.NameLang", counterParty_NameLang.toString());
        if (counterParty_Type === null || counterParty_Type === undefined)
            throw new Error("The parameter 'counterParty_Type' cannot be null.");
        else
            content_.append("CounterParty.Type", counterParty_Type.toString());
        if (counterParty_NationalityId === null || counterParty_NationalityId === undefined)
            throw new Error("The parameter 'counterParty_NationalityId' cannot be null.");
        else
            content_.append("CounterParty.NationalityId", counterParty_NationalityId.toString());
        if (counterParty_Address === null || counterParty_Address === undefined)
            throw new Error("The parameter 'counterParty_Address' cannot be null.");
        else
            content_.append("CounterParty.Address", counterParty_Address.toString());
        if (counterParty_Phone === null || counterParty_Phone === undefined)
            throw new Error("The parameter 'counterParty_Phone' cannot be null.");
        else
            content_.append("CounterParty.Phone", counterParty_Phone.toString());
        if (counterParty_RelationId === null || counterParty_RelationId === undefined)
            throw new Error("The parameter 'counterParty_RelationId' cannot be null.");
        else
            content_.append("CounterParty.RelationId", counterParty_RelationId.toString());
        if (counterParty_EmirateCode === null || counterParty_EmirateCode === undefined)
            throw new Error("The parameter 'counterParty_EmirateCode' cannot be null.");
        else
            content_.append("CounterParty.EmirateCode", counterParty_EmirateCode.toString());
        if (counterParty_NearestAirport === null || counterParty_NearestAirport === undefined)
            throw new Error("The parameter 'counterParty_NearestAirport' cannot be null.");
        else
            content_.append("CounterParty.NearestAirport", counterParty_NearestAirport.toString());
        if (counterParty_CounterPartyBank_BankCode === null || counterParty_CounterPartyBank_BankCode === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BankCode' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BankCode", counterParty_CounterPartyBank_BankCode.toString());
        if (counterParty_CounterPartyBank_BankName === null || counterParty_CounterPartyBank_BankName === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BankName' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BankName", counterParty_CounterPartyBank_BankName.toString());
        if (counterParty_CounterPartyBank_BranchCode === null || counterParty_CounterPartyBank_BranchCode === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BranchCode' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BranchCode", counterParty_CounterPartyBank_BranchCode.toString());
        if (counterParty_CounterPartyBank_BranchName === null || counterParty_CounterPartyBank_BranchName === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BranchName' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BranchName", counterParty_CounterPartyBank_BranchName.toString());
        if (counterParty_CounterPartyBank_BankAddress === null || counterParty_CounterPartyBank_BankAddress === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BankAddress' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BankAddress", counterParty_CounterPartyBank_BankAddress.toString());
        if (counterParty_CounterPartyBank_AccountNumber === null || counterParty_CounterPartyBank_AccountNumber === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_AccountNumber' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.AccountNumber", counterParty_CounterPartyBank_AccountNumber.toString());
        if (counterParty_CounterPartyBank_TransferMode === null || counterParty_CounterPartyBank_TransferMode === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_TransferMode' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.TransferMode", counterParty_CounterPartyBank_TransferMode.toString());
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceive(_response);
        });
    }

    protected processReceive(response: AxiosResponse): Promise<AddReceiveTransactionResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AddReceiveTransactionResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddReceiveTransactionResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getReceive(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ReceiveTransactionDto> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/GetReceive?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceive(_response);
        });
    }

    protected processGetReceive(response: AxiosResponse): Promise<ReceiveTransactionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ReceiveTransactionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiveTransactionDto>(null as any);
    }

    /**
     * @param referenceNumber (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getReceiveByReferenceNumber(referenceNumber: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ReceiveTransactionDto> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/GetReceiveByReferenceNumber?";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "referenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceiveByReferenceNumber(_response);
        });
    }

    protected processGetReceiveByReferenceNumber(response: AxiosResponse): Promise<ReceiveTransactionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ReceiveTransactionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiveTransactionDto>(null as any);
    }

    /**
     * @param actionDate_From (optional) 
     * @param actionDate_To (optional) 
     * @param actions (optional) 
     * @param actionById (optional) 
     * @param assignedToId (optional) 
     * @param referanceNumber (optional) 
     * @param addComplianceLogs (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getReceiveActivityLog(actionDate_From: string | undefined, actionDate_To: string | undefined, actions: ActivityLogAction[] | undefined, actionById: number[] | undefined, assignedToId: number[] | undefined, referanceNumber: string | undefined, addComplianceLogs: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ActivityLogDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/GetReceiveActivityLog?";
        if (actionDate_From === null)
            throw new Error("The parameter 'actionDate_From' cannot be null.");
        else if (actionDate_From !== undefined)
            url_ += "ActionDate.From=" + encodeURIComponent("" + actionDate_From) + "&";
        if (actionDate_To === null)
            throw new Error("The parameter 'actionDate_To' cannot be null.");
        else if (actionDate_To !== undefined)
            url_ += "ActionDate.To=" + encodeURIComponent("" + actionDate_To) + "&";
        if (actions === null)
            throw new Error("The parameter 'actions' cannot be null.");
        else if (actions !== undefined)
            actions && actions.forEach(item => { url_ += "Actions=" + encodeURIComponent("" + item) + "&"; });
        if (actionById === null)
            throw new Error("The parameter 'actionById' cannot be null.");
        else if (actionById !== undefined)
            actionById && actionById.forEach(item => { url_ += "ActionById=" + encodeURIComponent("" + item) + "&"; });
        if (assignedToId === null)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else if (assignedToId !== undefined)
            assignedToId && assignedToId.forEach(item => { url_ += "AssignedToId=" + encodeURIComponent("" + item) + "&"; });
        if (referanceNumber === null)
            throw new Error("The parameter 'referanceNumber' cannot be null.");
        else if (referanceNumber !== undefined)
            url_ += "ReferanceNumber=" + encodeURIComponent("" + referanceNumber) + "&";
        if (addComplianceLogs === null)
            throw new Error("The parameter 'addComplianceLogs' cannot be null.");
        else if (addComplianceLogs !== undefined)
            url_ += "AddComplianceLogs=" + encodeURIComponent("" + addComplianceLogs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceiveActivityLog(_response);
        });
    }

    protected processGetReceiveActivityLog(response: AxiosResponse): Promise<ActivityLogDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ActivityLogDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityLogDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    print(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Remittance/ReceiveTransaction/Print?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrint(_response);
        });
    }

    protected processPrint(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class RemittanceTransactionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param key (optional) 
     * @param number (optional) 
     * @param customer (optional) 
     * @param countryId (optional) 
     * @param counterPartyId (optional) 
     * @param exported (optional) 
     * @param notExported (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param types (optional) 
     * @param statuses (optional) 
     * @param providerIds (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(key: string | undefined, number: string | undefined, customer: string | undefined, countryId: number | undefined, counterPartyId: number | undefined, exported: boolean | undefined, notExported: boolean | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, types: TransactionTypes[] | undefined, statuses: TransactionStatuses[] | undefined, providerIds: number[] | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RemittanceTransactionListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/RemittanceTransaction/GetPaginatedList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (customer === null)
            throw new Error("The parameter 'customer' cannot be null.");
        else if (customer !== undefined)
            url_ += "Customer=" + encodeURIComponent("" + customer) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (counterPartyId === null)
            throw new Error("The parameter 'counterPartyId' cannot be null.");
        else if (counterPartyId !== undefined)
            url_ += "CounterPartyId=" + encodeURIComponent("" + counterPartyId) + "&";
        if (exported === null)
            throw new Error("The parameter 'exported' cannot be null.");
        else if (exported !== undefined)
            url_ += "Exported=" + encodeURIComponent("" + exported) + "&";
        if (notExported === null)
            throw new Error("The parameter 'notExported' cannot be null.");
        else if (notExported !== undefined)
            url_ += "NotExported=" + encodeURIComponent("" + notExported) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<RemittanceTransactionListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RemittanceTransactionListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RemittanceTransactionListDtoIPaginatedList>(null as any);
    }

    /**
     * @param key (optional) 
     * @param number (optional) 
     * @param customer (optional) 
     * @param countryId (optional) 
     * @param counterPartyId (optional) 
     * @param exported (optional) 
     * @param notExported (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param types (optional) 
     * @param statuses (optional) 
     * @param providerIds (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    export(key: string | undefined, number: string | undefined, customer: string | undefined, countryId: number | undefined, counterPartyId: number | undefined, exported: boolean | undefined, notExported: boolean | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, types: TransactionTypes[] | undefined, statuses: TransactionStatuses[] | undefined, providerIds: number[] | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Remittance/RemittanceTransaction/Export?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (customer === null)
            throw new Error("The parameter 'customer' cannot be null.");
        else if (customer !== undefined)
            url_ += "Customer=" + encodeURIComponent("" + customer) + "&";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (counterPartyId === null)
            throw new Error("The parameter 'counterPartyId' cannot be null.");
        else if (counterPartyId !== undefined)
            url_ += "CounterPartyId=" + encodeURIComponent("" + counterPartyId) + "&";
        if (exported === null)
            throw new Error("The parameter 'exported' cannot be null.");
        else if (exported !== undefined)
            url_ += "Exported=" + encodeURIComponent("" + exported) + "&";
        if (notExported === null)
            throw new Error("The parameter 'notExported' cannot be null.");
        else if (notExported !== undefined)
            url_ += "NotExported=" + encodeURIComponent("" + notExported) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @return Success
     */
    addNewTransactions(branchIdHeader: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Remittance/RemittanceTransaction/AddNewTransactions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddNewTransactions(_response);
        });
    }

    protected processAddNewTransactions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ReportClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param providerIds (optional) 
     * @param countryIds (optional) 
     * @param receiver (optional) 
     * @param receiverSubTypes (optional) 
     * @param sender (optional) 
     * @param payoutAmount_From (optional) 
     * @param payoutAmount_To (optional) 
     * @param deliveryMethodIds (optional) 
     * @param branchIds (optional) 
     * @param transactionStatuses (optional) 
     * @param userIds (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    receive(date_From: string | undefined, date_To: string | undefined, providerIds: number[] | undefined, countryIds: number[] | undefined, receiver: string | undefined, receiverSubTypes: number[] | undefined, sender: string | undefined, payoutAmount_From: number | undefined, payoutAmount_To: number | undefined, deliveryMethodIds: number[] | undefined, branchIds: number[] | undefined, transactionStatuses: TransactionStatuses[] | undefined, userIds: number[] | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ReceiveReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/Report/Receive?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "CountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (receiver === null)
            throw new Error("The parameter 'receiver' cannot be null.");
        else if (receiver !== undefined)
            url_ += "Receiver=" + encodeURIComponent("" + receiver) + "&";
        if (receiverSubTypes === null)
            throw new Error("The parameter 'receiverSubTypes' cannot be null.");
        else if (receiverSubTypes !== undefined)
            receiverSubTypes && receiverSubTypes.forEach(item => { url_ += "ReceiverSubTypes=" + encodeURIComponent("" + item) + "&"; });
        if (sender === null)
            throw new Error("The parameter 'sender' cannot be null.");
        else if (sender !== undefined)
            url_ += "Sender=" + encodeURIComponent("" + sender) + "&";
        if (payoutAmount_From === null)
            throw new Error("The parameter 'payoutAmount_From' cannot be null.");
        else if (payoutAmount_From !== undefined)
            url_ += "PayoutAmount.From=" + encodeURIComponent("" + payoutAmount_From) + "&";
        if (payoutAmount_To === null)
            throw new Error("The parameter 'payoutAmount_To' cannot be null.");
        else if (payoutAmount_To !== undefined)
            url_ += "PayoutAmount.To=" + encodeURIComponent("" + payoutAmount_To) + "&";
        if (deliveryMethodIds === null)
            throw new Error("The parameter 'deliveryMethodIds' cannot be null.");
        else if (deliveryMethodIds !== undefined)
            deliveryMethodIds && deliveryMethodIds.forEach(item => { url_ += "DeliveryMethodIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (transactionStatuses === null)
            throw new Error("The parameter 'transactionStatuses' cannot be null.");
        else if (transactionStatuses !== undefined)
            transactionStatuses && transactionStatuses.forEach(item => { url_ += "TransactionStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "UserIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceive(_response);
        });
    }

    protected processReceive(response: AxiosResponse): Promise<ReceiveReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ReceiveReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiveReportModelIPaginatedList>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param providerIds (optional) 
     * @param sendToCountryIds (optional) 
     * @param receiver (optional) 
     * @param senderSubTypes (optional) 
     * @param sender (optional) 
     * @param sendCurrencyIds (optional) 
     * @param sendAmount_From (optional) 
     * @param sendAmount_To (optional) 
     * @param receivedCurrencyIds (optional) 
     * @param receiveAmount_From (optional) 
     * @param receiveAmount_To (optional) 
     * @param deliveryMethodIds (optional) 
     * @param branchIds (optional) 
     * @param transactionStatuses (optional) 
     * @param userIds (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    send(date_From: string | undefined, date_To: string | undefined, providerIds: number[] | undefined, sendToCountryIds: number[] | undefined, receiver: string | undefined, senderSubTypes: number[] | undefined, sender: string | undefined, sendCurrencyIds: number[] | undefined, sendAmount_From: number | undefined, sendAmount_To: number | undefined, receivedCurrencyIds: number[] | undefined, receiveAmount_From: number | undefined, receiveAmount_To: number | undefined, deliveryMethodIds: number[] | undefined, branchIds: number[] | undefined, transactionStatuses: TransactionStatuses[] | undefined, userIds: number[] | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SendReportModelIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/Report/Send?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (sendToCountryIds === null)
            throw new Error("The parameter 'sendToCountryIds' cannot be null.");
        else if (sendToCountryIds !== undefined)
            sendToCountryIds && sendToCountryIds.forEach(item => { url_ += "SendToCountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (receiver === null)
            throw new Error("The parameter 'receiver' cannot be null.");
        else if (receiver !== undefined)
            url_ += "Receiver=" + encodeURIComponent("" + receiver) + "&";
        if (senderSubTypes === null)
            throw new Error("The parameter 'senderSubTypes' cannot be null.");
        else if (senderSubTypes !== undefined)
            senderSubTypes && senderSubTypes.forEach(item => { url_ += "SenderSubTypes=" + encodeURIComponent("" + item) + "&"; });
        if (sender === null)
            throw new Error("The parameter 'sender' cannot be null.");
        else if (sender !== undefined)
            url_ += "Sender=" + encodeURIComponent("" + sender) + "&";
        if (sendCurrencyIds === null)
            throw new Error("The parameter 'sendCurrencyIds' cannot be null.");
        else if (sendCurrencyIds !== undefined)
            sendCurrencyIds && sendCurrencyIds.forEach(item => { url_ += "SendCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (sendAmount_From === null)
            throw new Error("The parameter 'sendAmount_From' cannot be null.");
        else if (sendAmount_From !== undefined)
            url_ += "SendAmount.From=" + encodeURIComponent("" + sendAmount_From) + "&";
        if (sendAmount_To === null)
            throw new Error("The parameter 'sendAmount_To' cannot be null.");
        else if (sendAmount_To !== undefined)
            url_ += "SendAmount.To=" + encodeURIComponent("" + sendAmount_To) + "&";
        if (receivedCurrencyIds === null)
            throw new Error("The parameter 'receivedCurrencyIds' cannot be null.");
        else if (receivedCurrencyIds !== undefined)
            receivedCurrencyIds && receivedCurrencyIds.forEach(item => { url_ += "ReceivedCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (receiveAmount_From === null)
            throw new Error("The parameter 'receiveAmount_From' cannot be null.");
        else if (receiveAmount_From !== undefined)
            url_ += "ReceiveAmount.From=" + encodeURIComponent("" + receiveAmount_From) + "&";
        if (receiveAmount_To === null)
            throw new Error("The parameter 'receiveAmount_To' cannot be null.");
        else if (receiveAmount_To !== undefined)
            url_ += "ReceiveAmount.To=" + encodeURIComponent("" + receiveAmount_To) + "&";
        if (deliveryMethodIds === null)
            throw new Error("The parameter 'deliveryMethodIds' cannot be null.");
        else if (deliveryMethodIds !== undefined)
            deliveryMethodIds && deliveryMethodIds.forEach(item => { url_ += "DeliveryMethodIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (transactionStatuses === null)
            throw new Error("The parameter 'transactionStatuses' cannot be null.");
        else if (transactionStatuses !== undefined)
            transactionStatuses && transactionStatuses.forEach(item => { url_ += "TransactionStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "UserIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSend(_response);
        });
    }

    protected processSend(response: AxiosResponse): Promise<SendReportModelIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SendReportModelIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SendReportModelIPaginatedList>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param providerIds (optional) 
     * @param sendToCountryIds (optional) 
     * @param receiver (optional) 
     * @param senderSubTypes (optional) 
     * @param sender (optional) 
     * @param sendCurrencyIds (optional) 
     * @param sendAmount_From (optional) 
     * @param sendAmount_To (optional) 
     * @param receivedCurrencyIds (optional) 
     * @param receiveAmount_From (optional) 
     * @param receiveAmount_To (optional) 
     * @param deliveryMethodIds (optional) 
     * @param branchIds (optional) 
     * @param transactionStatuses (optional) 
     * @param userIds (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportSend(date_From: string | undefined, date_To: string | undefined, providerIds: number[] | undefined, sendToCountryIds: number[] | undefined, receiver: string | undefined, senderSubTypes: number[] | undefined, sender: string | undefined, sendCurrencyIds: number[] | undefined, sendAmount_From: number | undefined, sendAmount_To: number | undefined, receivedCurrencyIds: number[] | undefined, receiveAmount_From: number | undefined, receiveAmount_To: number | undefined, deliveryMethodIds: number[] | undefined, branchIds: number[] | undefined, transactionStatuses: TransactionStatuses[] | undefined, userIds: number[] | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Remittance/Report/ExportSend?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (sendToCountryIds === null)
            throw new Error("The parameter 'sendToCountryIds' cannot be null.");
        else if (sendToCountryIds !== undefined)
            sendToCountryIds && sendToCountryIds.forEach(item => { url_ += "SendToCountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (receiver === null)
            throw new Error("The parameter 'receiver' cannot be null.");
        else if (receiver !== undefined)
            url_ += "Receiver=" + encodeURIComponent("" + receiver) + "&";
        if (senderSubTypes === null)
            throw new Error("The parameter 'senderSubTypes' cannot be null.");
        else if (senderSubTypes !== undefined)
            senderSubTypes && senderSubTypes.forEach(item => { url_ += "SenderSubTypes=" + encodeURIComponent("" + item) + "&"; });
        if (sender === null)
            throw new Error("The parameter 'sender' cannot be null.");
        else if (sender !== undefined)
            url_ += "Sender=" + encodeURIComponent("" + sender) + "&";
        if (sendCurrencyIds === null)
            throw new Error("The parameter 'sendCurrencyIds' cannot be null.");
        else if (sendCurrencyIds !== undefined)
            sendCurrencyIds && sendCurrencyIds.forEach(item => { url_ += "SendCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (sendAmount_From === null)
            throw new Error("The parameter 'sendAmount_From' cannot be null.");
        else if (sendAmount_From !== undefined)
            url_ += "SendAmount.From=" + encodeURIComponent("" + sendAmount_From) + "&";
        if (sendAmount_To === null)
            throw new Error("The parameter 'sendAmount_To' cannot be null.");
        else if (sendAmount_To !== undefined)
            url_ += "SendAmount.To=" + encodeURIComponent("" + sendAmount_To) + "&";
        if (receivedCurrencyIds === null)
            throw new Error("The parameter 'receivedCurrencyIds' cannot be null.");
        else if (receivedCurrencyIds !== undefined)
            receivedCurrencyIds && receivedCurrencyIds.forEach(item => { url_ += "ReceivedCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (receiveAmount_From === null)
            throw new Error("The parameter 'receiveAmount_From' cannot be null.");
        else if (receiveAmount_From !== undefined)
            url_ += "ReceiveAmount.From=" + encodeURIComponent("" + receiveAmount_From) + "&";
        if (receiveAmount_To === null)
            throw new Error("The parameter 'receiveAmount_To' cannot be null.");
        else if (receiveAmount_To !== undefined)
            url_ += "ReceiveAmount.To=" + encodeURIComponent("" + receiveAmount_To) + "&";
        if (deliveryMethodIds === null)
            throw new Error("The parameter 'deliveryMethodIds' cannot be null.");
        else if (deliveryMethodIds !== undefined)
            deliveryMethodIds && deliveryMethodIds.forEach(item => { url_ += "DeliveryMethodIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (transactionStatuses === null)
            throw new Error("The parameter 'transactionStatuses' cannot be null.");
        else if (transactionStatuses !== undefined)
            transactionStatuses && transactionStatuses.forEach(item => { url_ += "TransactionStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "UserIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportSend(_response);
        });
    }

    protected processExportSend(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param providerIds (optional) 
     * @param countryIds (optional) 
     * @param receiver (optional) 
     * @param receiverSubTypes (optional) 
     * @param sender (optional) 
     * @param payoutAmount_From (optional) 
     * @param payoutAmount_To (optional) 
     * @param deliveryMethodIds (optional) 
     * @param branchIds (optional) 
     * @param transactionStatuses (optional) 
     * @param userIds (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportReceive(date_From: string | undefined, date_To: string | undefined, providerIds: number[] | undefined, countryIds: number[] | undefined, receiver: string | undefined, receiverSubTypes: number[] | undefined, sender: string | undefined, payoutAmount_From: number | undefined, payoutAmount_To: number | undefined, deliveryMethodIds: number[] | undefined, branchIds: number[] | undefined, transactionStatuses: TransactionStatuses[] | undefined, userIds: number[] | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Remittance/Report/ExportReceive?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (providerIds === null)
            throw new Error("The parameter 'providerIds' cannot be null.");
        else if (providerIds !== undefined)
            providerIds && providerIds.forEach(item => { url_ += "ProviderIds=" + encodeURIComponent("" + item) + "&"; });
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "CountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (receiver === null)
            throw new Error("The parameter 'receiver' cannot be null.");
        else if (receiver !== undefined)
            url_ += "Receiver=" + encodeURIComponent("" + receiver) + "&";
        if (receiverSubTypes === null)
            throw new Error("The parameter 'receiverSubTypes' cannot be null.");
        else if (receiverSubTypes !== undefined)
            receiverSubTypes && receiverSubTypes.forEach(item => { url_ += "ReceiverSubTypes=" + encodeURIComponent("" + item) + "&"; });
        if (sender === null)
            throw new Error("The parameter 'sender' cannot be null.");
        else if (sender !== undefined)
            url_ += "Sender=" + encodeURIComponent("" + sender) + "&";
        if (payoutAmount_From === null)
            throw new Error("The parameter 'payoutAmount_From' cannot be null.");
        else if (payoutAmount_From !== undefined)
            url_ += "PayoutAmount.From=" + encodeURIComponent("" + payoutAmount_From) + "&";
        if (payoutAmount_To === null)
            throw new Error("The parameter 'payoutAmount_To' cannot be null.");
        else if (payoutAmount_To !== undefined)
            url_ += "PayoutAmount.To=" + encodeURIComponent("" + payoutAmount_To) + "&";
        if (deliveryMethodIds === null)
            throw new Error("The parameter 'deliveryMethodIds' cannot be null.");
        else if (deliveryMethodIds !== undefined)
            deliveryMethodIds && deliveryMethodIds.forEach(item => { url_ += "DeliveryMethodIds=" + encodeURIComponent("" + item) + "&"; });
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (transactionStatuses === null)
            throw new Error("The parameter 'transactionStatuses' cannot be null.");
        else if (transactionStatuses !== undefined)
            transactionStatuses && transactionStatuses.forEach(item => { url_ += "TransactionStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "UserIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportReceive(_response);
        });
    }

    protected processExportReceive(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param key (optional) 
     * @param type (optional) 
     * @param name (optional) 
     * @param nationalityIds (optional) 
     * @param relationIds (optional) 
     * @param countryIds (optional) 
     * @param phone (optional) 
     * @param address (optional) 
     * @param bankName (optional) 
     * @param bankCode (optional) 
     * @param accountNumber (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getCustomerBeneficiaries(customerId: number | undefined, key: string | undefined, type: CustomerTypes | undefined, name: string | undefined, nationalityIds: number[] | undefined, relationIds: number[] | undefined, countryIds: number[] | undefined, phone: string | undefined, address: string | undefined, bankName: string | undefined, bankCode: string | undefined, accountNumber: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CustomerBeneficiariesModel[]> {
        let url_ = this.baseUrl + "/api/Remittance/Report/GetCustomerBeneficiaries?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (nationalityIds === null)
            throw new Error("The parameter 'nationalityIds' cannot be null.");
        else if (nationalityIds !== undefined)
            nationalityIds && nationalityIds.forEach(item => { url_ += "NationalityIds=" + encodeURIComponent("" + item) + "&"; });
        if (relationIds === null)
            throw new Error("The parameter 'relationIds' cannot be null.");
        else if (relationIds !== undefined)
            relationIds && relationIds.forEach(item => { url_ += "RelationIds=" + encodeURIComponent("" + item) + "&"; });
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "CountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "Address=" + encodeURIComponent("" + address) + "&";
        if (bankName === null)
            throw new Error("The parameter 'bankName' cannot be null.");
        else if (bankName !== undefined)
            url_ += "BankName=" + encodeURIComponent("" + bankName) + "&";
        if (bankCode === null)
            throw new Error("The parameter 'bankCode' cannot be null.");
        else if (bankCode !== undefined)
            url_ += "BankCode=" + encodeURIComponent("" + bankCode) + "&";
        if (accountNumber === null)
            throw new Error("The parameter 'accountNumber' cannot be null.");
        else if (accountNumber !== undefined)
            url_ += "AccountNumber=" + encodeURIComponent("" + accountNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCustomerBeneficiaries(_response);
        });
    }

    protected processGetCustomerBeneficiaries(response: AxiosResponse): Promise<CustomerBeneficiariesModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CustomerBeneficiariesModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerBeneficiariesModel[]>(null as any);
    }
}

export class SendProfileClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param providerId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getSendCurrencies(providerId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SimpleCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/SendProfile/GetSendCurrencies?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSendCurrencies(_response);
        });
    }

    protected processGetSendCurrencies(response: AxiosResponse): Promise<SimpleCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SimpleCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimpleCurrencyDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SendProfileDto> {
        let url_ = this.baseUrl + "/api/Remittance/SendProfile/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<SendProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SendProfileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SendProfileDto>(null as any);
    }

    /**
     * @param providerId (optional) 
     * @param key (optional) 
     * @param receiveCountryIds (optional) 
     * @param sendCurrencyIds (optional) 
     * @param receiveCurrencyIds (optional) 
     * @param deliveryMethodIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(providerId: number | undefined, key: string | undefined, receiveCountryIds: number[] | undefined, sendCurrencyIds: number[] | undefined, receiveCurrencyIds: number[] | undefined, deliveryMethodIds: number[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SendProfileDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/SendProfile/GetList?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "ProviderId=" + encodeURIComponent("" + providerId) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (receiveCountryIds === null)
            throw new Error("The parameter 'receiveCountryIds' cannot be null.");
        else if (receiveCountryIds !== undefined)
            receiveCountryIds && receiveCountryIds.forEach(item => { url_ += "ReceiveCountryIds=" + encodeURIComponent("" + item) + "&"; });
        if (sendCurrencyIds === null)
            throw new Error("The parameter 'sendCurrencyIds' cannot be null.");
        else if (sendCurrencyIds !== undefined)
            sendCurrencyIds && sendCurrencyIds.forEach(item => { url_ += "SendCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (receiveCurrencyIds === null)
            throw new Error("The parameter 'receiveCurrencyIds' cannot be null.");
        else if (receiveCurrencyIds !== undefined)
            receiveCurrencyIds && receiveCurrencyIds.forEach(item => { url_ += "ReceiveCurrencyIds=" + encodeURIComponent("" + item) + "&"; });
        if (deliveryMethodIds === null)
            throw new Error("The parameter 'deliveryMethodIds' cannot be null.");
        else if (deliveryMethodIds !== undefined)
            deliveryMethodIds && deliveryMethodIds.forEach(item => { url_ += "DeliveryMethodIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<SendProfileDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SendProfileDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SendProfileDtoIPaginatedList>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    create(branchIdHeader: string | undefined, body: AddSendProfileDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/SendProfile/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    update(branchIdHeader: string | undefined, body: UpdateSendProfileDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/SendProfile/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeStatus(branchIdHeader: string | undefined, body: ChangeStatusModel | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Remittance/SendProfile/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Remittance/SendProfile/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class SendTransactionClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param sendToCountryId (optional) 
     * @param sendCurrencyId (optional) 
     * @param receiveCurrencyId (optional) 
     * @param deliveryMethodId (optional) 
     * @param amount (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getProfiles(sendToCountryId: number | undefined, sendCurrencyId: number | undefined, receiveCurrencyId: number | undefined, deliveryMethodId: number | undefined, amount: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SendProfileWithLogoDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/SendTransaction/GetProfiles?";
        if (sendToCountryId === null)
            throw new Error("The parameter 'sendToCountryId' cannot be null.");
        else if (sendToCountryId !== undefined)
            url_ += "SendToCountryId=" + encodeURIComponent("" + sendToCountryId) + "&";
        if (sendCurrencyId === null)
            throw new Error("The parameter 'sendCurrencyId' cannot be null.");
        else if (sendCurrencyId !== undefined)
            url_ += "SendCurrencyId=" + encodeURIComponent("" + sendCurrencyId) + "&";
        if (receiveCurrencyId === null)
            throw new Error("The parameter 'receiveCurrencyId' cannot be null.");
        else if (receiveCurrencyId !== undefined)
            url_ += "ReceiveCurrencyId=" + encodeURIComponent("" + receiveCurrencyId) + "&";
        if (deliveryMethodId === null)
            throw new Error("The parameter 'deliveryMethodId' cannot be null.");
        else if (deliveryMethodId !== undefined)
            url_ += "DeliveryMethodId=" + encodeURIComponent("" + deliveryMethodId) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfiles(_response);
        });
    }

    protected processGetProfiles(response: AxiosResponse): Promise<SendProfileWithLogoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SendProfileWithLogoDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SendProfileWithLogoDto[]>(null as any);
    }

    /**
     * @param sendToCountryId (optional) 
     * @param sendCurrencyId (optional) 
     * @param receiveCurrencyId (optional) 
     * @param deliveryMethodId (optional) 
     * @param amount (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getSendPermissions(sendToCountryId: number | undefined, sendCurrencyId: number | undefined, receiveCurrencyId: number | undefined, deliveryMethodId: number | undefined, amount: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SendTransactionPermissions> {
        let url_ = this.baseUrl + "/api/Remittance/SendTransaction/GetSendPermissions?";
        if (sendToCountryId === null)
            throw new Error("The parameter 'sendToCountryId' cannot be null.");
        else if (sendToCountryId !== undefined)
            url_ += "SendToCountryId=" + encodeURIComponent("" + sendToCountryId) + "&";
        if (sendCurrencyId === null)
            throw new Error("The parameter 'sendCurrencyId' cannot be null.");
        else if (sendCurrencyId !== undefined)
            url_ += "SendCurrencyId=" + encodeURIComponent("" + sendCurrencyId) + "&";
        if (receiveCurrencyId === null)
            throw new Error("The parameter 'receiveCurrencyId' cannot be null.");
        else if (receiveCurrencyId !== undefined)
            url_ += "ReceiveCurrencyId=" + encodeURIComponent("" + receiveCurrencyId) + "&";
        if (deliveryMethodId === null)
            throw new Error("The parameter 'deliveryMethodId' cannot be null.");
        else if (deliveryMethodId !== undefined)
            url_ += "DeliveryMethodId=" + encodeURIComponent("" + deliveryMethodId) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSendPermissions(_response);
        });
    }

    protected processGetSendPermissions(response: AxiosResponse): Promise<SendTransactionPermissions> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SendTransactionPermissions>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SendTransactionPermissions>(null as any);
    }

    /**
     * @param name (optional) 
     * @param customerIdentityId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    receiverSearch(name: string | undefined, customerIdentityId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<CounterPartyDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/SendTransaction/ReceiverSearch?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (customerIdentityId === null)
            throw new Error("The parameter 'customerIdentityId' cannot be null.");
        else if (customerIdentityId !== undefined)
            url_ += "customerIdentityId=" + encodeURIComponent("" + customerIdentityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceiverSearch(_response);
        });
    }

    protected processReceiverSearch(response: AxiosResponse): Promise<CounterPartyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CounterPartyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CounterPartyDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param withCash (optional) 
     * @param customerIdentityId (optional) 
     * @param delegateIdentityId (optional) 
     * @param payerName (optional) 
     * @param reference (optional) 
     * @param branchId (optional) 
     * @param countryId (optional) 
     * @param sendCurrencyId (optional) 
     * @param sendFCAmount (optional) 
     * @param receiveCurrencyId (optional) 
     * @param receiveAmount (optional) 
     * @param providerId (optional) 
     * @param sendProfileId (optional) 
     * @param deliveryMethodId (optional) 
     * @param purposeId (optional) 
     * @param sourceOfFundId (optional) 
     * @param message (optional) 
     * @param rate (optional) 
     * @param ourFees (optional) 
     * @param providerFees (optional) 
     * @param ourMarginDetailId (optional) 
     * @param counterParty_Name (optional) 
     * @param counterParty_NameLang (optional) 
     * @param counterParty_Type (optional) 
     * @param counterParty_NationalityId (optional) 
     * @param counterParty_Address (optional) 
     * @param counterParty_Phone (optional) 
     * @param counterParty_RelationId (optional) 
     * @param counterParty_EmirateCode (optional) 
     * @param counterParty_NearestAirport (optional) 
     * @param counterParty_CounterPartyBank_BankCode (optional) 
     * @param counterParty_CounterPartyBank_BankName (optional) 
     * @param counterParty_CounterPartyBank_BranchCode (optional) 
     * @param counterParty_CounterPartyBank_BranchName (optional) 
     * @param counterParty_CounterPartyBank_BankAddress (optional) 
     * @param counterParty_CounterPartyBank_AccountNumber (optional) 
     * @param counterParty_CounterPartyBank_TransferMode (optional) 
     * @param attachment_Files (optional) 
     * @return Success
     */
    send(branchIdHeader: string | undefined, withCash: boolean | undefined, customerIdentityId: number | undefined, delegateIdentityId: number | undefined, payerName: string | undefined, reference: string | undefined, branchId: number | undefined, countryId: number | undefined, sendCurrencyId: number | undefined, sendFCAmount: number | undefined, receiveCurrencyId: number | undefined, receiveAmount: number | undefined, providerId: number | undefined, sendProfileId: number | undefined, deliveryMethodId: number | undefined, purposeId: number | undefined, sourceOfFundId: number | undefined, message: string | undefined, rate: number | undefined, ourFees: number | undefined, providerFees: number | undefined, ourMarginDetailId: number | undefined, counterParty_Name: string | undefined, counterParty_NameLang: string | undefined, counterParty_Type: CustomerTypes | undefined, counterParty_NationalityId: number | undefined, counterParty_Address: string | undefined, counterParty_Phone: string | undefined, counterParty_RelationId: number | undefined, counterParty_EmirateCode: string | undefined, counterParty_NearestAirport: string | undefined, counterParty_CounterPartyBank_BankCode: string | undefined, counterParty_CounterPartyBank_BankName: string | undefined, counterParty_CounterPartyBank_BranchCode: string | undefined, counterParty_CounterPartyBank_BranchName: string | undefined, counterParty_CounterPartyBank_BankAddress: string | undefined, counterParty_CounterPartyBank_AccountNumber: string | undefined, counterParty_CounterPartyBank_TransferMode: string | undefined, attachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<AddSendTransactionResultDto> {
        let url_ = this.baseUrl + "/api/Remittance/SendTransaction/Send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (withCash === null || withCash === undefined)
            throw new Error("The parameter 'withCash' cannot be null.");
        else
            content_.append("WithCash", withCash.toString());
        if (customerIdentityId === null || customerIdentityId === undefined)
            throw new Error("The parameter 'customerIdentityId' cannot be null.");
        else
            content_.append("CustomerIdentityId", customerIdentityId.toString());
        if (delegateIdentityId === null || delegateIdentityId === undefined)
            throw new Error("The parameter 'delegateIdentityId' cannot be null.");
        else
            content_.append("DelegateIdentityId", delegateIdentityId.toString());
        if (payerName === null || payerName === undefined)
            throw new Error("The parameter 'payerName' cannot be null.");
        else
            content_.append("PayerName", payerName.toString());
        if (reference === null || reference === undefined)
            throw new Error("The parameter 'reference' cannot be null.");
        else
            content_.append("Reference", reference.toString());
        if (branchId === null || branchId === undefined)
            throw new Error("The parameter 'branchId' cannot be null.");
        else
            content_.append("BranchId", branchId.toString());
        if (countryId === null || countryId === undefined)
            throw new Error("The parameter 'countryId' cannot be null.");
        else
            content_.append("CountryId", countryId.toString());
        if (sendCurrencyId === null || sendCurrencyId === undefined)
            throw new Error("The parameter 'sendCurrencyId' cannot be null.");
        else
            content_.append("SendCurrencyId", sendCurrencyId.toString());
        if (sendFCAmount === null || sendFCAmount === undefined)
            throw new Error("The parameter 'sendFCAmount' cannot be null.");
        else
            content_.append("SendFCAmount", sendFCAmount.toString());
        if (receiveCurrencyId === null || receiveCurrencyId === undefined)
            throw new Error("The parameter 'receiveCurrencyId' cannot be null.");
        else
            content_.append("ReceiveCurrencyId", receiveCurrencyId.toString());
        if (receiveAmount === null || receiveAmount === undefined)
            throw new Error("The parameter 'receiveAmount' cannot be null.");
        else
            content_.append("ReceiveAmount", receiveAmount.toString());
        if (providerId === null || providerId === undefined)
            throw new Error("The parameter 'providerId' cannot be null.");
        else
            content_.append("ProviderId", providerId.toString());
        if (sendProfileId === null || sendProfileId === undefined)
            throw new Error("The parameter 'sendProfileId' cannot be null.");
        else
            content_.append("SendProfileId", sendProfileId.toString());
        if (deliveryMethodId === null || deliveryMethodId === undefined)
            throw new Error("The parameter 'deliveryMethodId' cannot be null.");
        else
            content_.append("DeliveryMethodId", deliveryMethodId.toString());
        if (purposeId === null || purposeId === undefined)
            throw new Error("The parameter 'purposeId' cannot be null.");
        else
            content_.append("PurposeId", purposeId.toString());
        if (sourceOfFundId === null || sourceOfFundId === undefined)
            throw new Error("The parameter 'sourceOfFundId' cannot be null.");
        else
            content_.append("SourceOfFundId", sourceOfFundId.toString());
        if (message === null || message === undefined)
            throw new Error("The parameter 'message' cannot be null.");
        else
            content_.append("Message", message.toString());
        if (rate === null || rate === undefined)
            throw new Error("The parameter 'rate' cannot be null.");
        else
            content_.append("Rate", rate.toString());
        if (ourFees === null || ourFees === undefined)
            throw new Error("The parameter 'ourFees' cannot be null.");
        else
            content_.append("OurFees", ourFees.toString());
        if (providerFees === null || providerFees === undefined)
            throw new Error("The parameter 'providerFees' cannot be null.");
        else
            content_.append("ProviderFees", providerFees.toString());
        if (ourMarginDetailId === null || ourMarginDetailId === undefined)
            throw new Error("The parameter 'ourMarginDetailId' cannot be null.");
        else
            content_.append("OurMarginDetailId", ourMarginDetailId.toString());
        if (counterParty_Name === null || counterParty_Name === undefined)
            throw new Error("The parameter 'counterParty_Name' cannot be null.");
        else
            content_.append("CounterParty.Name", counterParty_Name.toString());
        if (counterParty_NameLang === null || counterParty_NameLang === undefined)
            throw new Error("The parameter 'counterParty_NameLang' cannot be null.");
        else
            content_.append("CounterParty.NameLang", counterParty_NameLang.toString());
        if (counterParty_Type === null || counterParty_Type === undefined)
            throw new Error("The parameter 'counterParty_Type' cannot be null.");
        else
            content_.append("CounterParty.Type", counterParty_Type.toString());
        if (counterParty_NationalityId === null || counterParty_NationalityId === undefined)
            throw new Error("The parameter 'counterParty_NationalityId' cannot be null.");
        else
            content_.append("CounterParty.NationalityId", counterParty_NationalityId.toString());
        if (counterParty_Address === null || counterParty_Address === undefined)
            throw new Error("The parameter 'counterParty_Address' cannot be null.");
        else
            content_.append("CounterParty.Address", counterParty_Address.toString());
        if (counterParty_Phone === null || counterParty_Phone === undefined)
            throw new Error("The parameter 'counterParty_Phone' cannot be null.");
        else
            content_.append("CounterParty.Phone", counterParty_Phone.toString());
        if (counterParty_RelationId === null || counterParty_RelationId === undefined)
            throw new Error("The parameter 'counterParty_RelationId' cannot be null.");
        else
            content_.append("CounterParty.RelationId", counterParty_RelationId.toString());
        if (counterParty_EmirateCode === null || counterParty_EmirateCode === undefined)
            throw new Error("The parameter 'counterParty_EmirateCode' cannot be null.");
        else
            content_.append("CounterParty.EmirateCode", counterParty_EmirateCode.toString());
        if (counterParty_NearestAirport === null || counterParty_NearestAirport === undefined)
            throw new Error("The parameter 'counterParty_NearestAirport' cannot be null.");
        else
            content_.append("CounterParty.NearestAirport", counterParty_NearestAirport.toString());
        if (counterParty_CounterPartyBank_BankCode === null || counterParty_CounterPartyBank_BankCode === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BankCode' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BankCode", counterParty_CounterPartyBank_BankCode.toString());
        if (counterParty_CounterPartyBank_BankName === null || counterParty_CounterPartyBank_BankName === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BankName' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BankName", counterParty_CounterPartyBank_BankName.toString());
        if (counterParty_CounterPartyBank_BranchCode === null || counterParty_CounterPartyBank_BranchCode === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BranchCode' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BranchCode", counterParty_CounterPartyBank_BranchCode.toString());
        if (counterParty_CounterPartyBank_BranchName === null || counterParty_CounterPartyBank_BranchName === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BranchName' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BranchName", counterParty_CounterPartyBank_BranchName.toString());
        if (counterParty_CounterPartyBank_BankAddress === null || counterParty_CounterPartyBank_BankAddress === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BankAddress' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BankAddress", counterParty_CounterPartyBank_BankAddress.toString());
        if (counterParty_CounterPartyBank_AccountNumber === null || counterParty_CounterPartyBank_AccountNumber === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_AccountNumber' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.AccountNumber", counterParty_CounterPartyBank_AccountNumber.toString());
        if (counterParty_CounterPartyBank_TransferMode === null || counterParty_CounterPartyBank_TransferMode === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_TransferMode' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.TransferMode", counterParty_CounterPartyBank_TransferMode.toString());
        if (attachment_Files === null || attachment_Files === undefined)
            throw new Error("The parameter 'attachment_Files' cannot be null.");
        else
            attachment_Files.forEach(item_ => content_.append("Attachment.Files", item_.data, item_.fileName ? item_.fileName : "Attachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSend(_response);
        });
    }

    protected processSend(response: AxiosResponse): Promise<AddSendTransactionResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<AddSendTransactionResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddSendTransactionResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getSend(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SendTransactionDto> {
        let url_ = this.baseUrl + "/api/Remittance/SendTransaction/GetSend?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSend(_response);
        });
    }

    protected processGetSend(response: AxiosResponse): Promise<SendTransactionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SendTransactionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SendTransactionDto>(null as any);
    }

    /**
     * @param referenceNumber (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getSendByReferenceNumber(referenceNumber: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SendTransactionDto> {
        let url_ = this.baseUrl + "/api/Remittance/SendTransaction/GetSendByReferenceNumber?";
        if (referenceNumber === null)
            throw new Error("The parameter 'referenceNumber' cannot be null.");
        else if (referenceNumber !== undefined)
            url_ += "referenceNumber=" + encodeURIComponent("" + referenceNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSendByReferenceNumber(_response);
        });
    }

    protected processGetSendByReferenceNumber(response: AxiosResponse): Promise<SendTransactionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SendTransactionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SendTransactionDto>(null as any);
    }

    /**
     * @param actionDate_From (optional) 
     * @param actionDate_To (optional) 
     * @param actions (optional) 
     * @param actionById (optional) 
     * @param assignedToId (optional) 
     * @param referanceNumber (optional) 
     * @param addComplianceLogs (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getSendActivityLog(actionDate_From: string | undefined, actionDate_To: string | undefined, actions: ActivityLogAction[] | undefined, actionById: number[] | undefined, assignedToId: number[] | undefined, referanceNumber: string | undefined, addComplianceLogs: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ActivityLogDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/SendTransaction/GetSendActivityLog?";
        if (actionDate_From === null)
            throw new Error("The parameter 'actionDate_From' cannot be null.");
        else if (actionDate_From !== undefined)
            url_ += "ActionDate.From=" + encodeURIComponent("" + actionDate_From) + "&";
        if (actionDate_To === null)
            throw new Error("The parameter 'actionDate_To' cannot be null.");
        else if (actionDate_To !== undefined)
            url_ += "ActionDate.To=" + encodeURIComponent("" + actionDate_To) + "&";
        if (actions === null)
            throw new Error("The parameter 'actions' cannot be null.");
        else if (actions !== undefined)
            actions && actions.forEach(item => { url_ += "Actions=" + encodeURIComponent("" + item) + "&"; });
        if (actionById === null)
            throw new Error("The parameter 'actionById' cannot be null.");
        else if (actionById !== undefined)
            actionById && actionById.forEach(item => { url_ += "ActionById=" + encodeURIComponent("" + item) + "&"; });
        if (assignedToId === null)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else if (assignedToId !== undefined)
            assignedToId && assignedToId.forEach(item => { url_ += "AssignedToId=" + encodeURIComponent("" + item) + "&"; });
        if (referanceNumber === null)
            throw new Error("The parameter 'referanceNumber' cannot be null.");
        else if (referanceNumber !== undefined)
            url_ += "ReferanceNumber=" + encodeURIComponent("" + referanceNumber) + "&";
        if (addComplianceLogs === null)
            throw new Error("The parameter 'addComplianceLogs' cannot be null.");
        else if (addComplianceLogs !== undefined)
            url_ += "AddComplianceLogs=" + encodeURIComponent("" + addComplianceLogs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSendActivityLog(_response);
        });
    }

    protected processGetSendActivityLog(response: AxiosResponse): Promise<ActivityLogDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ActivityLogDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityLogDto[]>(null as any);
    }

    /**
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param excludeExportedTransactions (optional) 
     * @param templateId (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    exportRemittanceFormattedFile(date_From: string | undefined, date_To: string | undefined, excludeExportedTransactions: boolean | undefined, templateId: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ExportRemittanceFormattedFileResultDto> {
        let url_ = this.baseUrl + "/api/Remittance/SendTransaction/ExportRemittanceFormattedFile?";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (excludeExportedTransactions === null)
            throw new Error("The parameter 'excludeExportedTransactions' cannot be null.");
        else if (excludeExportedTransactions !== undefined)
            url_ += "ExcludeExportedTransactions=" + encodeURIComponent("" + excludeExportedTransactions) + "&";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "TemplateId=" + encodeURIComponent("" + templateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportRemittanceFormattedFile(_response);
        });
    }

    protected processExportRemittanceFormattedFile(response: AxiosResponse): Promise<ExportRemittanceFormattedFileResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ExportRemittanceFormattedFileResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExportRemittanceFormattedFileResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    print(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Remittance/SendTransaction/Print?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrint(_response);
        });
    }

    protected processPrint(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class StockTransactionsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param providerId (optional) 
     * @param key (optional) 
     * @param date_From (optional) 
     * @param date_To (optional) 
     * @param branchIds (optional) 
     * @param settlementAmount_From (optional) 
     * @param settlementAmount_To (optional) 
     * @param settlementCurrencyId (optional) 
     * @param stockAmount_From (optional) 
     * @param stockAmount_To (optional) 
     * @param stockCurrencyId (optional) 
     * @param statuses (optional) 
     * @param stockBalance_From (optional) 
     * @param stockBalance_To (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(providerId: number | undefined, key: string | undefined, date_From: string | undefined, date_To: string | undefined, branchIds: number[] | undefined, settlementAmount_From: number | undefined, settlementAmount_To: number | undefined, settlementCurrencyId: number | undefined, stockAmount_From: number | undefined, stockAmount_To: number | undefined, stockCurrencyId: number | undefined, statuses: StockTransactionStatuses[] | undefined, stockBalance_From: number | undefined, stockBalance_To: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<StockTransactionListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/StockTransactions/GetPaginatedList?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "ProviderId=" + encodeURIComponent("" + providerId) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (date_From === null)
            throw new Error("The parameter 'date_From' cannot be null.");
        else if (date_From !== undefined)
            url_ += "Date.From=" + encodeURIComponent("" + date_From) + "&";
        if (date_To === null)
            throw new Error("The parameter 'date_To' cannot be null.");
        else if (date_To !== undefined)
            url_ += "Date.To=" + encodeURIComponent("" + date_To) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (settlementAmount_From === null)
            throw new Error("The parameter 'settlementAmount_From' cannot be null.");
        else if (settlementAmount_From !== undefined)
            url_ += "SettlementAmount.From=" + encodeURIComponent("" + settlementAmount_From) + "&";
        if (settlementAmount_To === null)
            throw new Error("The parameter 'settlementAmount_To' cannot be null.");
        else if (settlementAmount_To !== undefined)
            url_ += "SettlementAmount.To=" + encodeURIComponent("" + settlementAmount_To) + "&";
        if (settlementCurrencyId === null)
            throw new Error("The parameter 'settlementCurrencyId' cannot be null.");
        else if (settlementCurrencyId !== undefined)
            url_ += "SettlementCurrencyId=" + encodeURIComponent("" + settlementCurrencyId) + "&";
        if (stockAmount_From === null)
            throw new Error("The parameter 'stockAmount_From' cannot be null.");
        else if (stockAmount_From !== undefined)
            url_ += "StockAmount.From=" + encodeURIComponent("" + stockAmount_From) + "&";
        if (stockAmount_To === null)
            throw new Error("The parameter 'stockAmount_To' cannot be null.");
        else if (stockAmount_To !== undefined)
            url_ += "StockAmount.To=" + encodeURIComponent("" + stockAmount_To) + "&";
        if (stockCurrencyId === null)
            throw new Error("The parameter 'stockCurrencyId' cannot be null.");
        else if (stockCurrencyId !== undefined)
            url_ += "StockCurrencyId=" + encodeURIComponent("" + stockCurrencyId) + "&";
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (stockBalance_From === null)
            throw new Error("The parameter 'stockBalance_From' cannot be null.");
        else if (stockBalance_From !== undefined)
            url_ += "StockBalance.From=" + encodeURIComponent("" + stockBalance_From) + "&";
        if (stockBalance_To === null)
            throw new Error("The parameter 'stockBalance_To' cannot be null.");
        else if (stockBalance_To !== undefined)
            url_ += "StockBalance.To=" + encodeURIComponent("" + stockBalance_To) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<StockTransactionListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<StockTransactionListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StockTransactionListDtoIPaginatedList>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<StockTransactionDto> {
        let url_ = this.baseUrl + "/api/Remittance/StockTransactions/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<StockTransactionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<StockTransactionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StockTransactionDto>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    add(branchIdHeader: string | undefined, body: AddStockTransactionDto | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/StockTransactions/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param actionDate_From (optional) 
     * @param actionDate_To (optional) 
     * @param actions (optional) 
     * @param actionById (optional) 
     * @param assignedToId (optional) 
     * @param referanceNumber (optional) 
     * @param addComplianceLogs (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getActivityLog(actionDate_From: string | undefined, actionDate_To: string | undefined, actions: ActivityLogAction[] | undefined, actionById: number[] | undefined, assignedToId: number[] | undefined, referanceNumber: string | undefined, addComplianceLogs: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ActivityLogDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/StockTransactions/GetActivityLog?";
        if (actionDate_From === null)
            throw new Error("The parameter 'actionDate_From' cannot be null.");
        else if (actionDate_From !== undefined)
            url_ += "ActionDate.From=" + encodeURIComponent("" + actionDate_From) + "&";
        if (actionDate_To === null)
            throw new Error("The parameter 'actionDate_To' cannot be null.");
        else if (actionDate_To !== undefined)
            url_ += "ActionDate.To=" + encodeURIComponent("" + actionDate_To) + "&";
        if (actions === null)
            throw new Error("The parameter 'actions' cannot be null.");
        else if (actions !== undefined)
            actions && actions.forEach(item => { url_ += "Actions=" + encodeURIComponent("" + item) + "&"; });
        if (actionById === null)
            throw new Error("The parameter 'actionById' cannot be null.");
        else if (actionById !== undefined)
            actionById && actionById.forEach(item => { url_ += "ActionById=" + encodeURIComponent("" + item) + "&"; });
        if (assignedToId === null)
            throw new Error("The parameter 'assignedToId' cannot be null.");
        else if (assignedToId !== undefined)
            assignedToId && assignedToId.forEach(item => { url_ += "AssignedToId=" + encodeURIComponent("" + item) + "&"; });
        if (referanceNumber === null)
            throw new Error("The parameter 'referanceNumber' cannot be null.");
        else if (referanceNumber !== undefined)
            url_ += "ReferanceNumber=" + encodeURIComponent("" + referanceNumber) + "&";
        if (addComplianceLogs === null)
            throw new Error("The parameter 'addComplianceLogs' cannot be null.");
        else if (addComplianceLogs !== undefined)
            url_ += "AddComplianceLogs=" + encodeURIComponent("" + addComplianceLogs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActivityLog(_response);
        });
    }

    protected processGetActivityLog(response: AxiosResponse): Promise<ActivityLogDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ActivityLogDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityLogDto[]>(null as any);
    }
}

export class TransactionsModificationClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param key (optional) 
     * @param number (optional) 
     * @param transactionId (optional) 
     * @param types (optional) 
     * @param modificationDate_From (optional) 
     * @param modificationDate_To (optional) 
     * @param modificationById (optional) 
     * @param branchIds (optional) 
     * @param statuses (optional) 
     * @param customerId (optional) 
     * @param customerName (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getPaginatedList(key: string | undefined, number: string | undefined, transactionId: number | undefined, types: ModificationTypes[] | undefined, modificationDate_From: string | undefined, modificationDate_To: string | undefined, modificationById: number | undefined, branchIds: number[] | undefined, statuses: ModificationStatuses[] | undefined, customerId: number | undefined, customerName: string | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<RemittanceModificationListDtoIPaginatedList> {
        let url_ = this.baseUrl + "/api/Remittance/TransactionsModification/GetPaginatedList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (transactionId === null)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else if (transactionId !== undefined)
            url_ += "TransactionId=" + encodeURIComponent("" + transactionId) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (modificationDate_From === null)
            throw new Error("The parameter 'modificationDate_From' cannot be null.");
        else if (modificationDate_From !== undefined)
            url_ += "ModificationDate.From=" + encodeURIComponent("" + modificationDate_From) + "&";
        if (modificationDate_To === null)
            throw new Error("The parameter 'modificationDate_To' cannot be null.");
        else if (modificationDate_To !== undefined)
            url_ += "ModificationDate.To=" + encodeURIComponent("" + modificationDate_To) + "&";
        if (modificationById === null)
            throw new Error("The parameter 'modificationById' cannot be null.");
        else if (modificationById !== undefined)
            url_ += "ModificationById=" + encodeURIComponent("" + modificationById) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPaginatedList(_response);
        });
    }

    protected processGetPaginatedList(response: AxiosResponse): Promise<RemittanceModificationListDtoIPaginatedList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<RemittanceModificationListDtoIPaginatedList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RemittanceModificationListDtoIPaginatedList>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getSendModificationById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<SendModificationDto> {
        let url_ = this.baseUrl + "/api/Remittance/TransactionsModification/GetSendModificationById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSendModificationById(_response);
        });
    }

    protected processGetSendModificationById(response: AxiosResponse): Promise<SendModificationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SendModificationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SendModificationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getReceiveModificationById(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<ReceiveModificationDto> {
        let url_ = this.baseUrl + "/api/Remittance/TransactionsModification/GetReceiveModificationById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReceiveModificationById(_response);
        });
    }

    protected processGetReceiveModificationById(response: AxiosResponse): Promise<ReceiveModificationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ReceiveModificationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiveModificationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param isSend (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getValidTransactionActions(id: number | undefined, isSend: boolean | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TransactionActions[]> {
        let url_ = this.baseUrl + "/api/Remittance/TransactionsModification/GetValidTransactionActions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (isSend === null)
            throw new Error("The parameter 'isSend' cannot be null.");
        else if (isSend !== undefined)
            url_ += "isSend=" + encodeURIComponent("" + isSend) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidTransactionActions(_response);
        });
    }

    protected processGetValidTransactionActions(response: AxiosResponse): Promise<TransactionActions[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionActions[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionActions[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param receiveTransactionId (optional) 
     * @param action (optional) 
     * @param remarks (optional) 
     * @param addAttachment_Files (optional) 
     * @return Success
     */
    setReceiveTransactionAction(branchIdHeader: string | undefined, receiveTransactionId: number | undefined, action: TransactionActions | undefined, remarks: string | undefined, addAttachment_Files: FileParameter[] | undefined, signal?: AbortSignal): Promise<TransactionStatuses> {
        let url_ = this.baseUrl + "/api/Remittance/TransactionsModification/SetReceiveTransactionAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (receiveTransactionId === null || receiveTransactionId === undefined)
            throw new Error("The parameter 'receiveTransactionId' cannot be null.");
        else
            content_.append("ReceiveTransactionId", receiveTransactionId.toString());
        if (action === null || action === undefined)
            throw new Error("The parameter 'action' cannot be null.");
        else
            content_.append("Action", action.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetReceiveTransactionAction(_response);
        });
    }

    protected processSetReceiveTransactionAction(response: AxiosResponse): Promise<TransactionStatuses> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionStatuses>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionStatuses>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param sendTransactionId (optional) 
     * @param action (optional) 
     * @param remarks (optional) 
     * @param addAttachment_Files (optional) 
     * @param purposeId (optional) 
     * @param sourceOfFundId (optional) 
     * @param counterParty_Name (optional) 
     * @param counterParty_NameLang (optional) 
     * @param counterParty_Type (optional) 
     * @param counterParty_NationalityId (optional) 
     * @param counterParty_Address (optional) 
     * @param counterParty_Phone (optional) 
     * @param counterParty_RelationId (optional) 
     * @param counterParty_EmirateCode (optional) 
     * @param counterParty_NearestAirport (optional) 
     * @param counterParty_CounterPartyBank_BankCode (optional) 
     * @param counterParty_CounterPartyBank_BankName (optional) 
     * @param counterParty_CounterPartyBank_BranchCode (optional) 
     * @param counterParty_CounterPartyBank_BranchName (optional) 
     * @param counterParty_CounterPartyBank_BankAddress (optional) 
     * @param counterParty_CounterPartyBank_AccountNumber (optional) 
     * @return Success
     */
    setSendTransactionAction(branchIdHeader: string | undefined, sendTransactionId: number | undefined, action: TransactionActions | undefined, remarks: string | undefined, addAttachment_Files: FileParameter[] | undefined, purposeId: number | undefined, sourceOfFundId: number | undefined, counterParty_Name: string | undefined, counterParty_NameLang: string | undefined, counterParty_Type: CustomerTypes | undefined, counterParty_NationalityId: number | undefined, counterParty_Address: string | undefined, counterParty_Phone: string | undefined, counterParty_RelationId: number | undefined, counterParty_EmirateCode: string | undefined, counterParty_NearestAirport: string | undefined, counterParty_CounterPartyBank_BankCode: string | undefined, counterParty_CounterPartyBank_BankName: string | undefined, counterParty_CounterPartyBank_BranchCode: string | undefined, counterParty_CounterPartyBank_BranchName: string | undefined, counterParty_CounterPartyBank_BankAddress: string | undefined, counterParty_CounterPartyBank_AccountNumber: string | undefined, signal?: AbortSignal): Promise<TransactionStatuses> {
        let url_ = this.baseUrl + "/api/Remittance/TransactionsModification/SetSendTransactionAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (sendTransactionId === null || sendTransactionId === undefined)
            throw new Error("The parameter 'sendTransactionId' cannot be null.");
        else
            content_.append("SendTransactionId", sendTransactionId.toString());
        if (action === null || action === undefined)
            throw new Error("The parameter 'action' cannot be null.");
        else
            content_.append("Action", action.toString());
        if (remarks === null || remarks === undefined)
            throw new Error("The parameter 'remarks' cannot be null.");
        else
            content_.append("Remarks", remarks.toString());
        if (addAttachment_Files === null || addAttachment_Files === undefined)
            throw new Error("The parameter 'addAttachment_Files' cannot be null.");
        else
            addAttachment_Files.forEach(item_ => content_.append("AddAttachment.Files", item_.data, item_.fileName ? item_.fileName : "AddAttachment.Files") );
        if (purposeId === null || purposeId === undefined)
            throw new Error("The parameter 'purposeId' cannot be null.");
        else
            content_.append("PurposeId", purposeId.toString());
        if (sourceOfFundId === null || sourceOfFundId === undefined)
            throw new Error("The parameter 'sourceOfFundId' cannot be null.");
        else
            content_.append("SourceOfFundId", sourceOfFundId.toString());
        if (counterParty_Name === null || counterParty_Name === undefined)
            throw new Error("The parameter 'counterParty_Name' cannot be null.");
        else
            content_.append("CounterParty.Name", counterParty_Name.toString());
        if (counterParty_NameLang === null || counterParty_NameLang === undefined)
            throw new Error("The parameter 'counterParty_NameLang' cannot be null.");
        else
            content_.append("CounterParty.NameLang", counterParty_NameLang.toString());
        if (counterParty_Type === null || counterParty_Type === undefined)
            throw new Error("The parameter 'counterParty_Type' cannot be null.");
        else
            content_.append("CounterParty.Type", counterParty_Type.toString());
        if (counterParty_NationalityId === null || counterParty_NationalityId === undefined)
            throw new Error("The parameter 'counterParty_NationalityId' cannot be null.");
        else
            content_.append("CounterParty.NationalityId", counterParty_NationalityId.toString());
        if (counterParty_Address === null || counterParty_Address === undefined)
            throw new Error("The parameter 'counterParty_Address' cannot be null.");
        else
            content_.append("CounterParty.Address", counterParty_Address.toString());
        if (counterParty_Phone === null || counterParty_Phone === undefined)
            throw new Error("The parameter 'counterParty_Phone' cannot be null.");
        else
            content_.append("CounterParty.Phone", counterParty_Phone.toString());
        if (counterParty_RelationId === null || counterParty_RelationId === undefined)
            throw new Error("The parameter 'counterParty_RelationId' cannot be null.");
        else
            content_.append("CounterParty.RelationId", counterParty_RelationId.toString());
        if (counterParty_EmirateCode === null || counterParty_EmirateCode === undefined)
            throw new Error("The parameter 'counterParty_EmirateCode' cannot be null.");
        else
            content_.append("CounterParty.EmirateCode", counterParty_EmirateCode.toString());
        if (counterParty_NearestAirport === null || counterParty_NearestAirport === undefined)
            throw new Error("The parameter 'counterParty_NearestAirport' cannot be null.");
        else
            content_.append("CounterParty.NearestAirport", counterParty_NearestAirport.toString());
        if (counterParty_CounterPartyBank_BankCode === null || counterParty_CounterPartyBank_BankCode === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BankCode' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BankCode", counterParty_CounterPartyBank_BankCode.toString());
        if (counterParty_CounterPartyBank_BankName === null || counterParty_CounterPartyBank_BankName === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BankName' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BankName", counterParty_CounterPartyBank_BankName.toString());
        if (counterParty_CounterPartyBank_BranchCode === null || counterParty_CounterPartyBank_BranchCode === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BranchCode' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BranchCode", counterParty_CounterPartyBank_BranchCode.toString());
        if (counterParty_CounterPartyBank_BranchName === null || counterParty_CounterPartyBank_BranchName === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BranchName' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BranchName", counterParty_CounterPartyBank_BranchName.toString());
        if (counterParty_CounterPartyBank_BankAddress === null || counterParty_CounterPartyBank_BankAddress === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_BankAddress' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.BankAddress", counterParty_CounterPartyBank_BankAddress.toString());
        if (counterParty_CounterPartyBank_AccountNumber === null || counterParty_CounterPartyBank_AccountNumber === undefined)
            throw new Error("The parameter 'counterParty_CounterPartyBank_AccountNumber' cannot be null.");
        else
            content_.append("CounterParty.CounterPartyBank.AccountNumber", counterParty_CounterPartyBank_AccountNumber.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetSendTransactionAction(_response);
        });
    }

    protected processSetSendTransactionAction(response: AxiosResponse): Promise<TransactionStatuses> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransactionStatuses>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionStatuses>(null as any);
    }

    /**
     * @param key (optional) 
     * @param number (optional) 
     * @param transactionId (optional) 
     * @param types (optional) 
     * @param modificationDate_From (optional) 
     * @param modificationDate_To (optional) 
     * @param modificationById (optional) 
     * @param branchIds (optional) 
     * @param statuses (optional) 
     * @param customerId (optional) 
     * @param customerName (optional) 
     * @param exportAs (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    export(key: string | undefined, number: string | undefined, transactionId: number | undefined, types: ModificationTypes[] | undefined, modificationDate_From: string | undefined, modificationDate_To: string | undefined, modificationById: number | undefined, branchIds: number[] | undefined, statuses: ModificationStatuses[] | undefined, customerId: number | undefined, customerName: string | undefined, exportAs: ReportTypes | undefined, pageNumber: number | undefined, pageSize: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<FileDto> {
        let url_ = this.baseUrl + "/api/Remittance/TransactionsModification/Export?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (transactionId === null)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else if (transactionId !== undefined)
            url_ += "TransactionId=" + encodeURIComponent("" + transactionId) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            types && types.forEach(item => { url_ += "Types=" + encodeURIComponent("" + item) + "&"; });
        if (modificationDate_From === null)
            throw new Error("The parameter 'modificationDate_From' cannot be null.");
        else if (modificationDate_From !== undefined)
            url_ += "ModificationDate.From=" + encodeURIComponent("" + modificationDate_From) + "&";
        if (modificationDate_To === null)
            throw new Error("The parameter 'modificationDate_To' cannot be null.");
        else if (modificationDate_To !== undefined)
            url_ += "ModificationDate.To=" + encodeURIComponent("" + modificationDate_To) + "&";
        if (modificationById === null)
            throw new Error("The parameter 'modificationById' cannot be null.");
        else if (modificationById !== undefined)
            url_ += "ModificationById=" + encodeURIComponent("" + modificationById) + "&";
        if (branchIds === null)
            throw new Error("The parameter 'branchIds' cannot be null.");
        else if (branchIds !== undefined)
            branchIds && branchIds.forEach(item => { url_ += "BranchIds=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (customerName === null)
            throw new Error("The parameter 'customerName' cannot be null.");
        else if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&";
        if (exportAs === null)
            throw new Error("The parameter 'exportAs' cannot be null.");
        else if (exportAs !== undefined)
            url_ += "ExportAs=" + encodeURIComponent("" + exportAs) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FileDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDto>(null as any);
    }
}

export class TransferableCountryClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param supportedTransactions (optional) 
     * @param name (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(supportedTransactions: SupportedTransactionsFilter | undefined, name: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TransferableCountryDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/TransferableCountry/GetList?";
        if (supportedTransactions === null)
            throw new Error("The parameter 'supportedTransactions' cannot be null.");
        else if (supportedTransactions !== undefined)
            url_ += "SupportedTransactions=" + encodeURIComponent("" + supportedTransactions) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<TransferableCountryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransferableCountryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransferableCountryDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    set(branchIdHeader: string | undefined, body: SetTransferableCountryDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Remittance/TransferableCountry/Set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSet(_response);
        });
    }

    protected processSet(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/TransferableCountry/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export class TransferableCurrencyClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param supportedTransactions (optional) 
     * @param name (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    getList(supportedTransactions: SupportedTransactionsFilter | undefined, name: string | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<TransferableCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Remittance/TransferableCurrency/GetList?";
        if (supportedTransactions === null)
            throw new Error("The parameter 'supportedTransactions' cannot be null.");
        else if (supportedTransactions !== undefined)
            url_ += "SupportedTransactions=" + encodeURIComponent("" + supportedTransactions) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: AxiosResponse): Promise<TransferableCurrencyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<TransferableCurrencyDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransferableCurrencyDto[]>(null as any);
    }

    /**
     * @param branchIdHeader (optional) 
     * @param body (optional) 
     * @return Success
     */
    set(branchIdHeader: string | undefined, body: SetTransferableCurrencyDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Remittance/TransferableCurrency/Set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSet(_response);
        });
    }

    protected processSet(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param branchIdHeader (optional) 
     * @return Success
     */
    delete(id: number | undefined, branchIdHeader: string | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Remittance/TransferableCurrency/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "BranchIdHeader": branchIdHeader !== undefined && branchIdHeader !== null ? "" + branchIdHeader : "",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export enum ActivityLogAction {
    AMLCheck = "AMLCheck",
    AMLRecheck = "AMLRecheck",
    Block = "Block",
    Release = "Release",
    Escalate = "Escalate",
    Returned = "Returned",
    Comment = "Comment",
    Reassign = "Reassign",
    Case = "Case",
    Create = "Create",
    Edit = "Edit",
    Cancel = "Cancel",
    Refund = "Refund",
    Approve = "Approve",
    Reject = "Reject",
    Cash = "Cash",
}

export interface ActivityLogDto {
    actionDate?: string;
    actionName?: string | null;
    actionBy?: string | null;
    actionById?: number | null;
    assignedTo?: string | null;
    remarks?: string | null;
    status?: string | null;
    transactionType?: string | null;
    referenceNumber?: string | null;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
    attachments?: AttachmentDto[] | null;
}

export interface AddFeeProfileDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    feeProfileDetails?: FeeProfileDetailDto[] | null;
}

export interface AddMarginDetailDto {
    id?: number;
    amountRangeBegin?: number;
    amountRangeEnd?: number;
    customerRateMarginPercent?: number | null;
    ourMarginPercent?: number | null;
}

export interface AddMarginDto {
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
    supportedTransaction?: SupportedTransactions;
    providerIds?: number[] | null;
    sendCurrencyIds?: number[] | null;
    receiveCurrencyIds?: number[] | null;
    countryIds?: number[] | null;
    deliveryMethodIds?: number[] | null;
    branchIds?: number[] | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    marginDetails?: AddMarginDetailDto[] | null;
}

export interface AddReceiveProfileDto {
    providerId: number;
    sourceCountryId: number;
    receiveCurrencyId: number;
    deliveryMethodId: number;
    ourFeeProfileId?: number | null;
    providerFeeProfileId?: number | null;
    receiveAmountLimit?: number | null;
    limitAccumulation?: LimitAccumulations;
    accumulationDays?: number | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
}

export interface AddReceiveTransactionResultDto {
    id?: number;
    status?: TransactionStatuses;
}

export interface AddSendProfileDto {
    branchId?: number | null;
    providerId: number;
    receiveCountryId: number;
    sendCurrencyId: number;
    receiveCurrencyId: number;
    deliveryMethodId: number;
    payerName: string;
    payerNameLang?: string | null;
    serviceTime: string;
    serviceTimeLang?: string | null;
    ourFeeProfileId?: number | null;
    providerFeeProfileId?: number | null;
    sendAmountLimit?: number | null;
    limitAccumulation?: LimitAccumulations;
    accumulationDays?: number | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    sendProfileRates?: AddSendProfileRateDto[] | null;
}

export interface AddSendProfileRateDto {
    id?: number;
    amountRangeBegin?: number;
    amountRangeEnd?: number;
    customerMinRate: number;
    customerMaxRate: number;
    costRate: number;
}

export interface AddSendTransactionResultDto {
    id?: number;
    status?: TransactionStatuses;
}

export interface AddStockTransactionDto {
    providerId?: number;
    settlementCurrencyId?: number;
    settlementAmount?: number;
    settlementRate?: number;
    stockCurrencyId?: number;
    stockAmount?: number;
    reference?: string | null;
}

export interface AttachmentDto {
    id?: number;
    files?: FileDto[] | null;
}

export interface BranchDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    phone?: string | null;
    address?: string | null;
    landMark?: string | null;
    email?: string | null;
    active?: boolean;
    companyName?: string | null;
    countryName?: string | null;
    cityName?: string | null;
    managerName?: string | null;
    managerMobile?: string | null;
}

export interface ChangeExportRecordResultStatusDto {
    id?: number;
    exportRecordStatus?: ExportRecordStatus;
    reasons?: string | null;
}

export interface ChangeStatusModel {
    ids: number[];
    active: boolean;
    reason?: string | null;
}

export enum Channels {
    FaceToFace = "FaceToFace",
    NonFaceToFace = "NonFaceToFace",
}

export interface CounterPartyBankDto {
    bankCode?: string | null;
    bankName?: string | null;
    branchCode?: string | null;
    branchName?: string | null;
    bankAddress?: string | null;
    accountNumber?: string | null;
    transferMode?: string | null;
}

export interface CounterPartyDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    type?: CustomerTypes;
    nationality?: CountryDto;
    country?: CountryDto;
    address?: string | null;
    phone?: string | null;
    emirateCode?: string | null;
    nearestAirport?: string | null;
    relation?: RelationDto;
    counterPartyBank?: CounterPartyBankDto;
}

export interface CounterPartyDtoIPaginatedList {
    readonly items?: CounterPartyDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum CounterPartyTypes {
    Sender = "Sender",
    Receiver = "Receiver",
}

export interface CountryDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    iso3Code?: string | null;
    countryCode?: string | null;
    active?: boolean;
    aliases?: string[] | null;
    currencyId?: number;
}

export interface CustomerAddressDto {
    id?: number;
    addressType?: CustomerLookupModel;
    addressTypeId?: number;
    country?: SimpleCountryDto;
    countryId?: number;
    city?: SimpleCityDto;
    cityId?: number;
    district?: string | null;
    street?: string | null;
    detailedAddress?: string | null;
    permanentAddress?: string | null;
    building?: string | null;
    poBox?: string | null;
    isMain?: boolean;
}

export interface CustomerBeneficiariesModel {
    counterPartyType?: CounterPartyTypes;
    name?: string | null;
    type?: CustomerTypes;
    nationality?: CountryDto;
    relation?: RelationDto;
    phone?: string | null;
    address?: string | null;
    country?: CountryDto;
    counterPartyBank?: CounterPartyBankDto;
}

export interface CustomerIdentityTransactionDto {
    id?: number;
    name?: string | null;
    type?: CustomerTypes;
    nationality?: CountryDto;
    date?: string;
    identity?: CustomerSimpleIdentityDto;
    address?: CustomerAddressDto;
    phone?: string | null;
}

export interface CustomerLookupModel {
    id?: number;
    name?: string | null;
    active?: boolean;
}

export interface CustomerSimpleIdentityDto {
    id?: number;
    identityType?: IdentityTypeDto;
    identityTypeId?: number;
    identityTypeName?: string | null;
    identityNumber?: string | null;
    nationalNo?: string | null;
    issuePlace?: SimpleCountryDto;
    issuePlaceId?: number;
    issueDate?: string;
    expiryDate?: string;
    isMain?: boolean;
}

export enum CustomerTypes {
    Person = "Person",
    Corporate = "Corporate",
}

export interface DeliveryMethodDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
}

export interface DeliveryMethodDtoIPaginatedList {
    readonly items?: DeliveryMethodDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface ExportLogDto {
    id?: number;
    templateName?: string | null;
    providerId?: number;
    provider?: SimpleProviderLookupDto;
    templateFileId?: number;
    templateFile?: FileDto;
    fileId?: number;
    file?: FileDto;
    fromDate?: string | null;
    toDate?: string | null;
    successRecordsCount?: number;
    failRecordsCount?: number;
    createdById?: number;
    createdBy?: string | null;
}

export interface ExportLogDtoIPaginatedList {
    readonly items?: ExportLogDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface ExportRecordDto {
    id?: number;
    exportLogId?: number;
    sendTransactionId?: number;
    sendTransaction?: SendTransactionExportDto;
    status?: ExportRecordStatus;
    reasons?: string[] | null;
}

export interface ExportRecordDtoIPaginatedList {
    readonly items?: ExportRecordDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum ExportRecordStatus {
    Success = "Success",
    Failed = "Failed",
    Repaired = "Repaired",
}

export interface ExportRemittanceFormattedFileItemResult {
    id?: number;
    number?: string | null;
    reasons?: string[] | null;
}

export interface ExportRemittanceFormattedFileResultDto {
    file?: FileDto;
    failRecordsCount?: number;
    mappedRecordsCount?: number;
    unMappedTransactions?: ExportRemittanceFormattedFileItemResult[] | null;
}

export interface ExportTemplateDto {
    id?: number;
    templateName?: string | null;
    providerId?: number;
    provider?: SimpleProviderLookupDto;
    templateFileId?: number;
    templateFile?: FileDto;
}

export interface ExportTemplateDtoIPaginatedList {
    readonly items?: ExportTemplateDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface FeeModel {
    ourFee?: number;
    providerFee?: number;
}

export interface FeeProfileDetailDto {
    id?: number;
    amountRangeBegin?: number;
    amountRangeEnd?: number;
    fixedFee?: number;
    percentFee?: number;
}

export interface FeeProfileDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    active?: boolean;
    feeProfileDetails?: FeeProfileDetailDto[] | null;
}

export interface FeeProfileDtoIPaginatedList {
    readonly items?: FeeProfileDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface FeeProfileLookupDto {
    id?: number;
    name?: string | null;
    code?: string | null;
}

export interface FileDto {
    id?: number;
    name?: string | null;
    extension?: string | null;
    link?: string | null;
    created?: string;
}

export interface FullDeliveryMethodDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface FullFeeProfileDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code?: string | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    feeProfileDetails?: FeeProfileDetailDto[] | null;
    active?: boolean;
}

export interface FullMarginDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code?: string | null;
    supportedTransaction?: SupportedTransactions;
    providerIds?: number[] | null;
    sendCurrencyIds?: number[] | null;
    receiveCurrencyIds?: number[] | null;
    countryIds?: number[] | null;
    deliveryMethodIds?: number[] | null;
    branchIds?: number[] | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    marginDetails?: AddMarginDetailDto[] | null;
    active?: boolean;
}

export interface FullProviderDto {
    id?: number;
    name?: string | null;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    integrationType?: ProviderTypes;
    settlementType?: SettlementTypes;
    supportedTransaction?: SupportedTransactions;
    logo?: string | null;
    countryId?: number | null;
    ourSendFeeProfileId?: number | null;
    providerSendFeeProfileId?: number | null;
    ourReceiveFeeProfileId?: number | null;
    providerReceiveFeeProfileId?: number | null;
    logoFile?: FileDto;
    logoFileId?: number | null;
    country?: CountryDto;
    isInternational?: boolean;
    ourSendFeeProfile?: FeeProfileDto;
    providerSendFeeProfile?: FeeProfileDto;
    ourReceiveFeeProfile?: FeeProfileDto;
    providerReceiveFeeProfile?: FeeProfileDto;
    providerSettlementCurrencies?: ProviderSettlementCurrencyDto[] | null;
    active?: boolean;
}

export interface IFSCDto {
    code?: string | null;
    bank?: string | null;
    branch?: string | null;
    address?: string | null;
    city1?: string | null;
    city2?: string | null;
    state?: string | null;
    stdCode?: string | null;
    phone?: string | null;
}

export interface IdentityTypeDto {
    id?: number;
    name?: string | null;
    active?: boolean;
    customerType?: CustomerTypes;
    isThereNationalNo?: boolean;
    isThereExpiry?: boolean;
    isAttachmentRequired?: boolean;
    aliases?: string[] | null;
}

export enum LimitAccumulations {
    PerTransaction = "PerTransaction",
    PerCustomer = "PerCustomer",
    AllTransactions = "AllTransactions",
}

export interface MarginDetailDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    customerRateMarginPercent?: number | null;
    ourMarginPercent?: number | null;
}

export interface MarginDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    supportedTransaction?: SupportedTransactions;
    providers?: SimpleProviderLookupDto[] | null;
    sendCurrencies?: SimpleCurrencyDto[] | null;
    receiveCurrencies?: SimpleCurrencyDto[] | null;
    countries?: CountryDto[] | null;
    deliveryMethods?: DeliveryMethodDto[] | null;
    branches?: SimpleBranchDto[] | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    active?: boolean;
    marginDetails?: AddMarginDetailDto[] | null;
}

export interface MarginListDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    supportedTransaction?: SupportedTransactions;
    hasMultipleProviders?: boolean;
    provider?: SimpleProviderLookupDto;
    hasMultipleSendCurrencies?: boolean;
    sendCurrency?: SimpleCurrencyDto;
    hasMultipleReceiveCurrencies?: boolean;
    receiveCurrency?: SimpleCurrencyDto;
    hasMultipleCountries?: boolean;
    country?: CountryDto;
    hasMultipleDeliveryMethods?: boolean;
    deliveryMethod?: DeliveryMethodDto;
    hasMultipleBranches?: boolean;
    branch?: SimpleBranchDto;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    active?: boolean;
    marginDetails?: AddMarginDetailDto[] | null;
}

export interface MarginLookupDto {
    id?: number;
    name?: string | null;
    code?: string | null;
}

export enum ModificationStatuses {
    PendingForApproval = "PendingForApproval",
    Approved = "Approved",
    Rejected = "Rejected",
    PendingForCash = "PendingForCash",
    PendingForCompliance = "PendingForCompliance",
    Blocked = "Blocked",
}

export enum ModificationTypes {
    Cancel = "Cancel",
    Refund = "Refund",
    Edit = "Edit",
}

export enum PaymentModes {
    Cash = "Cash",
    NonCash = "NonCash",
}

export interface ProviderDto {
    id?: number;
    name?: string | null;
    integrationType?: ProviderTypes;
    settlementType?: SettlementTypes;
    supportedTransaction?: SupportedTransactions;
    logoFile?: FileDto;
    country?: CountryDto;
    isInternational?: boolean;
    ourSendFeeProfile?: FeeProfileDto;
    providerSendFeeProfile?: FeeProfileDto;
    ourReceiveFeeProfile?: FeeProfileDto;
    providerReceiveFeeProfile?: FeeProfileDto;
    active?: boolean;
}

export interface ProviderSettlementCurrencyDto {
    id?: number;
    settlementCurrency?: SimpleCurrencyDto;
    settlementRate?: number;
    creditLimit?: number | null;
    balance?: number;
    active?: boolean;
}

export interface ProviderStockCurrencyListDto {
    id?: number;
    stockCurrency?: SimpleCurrencyDto;
    settlementCurrency?: SimpleCurrencyDto;
    costRate?: number | null;
    creditLimit?: number | null;
    balance?: number;
    active?: boolean;
}

export enum ProviderTypes {
    Online = "Online",
    Offline = "Offline",
    Manual = "Manual",
}

export interface PurposeDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
}

export interface ReceiveModificationDto {
    id?: number;
    number?: string | null;
    receiveTransactionId?: number;
    type?: ModificationTypes;
    modificationDate?: string;
    modificationBy?: SimpleApplicationUserDto;
    modificationById?: number;
    branch?: SimpleBranchDto;
    branchId?: number;
    status?: ModificationStatuses;
}

export interface ReceiveProfileDto {
    id?: number;
    providerId?: number;
    sourceCountry?: CountryDto;
    receiveCurrency?: SimpleCurrencyDto;
    deliveryMethod?: DeliveryMethodDto;
    ourFeeProfile?: FeeProfileDto;
    providerFeeProfile?: FeeProfileDto;
    receiveAmountLimit?: number | null;
    limitAccumulation?: LimitAccumulations;
    accumulationDays?: number | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    active?: boolean;
}

export interface ReceiveProfileDtoIPaginatedList {
    readonly items?: ReceiveProfileDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface ReceiveReportModel {
    id?: number;
    created?: string;
    branch?: BranchDto;
    number?: string | null;
    provider?: string | null;
    country?: CountryDto;
    receiver?: string | null;
    sender?: string | null;
    payoutFCAmount?: number;
    payoutLCAmount?: number;
    providerFees?: number;
    ourFees?: number;
    deliveryMethod?: DeliveryMethodDto;
    status?: TransactionStatuses;
    user?: string | null;
    payoutFCAmountWithCurrency?: string | null;
    payoutLCAmountWithCurrency?: string | null;
}

export interface ReceiveReportModelIPaginatedList {
    readonly items?: ReceiveReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface ReceiveTransactionDto {
    id?: number;
    type?: TransactionTypes;
    number?: string | null;
    reference?: string | null;
    created?: string;
    createdBy?: string | null;
    branch?: SimpleBranchDto;
    customerIdentity?: CustomerIdentityTransactionDto;
    delegateIdentity?: CustomerIdentityTransactionDto;
    delegateIdentityId?: number | null;
    country?: CountryDto;
    payoutCurrency?: SimpleCurrencyDto;
    payoutFCAmount?: number;
    payoutLCAmount?: number;
    rate?: number;
    fees?: number;
    rounding?: number;
    tax?: number;
    totalPaidAmount?: number;
    riskScore?: number;
    purpose?: PurposeDto;
    sourceOfFund?: SourceOfFundDto;
    notes?: string | null;
    message?: string | null;
    status?: TransactionStatuses;
    counterParty?: CounterPartyDto;
    provider?: SimpleProviderDto;
    deliveryMethod?: DeliveryMethodDto;
    channel?: Channels;
    paymentMode?: PaymentModes;
    lastModificationType?: ModificationTypes;
    lastModificationStatus?: ModificationStatuses;
    lastModificationAttachment?: AttachmentDto;
    lastModificationRemarks?: string | null;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
}

export interface ReceiveTransactionPermissions {
    isFessEditable?: boolean;
    isAmountEditable?: boolean;
    isCurrencyEditable?: boolean;
    isDeliveryMethodEditable?: boolean;
    isPurposeEditable?: boolean;
    isSourceOfFundsEditable?: boolean;
}

export interface RelationDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
}

export interface RemittanceModificationListDto {
    id?: number;
    number?: string | null;
    transactionNumber?: string | null;
    transactionId?: number;
    transactionType?: SupportedTransactionsFilter;
    type?: ModificationTypes;
    modificationDate?: string;
    modificationBy?: string | null;
    modificationById?: number;
    branch?: SimpleBranchDto;
    branchId?: number;
    status?: ModificationStatuses;
}

export interface RemittanceModificationListDtoIPaginatedList {
    readonly items?: RemittanceModificationListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface RemittanceTransactionListDto {
    id?: number;
    created?: string;
    readonly formatedCreationDate?: string | null;
    number?: string | null;
    customerName?: string | null;
    customerNameLang?: string | null;
    customerId?: number;
    branch?: SimpleBranchDto;
    type?: SupportedTransactionsFilter;
    country?: SimpleCountryDto;
    status?: TransactionStatuses;
    statusEnumNumber?: string | null;
    amount?: number;
    providerName?: string | null;
    fees?: number;
    vat?: number;
    total?: number;
    message?: string | null;
    currency?: SimpleCurrencyDto;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
    exported?: boolean | null;
}

export interface RemittanceTransactionListDtoIPaginatedList {
    readonly items?: RemittanceTransactionListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum ReportTypes {
    Pdf = "Pdf",
    Excel = "Excel",
}

export interface SendModificationDto {
    id?: number;
    number?: string | null;
    sendTransactionId?: number;
    type?: ModificationTypes;
    purpose?: PurposeDto;
    purposeId?: number | null;
    sourceOfFund?: SourceOfFundDto;
    sourceOfFundId?: number | null;
    counterParty?: CounterPartyDto;
    counterPartyId?: number | null;
    modificationDate?: string;
    modificationBy?: SimpleApplicationUserDto;
    modificationById?: number;
    branch?: SimpleBranchDto;
    branchId?: number;
    status?: ModificationStatuses;
    riskScore?: number;
}

export interface SendProfileDto {
    id?: number;
    branch?: SimpleBranchDto;
    receiveCountry?: CountryDto;
    sendCurrency?: SimpleCurrencyDto;
    receiveCurrency?: SimpleCurrencyDto;
    deliveryMethod?: DeliveryMethodDto;
    payerName?: string | null;
    payerNameLang?: string | null;
    serviceTime?: string | null;
    serviceTimeLang?: string | null;
    ourFeeProfile?: FeeProfileDto;
    providerFeeProfile?: FeeProfileDto;
    sendAmountLimit?: number | null;
    limitAccumulation?: LimitAccumulations;
    accumulationDays?: number | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    active?: boolean;
    sendProfileRates?: AddSendProfileRateDto[] | null;
}

export interface SendProfileDtoIPaginatedList {
    readonly items?: SendProfileDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface SendProfileWithLogoDto {
    id?: number | null;
    providerId?: number;
    providerName?: string | null;
    payerName?: string | null;
    serviceTime?: string | null;
    ourFeeProfileId?: number | null;
    ourFeeProfileValue?: number | null;
    providerFeeProfileId?: number | null;
    providerFeeProfileValue?: number | null;
    customerMinRate?: number | null;
    customerMaxRate?: number | null;
    costRate?: number | null;
    sendAmountLimit?: number | null;
    limitAccumulation?: LimitAccumulations;
    accumulationDays?: number | null;
    logo?: FileDto;
    active?: boolean;
}

export interface SendReportModel {
    id?: number;
    created?: string;
    branch?: BranchDto;
    number?: string | null;
    provider?: string | null;
    country?: CountryDto;
    receiver?: string | null;
    sender?: string | null;
    sendCurrency?: SimpleCurrencyDto;
    sendFCAmount?: number;
    sendLCAmount?: number;
    receiveCurrency?: SimpleCurrencyDto;
    receiveAmount?: number;
    rate?: number;
    providerFees?: number;
    ourFees?: number;
    totalPaidAmount?: number;
    deliveryMethod?: DeliveryMethodDto;
    status?: TransactionStatuses;
    user?: string | null;
    sendFCAmountWithCurrency?: string | null;
    sendLCAmountWithCurrency?: string | null;
    receiveAmountWithCurrency?: string | null;
}

export interface SendReportModelIPaginatedList {
    readonly items?: SendReportModel[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export interface SendTransactionDto {
    id?: number;
    type?: TransactionTypes;
    number?: string | null;
    reference?: string | null;
    created?: string;
    createdBy?: string | null;
    branch?: SimpleBranchDto;
    customerIdentity?: CustomerIdentityTransactionDto;
    delegateIdentity?: CustomerIdentityTransactionDto;
    delegateIdentityId?: number | null;
    country?: CountryDto;
    sendCurrency?: SimpleCurrencyDto;
    sendFCAmount?: number;
    sendLCAmount?: number;
    receiveCurrency?: SimpleCurrencyDto;
    receiveFCAmount?: number;
    rate?: number;
    fees?: number;
    ourFees?: number;
    providerFees?: number;
    rounding?: number;
    tax?: number;
    totalPaidAmount?: number;
    riskScore?: number;
    counterParty?: CounterPartyDto;
    purpose?: PurposeDto;
    sourceOfFund?: SourceOfFundDto;
    lastCounterParty?: CounterPartyDto;
    lastPurpose?: PurposeDto;
    lastSourceOfFund?: SourceOfFundDto;
    notes?: string | null;
    message?: string | null;
    status?: TransactionStatuses;
    provider?: SimpleProviderDto;
    deliveryMethod?: DeliveryMethodDto;
    serviceTime?: string | null;
    payerName?: string | null;
    marginDetail?: MarginDetailDto;
    channel?: Channels;
    paymentMode?: PaymentModes;
    lastModificationType?: ModificationTypes;
    lastModificationStatus?: ModificationStatuses;
    lastModificationAttachment?: AttachmentDto;
    lastModificationRemarks?: string | null;
    attachment?: AttachmentDto;
    attachmentId?: number | null;
    exported?: boolean | null;
}

export interface SendTransactionExportDto {
    id?: number;
    number?: string | null;
    status?: TransactionStatuses;
    customerName?: string | null;
    customerId?: number;
    branch?: SimpleBranchDto;
    receiveCurrency?: SimpleCurrencyDto;
    receiveFCAmount?: number;
    created?: string;
}

export interface SendTransactionPermissions {
    isFessEditable?: boolean;
    isRateEditable?: boolean;
}

export interface SetTransferableCountryDto {
    id?: number;
    supportedTransaction?: SupportedTransactions;
}

export interface SetTransferableCurrencyDto {
    id?: number;
    supportedTransaction?: SupportedTransactions;
}

export enum SettlementTypes {
    Stock = "Stock",
    Deposit = "Deposit",
}

export interface SimpleApplicationUserDto {
    id?: number;
    email?: string | null;
    fullName?: string | null;
    branches?: SimpleBranchDto[] | null;
    mobile?: string | null;
}

export interface SimpleBranchDto {
    id?: number;
    name?: string | null;
    code?: string | null;
}

export interface SimpleCityDto {
    id?: number;
    name?: string | null;
}

export interface SimpleCountryDto {
    id?: number;
    name?: string | null;
}

export interface SimpleCurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
}

export interface SimpleProviderDto {
    id?: number;
    name?: string | null;
    integrationType?: ProviderTypes;
    settlementType?: SettlementTypes;
    supportedTransaction?: SupportedTransactions;
    logoFile?: FileDto;
    logoFileId?: number | null;
    country?: CountryDto;
    countryId?: number | null;
    isInternational?: boolean;
    active?: boolean;
}

export interface SimpleProviderLookupDto {
    id?: number;
    name?: string | null;
    integrationType?: ProviderTypes;
    settlementType?: SettlementTypes;
    supportedTransaction?: SupportedTransactions;
}

export interface SourceOfFundDto {
    id?: number;
    name?: string | null;
    description?: string | null;
    active?: boolean;
}

export interface StockTransactionDto {
    id?: number;
    created?: string;
    createdBy?: string | null;
    number?: string | null;
    branch?: SimpleBranchDto;
    reference?: string | null;
    settlementAmount?: number;
    settlementCurrency?: SimpleCurrencyDto;
    settlementRate?: number;
    stockAmount?: number;
    stockCurrency?: SimpleCurrencyDto;
    status?: StockTransactionStatuses;
    stockBalance?: number;
}

export interface StockTransactionListDto {
    id?: number;
    created?: string;
    number?: string | null;
    branch?: SimpleBranchDto;
    reference?: string | null;
    settlementAmount?: number;
    settlementCurrency?: SimpleCurrencyDto;
    settlementRate?: number;
    stockAmount?: number;
    stockCurrency?: SimpleCurrencyDto;
    status?: StockTransactionStatuses;
    stockBalance?: number;
}

export interface StockTransactionListDtoIPaginatedList {
    readonly items?: StockTransactionListDto[] | null;
    readonly pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
}

export enum StockTransactionStatuses {
    Completed = "Completed",
}

export enum SupportedTransactions {
    Send = "Send",
    Receive = "Receive",
    Both = "Both",
}

export enum SupportedTransactionsFilter {
    Send = "Send",
    Receive = "Receive",
}

export enum TransactionActions {
    Create = "Create",
    Cancel = "Cancel",
    Refund = "Refund",
    Cash = "Cash",
    Approve = "Approve",
    Reject = "Reject",
    Edit = "Edit",
}

export enum TransactionStatuses {
    PendingForCompliance = "PendingForCompliance",
    Blocked = "Blocked",
    PendingForCash = "PendingForCash",
    Completed = "Completed",
    PendingForCancel = "PendingForCancel",
    Canceled = "Canceled",
    PendingForRefund = "PendingForRefund",
    Refunded = "Refunded",
    ReadyForDelivery = "ReadyForDelivery",
    Delivered = "Delivered",
    PendingForEdit = "PendingForEdit",
    BlockedForRefund = "BlockedForRefund",
    BlockedForReserve = "BlockedForReserve",
    PendingForApproval = "PendingForApproval",
    Rejected = "Rejected",
    PendingForSenderApproval = "PendingForSenderApproval",
    PendingForReceiverApproval = "PendingForReceiverApproval",
    PendingForSenderCash = "PendingForSenderCash",
    PendingForReceiverCash = "PendingForReceiverCash",
    ComplianceProcessing = "ComplianceProcessing",
}

export enum TransactionTypes {
    FC_Sale = "FC_Sale",
    FC_Purchase = "FC_Purchase",
    SendMoney = "SendMoney",
    ReceiveMoney = "ReceiveMoney",
    Income = "Income",
    Expenses = "Expenses",
    InternalTransfer = "InternalTransfer",
    ExternalTransfer = "ExternalTransfer",
    StockTransaction = "StockTransaction",
}

export interface TransferableCountryDto {
    id?: number;
    name?: string | null;
    code?: string | null;
    iso3Code?: string | null;
    countryCode?: string | null;
    active?: boolean;
    aliases?: string[] | null;
    currencyId?: number;
    supportedTransaction?: SupportedTransactions;
}

export interface TransferableCurrencyDto {
    id?: number;
    name?: string | null;
    namePlural?: string | null;
    code?: string | null;
    symbol?: string | null;
    decimalDigits?: number;
    rounding?: number;
    active?: boolean;
    isLocked?: boolean;
    isBaseCurrency?: boolean;
    supportedTransaction?: SupportedTransactions;
}

export interface UpdateDeliveryMethodDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
}

export interface UpdateExportTemplateDto {
    id?: number;
    templateName?: string | null;
    templateFile?: string | null;
}

export interface UpdateFeeProfileDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    feeProfileDetails?: FeeProfileDetailDto[] | null;
}

export interface UpdateMarginDto {
    id: number;
    name: string;
    nameLang?: string | null;
    description?: string | null;
    descriptionLang?: string | null;
    code: string;
    supportedTransaction?: SupportedTransactions;
    providerIds?: number[] | null;
    sendCurrencyIds?: number[] | null;
    receiveCurrencyIds?: number[] | null;
    countryIds?: number[] | null;
    deliveryMethodIds?: number[] | null;
    branchIds?: number[] | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    setMarginDetails?: AddMarginDetailDto[] | null;
}

export interface UpdateProviderSettlementCurrencyDto {
    id?: number;
    settlementRate?: number;
    creditLimit?: number | null;
}

export interface UpdateProviderStockCurrencyDto {
    id?: number;
    creditLimit?: number | null;
}

export interface UpdateReceiveProfileDto {
    id: number;
    sourceCountryId: number;
    receiveCurrencyId: number;
    deliveryMethodId: number;
    ourFeeProfileId?: number | null;
    providerFeeProfileId?: number | null;
    receiveAmountLimit?: number | null;
    limitAccumulation?: LimitAccumulations;
    accumulationDays?: number | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
}

export interface UpdateSendProfileDto {
    id: number;
    branchId?: number | null;
    receiveCountryId: number;
    sendCurrencyId: number;
    receiveCurrencyId: number;
    deliveryMethodId: number;
    payerName: string;
    payerNameLang?: string | null;
    serviceTime: string;
    serviceTimeLang?: string | null;
    ourFeeProfileId?: number | null;
    providerFeeProfileId?: number | null;
    sendAmountLimit?: number | null;
    limitAccumulation?: LimitAccumulations;
    accumulationDays?: number | null;
    activeStartDate?: string | null;
    activeEndDate?: string | null;
    setSendProfileRates?: AddSendProfileRateDto[] | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}